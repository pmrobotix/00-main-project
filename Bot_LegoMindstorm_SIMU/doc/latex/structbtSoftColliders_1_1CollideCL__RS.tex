\hypertarget{structbtSoftColliders_1_1CollideCL__RS}{}\section{bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+RS Struct Reference}
\label{structbtSoftColliders_1_1CollideCL__RS}\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS}}


Inheritance diagram for bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+RS\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=221pt]{structbtSoftColliders_1_1CollideCL__RS__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+RS\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structbtSoftColliders_1_1CollideCL__RS__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{structbtSoftColliders_1_1CollideCL__RS_a020b9712f8e0c9c2dd901c93a1f97120}{Process} (const \hyperlink{structbtDbvtNode}{bt\+Dbvt\+Node} $\ast$leaf)
\item 
void \hyperlink{structbtSoftColliders_1_1CollideCL__RS_a34f463ddcfcda480e9843277d4bd732e}{Process\+Col\+Obj} (\hyperlink{classbtSoftBody}{bt\+Soft\+Body} $\ast$ps, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$col\+Ob\+Wrap)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structbtSoftColliders_1_1CollideCL__RS_a0662ec8322a255b1dbc22b8ae512cd9c}\label{structbtSoftColliders_1_1CollideCL__RS_a0662ec8322a255b1dbc22b8ae512cd9c}} 
\hyperlink{classbtSoftBody}{bt\+Soft\+Body} $\ast$ {\bfseries psb}
\item 
\mbox{\Hypertarget{structbtSoftColliders_1_1CollideCL__RS_a8e9189fbd214b4f700536892d098d0f4}\label{structbtSoftColliders_1_1CollideCL__RS_a8e9189fbd214b4f700536892d098d0f4}} 
const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$ {\bfseries m\+\_\+col\+Obj\+Wrap}
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{structbtSoftColliders_1_1CollideCL__RS_a020b9712f8e0c9c2dd901c93a1f97120}\label{structbtSoftColliders_1_1CollideCL__RS_a020b9712f8e0c9c2dd901c93a1f97120}} 
\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS}!Process@{Process}}
\index{Process@{Process}!bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS}}
\subsubsection{\texorpdfstring{Process()}{Process()}}
{\footnotesize\ttfamily void bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S\+::\+Process (\begin{DoxyParamCaption}\item[{const \hyperlink{structbtDbvtNode}{bt\+Dbvt\+Node} $\ast$}]{leaf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

don\textquotesingle{}t collide an anchored cluster with a static/kinematic object \mbox{\Hypertarget{structbtSoftColliders_1_1CollideCL__RS_a34f463ddcfcda480e9843277d4bd732e}\label{structbtSoftColliders_1_1CollideCL__RS_a34f463ddcfcda480e9843277d4bd732e}} 
\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS}!Process\+Col\+Obj@{Process\+Col\+Obj}}
\index{Process\+Col\+Obj@{Process\+Col\+Obj}!bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+RS}}
\subsubsection{\texorpdfstring{Process\+Col\+Obj()}{ProcessColObj()}}
{\footnotesize\ttfamily void bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S\+::\+Process\+Col\+Obj (\begin{DoxyParamCaption}\item[{\hyperlink{classbtSoftBody}{bt\+Soft\+Body} $\ast$}]{ps,  }\item[{const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$}]{col\+Ob\+Wrap }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Bullet rigid body uses multiply instead of minimum to determine combined friction. Some customization would be useful. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/pmx/git/\+P\+M\+X/\+Simu\+Cocos/cocos2d/external/bullet/\+Bullet\+Soft\+Body/bt\+Soft\+Body\+Internals.\+h\end{DoxyCompactItemize}
