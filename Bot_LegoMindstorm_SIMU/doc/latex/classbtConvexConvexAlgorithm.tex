\hypertarget{classbtConvexConvexAlgorithm}{}\section{bt\+Convex\+Convex\+Algorithm Class Reference}
\label{classbtConvexConvexAlgorithm}\index{bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}}


{\ttfamily \#include $<$bt\+Convex\+Convex\+Algorithm.\+h$>$}



Inheritance diagram for bt\+Convex\+Convex\+Algorithm\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=227pt]{classbtConvexConvexAlgorithm__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for bt\+Convex\+Convex\+Algorithm\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=227pt]{classbtConvexConvexAlgorithm__coll__graph}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structbtConvexConvexAlgorithm_1_1CreateFunc}{Create\+Func}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}\label{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}} 
\hyperlink{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}{bt\+Convex\+Convex\+Algorithm} (bt\+Persistent\+Manifold $\ast$mf, const \hyperlink{structbtCollisionAlgorithmConstructionInfo}{bt\+Collision\+Algorithm\+Construction\+Info} \&ci, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body0\+Wrap, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body1\+Wrap, bt\+Simplex\+Solver\+Interface $\ast$simplex\+Solver, \hyperlink{classbtConvexPenetrationDepthSolver}{bt\+Convex\+Penetration\+Depth\+Solver} $\ast$pd\+Solver, int num\+Perturbation\+Iterations, int minimum\+Points\+Perturbation\+Threshold)
\begin{DoxyCompactList}\small\item\em cache separating vector to speedup collision detection \end{DoxyCompactList}\item 
virtual void \hyperlink{classbtConvexConvexAlgorithm_ab566631355a17f7a4bcbddf9454eb9e5}{process\+Collision} (const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body0\+Wrap, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body1\+Wrap, const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$result\+Out)
\item 
virtual bt\+Scalar \hyperlink{classbtConvexConvexAlgorithm_a55f817b690c4e858d2b02607b382ce6b}{calculate\+Time\+Of\+Impact} (bt\+Collision\+Object $\ast$body0, bt\+Collision\+Object $\ast$body1, const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$result\+Out)
\item 
virtual void \hyperlink{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}{get\+All\+Contact\+Manifolds} (\hyperlink{classbtAlignedObjectArray}{bt\+Manifold\+Array} \&manifold\+Array)
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_a64464ed857fba6750ded542c47ee4e45}\label{classbtConvexConvexAlgorithm_a64464ed857fba6750ded542c47ee4e45}} 
void {\bfseries set\+Low\+Level\+Of\+Detail} (bool use\+Low\+Level)
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_a16a0cc2ea9ef78c3417ab93c3bfff012}\label{classbtConvexConvexAlgorithm_a16a0cc2ea9ef78c3417ab93c3bfff012}} 
const bt\+Persistent\+Manifold $\ast$ {\bfseries get\+Manifold} ()
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}\label{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}} 
\hyperlink{classbtConvexConvexAlgorithm_af60334d81e10602a003a0d92ae918af4}{bt\+Convex\+Convex\+Algorithm} (bt\+Persistent\+Manifold $\ast$mf, const \hyperlink{structbtCollisionAlgorithmConstructionInfo}{bt\+Collision\+Algorithm\+Construction\+Info} \&ci, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body0\+Wrap, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body1\+Wrap, bt\+Simplex\+Solver\+Interface $\ast$simplex\+Solver, \hyperlink{classbtConvexPenetrationDepthSolver}{bt\+Convex\+Penetration\+Depth\+Solver} $\ast$pd\+Solver, int num\+Perturbation\+Iterations, int minimum\+Points\+Perturbation\+Threshold)
\begin{DoxyCompactList}\small\item\em cache separating vector to speedup collision detection \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_afa59e68cdbba1206568fc7852db04ffc}\label{classbtConvexConvexAlgorithm_afa59e68cdbba1206568fc7852db04ffc}} 
virtual void {\bfseries process\+Collision} (const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body0\+Wrap, const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body1\+Wrap, const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$result\+Out)
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_ab1b11d40217f97c7cb41aaa7eedfb7f7}\label{classbtConvexConvexAlgorithm_ab1b11d40217f97c7cb41aaa7eedfb7f7}} 
virtual bt\+Scalar {\bfseries calculate\+Time\+Of\+Impact} (bt\+Collision\+Object $\ast$body0, bt\+Collision\+Object $\ast$body1, const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$result\+Out)
\item 
virtual void \hyperlink{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}{get\+All\+Contact\+Manifolds} (\hyperlink{classbtAlignedObjectArray}{bt\+Manifold\+Array} \&manifold\+Array)
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_a64464ed857fba6750ded542c47ee4e45}\label{classbtConvexConvexAlgorithm_a64464ed857fba6750ded542c47ee4e45}} 
void {\bfseries set\+Low\+Level\+Of\+Detail} (bool use\+Low\+Level)
\item 
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_a16a0cc2ea9ef78c3417ab93c3bfff012}\label{classbtConvexConvexAlgorithm_a16a0cc2ea9ef78c3417ab93c3bfff012}} 
const bt\+Persistent\+Manifold $\ast$ {\bfseries get\+Manifold} ()
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Enabling U\+S\+E\+\_\+\+S\+E\+P\+D\+I\+S\+T\+A\+N\+C\+E\+\_\+\+U\+T\+I\+L2 requires 100\% reliable distance computation. However, when using large size ratios G\+JK can be imprecise so the distance is not conservative. In that case, enabling this U\+S\+E\+\_\+\+S\+E\+P\+D\+I\+S\+T\+A\+N\+C\+E\+\_\+\+U\+T\+I\+L2 would result in failing/missing collisions. Either improve G\+JK for large size ratios (testing a 100 units versus a 0.\+1 unit object) or only enable the util for certain pairs that have a small size ratio The convex\+Convex\+Algorithm collision algorithm implements time of impact, convex closest points and penetration depth calculations between two convex objects. Multiple contact points are calculated by perturbing the orientation of the smallest object orthogonal to the separating normal. This idea was described by Gino van den Bergen in this forum topic \href{http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=4&t=288&p=888#p888}{\tt http\+://www.\+bulletphysics.\+com/\+Bullet/php\+B\+B3/viewtopic.\+php?f=4\&t=288\&p=888\#p888} 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classbtConvexConvexAlgorithm_a55f817b690c4e858d2b02607b382ce6b}\label{classbtConvexConvexAlgorithm_a55f817b690c4e858d2b02607b382ce6b}} 
\index{bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}!calculate\+Time\+Of\+Impact@{calculate\+Time\+Of\+Impact}}
\index{calculate\+Time\+Of\+Impact@{calculate\+Time\+Of\+Impact}!bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}}
\subsubsection{\texorpdfstring{calculate\+Time\+Of\+Impact()}{calculateTimeOfImpact()}}
{\footnotesize\ttfamily bt\+Scalar bt\+Convex\+Convex\+Algorithm\+::calculate\+Time\+Of\+Impact (\begin{DoxyParamCaption}\item[{bt\+Collision\+Object $\ast$}]{body0,  }\item[{bt\+Collision\+Object $\ast$}]{body1,  }\item[{const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&}]{dispatch\+Info,  }\item[{\hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$}]{result\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Rather then checking A\+LL pairs, only calculate T\+OI when motion exceeds threshold

Linear motion for one of objects needs to exceed m\+\_\+ccd\+Square\+Motion\+Threshold col0-\/$>$m\+\_\+world\+Transform,

Convex0 against sphere for Convex1

Simplification, one object is simplified as a sphere

Sphere (for convex0) against Convex1

Simplification, one object is simplified as a sphere 

Implements \hyperlink{classbtCollisionAlgorithm}{bt\+Collision\+Algorithm}.

\mbox{\Hypertarget{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}\label{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}} 
\index{bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}!get\+All\+Contact\+Manifolds@{get\+All\+Contact\+Manifolds}}
\index{get\+All\+Contact\+Manifolds@{get\+All\+Contact\+Manifolds}!bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}}
\subsubsection{\texorpdfstring{get\+All\+Contact\+Manifolds()}{getAllContactManifolds()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void bt\+Convex\+Convex\+Algorithm\+::get\+All\+Contact\+Manifolds (\begin{DoxyParamCaption}\item[{\hyperlink{classbtAlignedObjectArray}{bt\+Manifold\+Array} \&}]{manifold\+Array }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

should we use m\+\_\+own\+Manifold to avoid adding duplicates? 

Implements \hyperlink{classbtCollisionAlgorithm}{bt\+Collision\+Algorithm}.

\mbox{\Hypertarget{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}\label{classbtConvexConvexAlgorithm_aa2a195cdd3b45c169c15ea2de85c4038}} 
\index{bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}!get\+All\+Contact\+Manifolds@{get\+All\+Contact\+Manifolds}}
\index{get\+All\+Contact\+Manifolds@{get\+All\+Contact\+Manifolds}!bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}}
\subsubsection{\texorpdfstring{get\+All\+Contact\+Manifolds()}{getAllContactManifolds()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void bt\+Convex\+Convex\+Algorithm\+::get\+All\+Contact\+Manifolds (\begin{DoxyParamCaption}\item[{\hyperlink{classbtAlignedObjectArray}{bt\+Manifold\+Array} \&}]{manifold\+Array }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

should we use m\+\_\+own\+Manifold to avoid adding duplicates? 

Implements \hyperlink{classbtCollisionAlgorithm}{bt\+Collision\+Algorithm}.

\mbox{\Hypertarget{classbtConvexConvexAlgorithm_ab566631355a17f7a4bcbddf9454eb9e5}\label{classbtConvexConvexAlgorithm_ab566631355a17f7a4bcbddf9454eb9e5}} 
\index{bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}!process\+Collision@{process\+Collision}}
\index{process\+Collision@{process\+Collision}!bt\+Convex\+Convex\+Algorithm@{bt\+Convex\+Convex\+Algorithm}}
\subsubsection{\texorpdfstring{process\+Collision()}{processCollision()}}
{\footnotesize\ttfamily void bt\+Convex\+Convex\+Algorithm\+::process\+Collision (\begin{DoxyParamCaption}\item[{const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$}]{body0\+Wrap,  }\item[{const \hyperlink{structbtCollisionObjectWrapper}{bt\+Collision\+Object\+Wrapper} $\ast$}]{body1\+Wrap,  }\item[{const \hyperlink{structbtDispatcherInfo}{bt\+Dispatcher\+Info} \&}]{dispatch\+Info,  }\item[{\hyperlink{classbtManifoldResult}{bt\+Manifold\+Result} $\ast$}]{result\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

bt\+Box\+Shape is an exception\+: its vertices are created W\+I\+TH margin so don\textquotesingle{}t subtract it 

Implements \hyperlink{classbtCollisionAlgorithm}{bt\+Collision\+Algorithm}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/pmx/git/\+P\+M\+X/\+Simu\+Cocos/cocos2d/external/bullet/\+Bullet\+Collision/\+Collision\+Dispatch/bt\+Convex\+Convex\+Algorithm.\+h\item 
/home/pmx/git/\+P\+M\+X/\+Simu\+Cocos/cocos2d/external/bullet/\+Bullet\+Collision/\+Collision\+Dispatch/bt\+Convex\+Convex\+Algorithm.\+cpp\end{DoxyCompactItemize}
