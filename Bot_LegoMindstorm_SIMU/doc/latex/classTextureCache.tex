\hypertarget{classTextureCache}{}\section{Texture\+Cache Class Reference}
\label{classTextureCache}\index{Texture\+Cache@{Texture\+Cache}}


Singleton that handles the loading of textures. Once the texture is loaded, the next time it will return. A reference of the previously loaded texture reducing G\+PU \& C\+PU memory.  




{\ttfamily \#include $<$C\+C\+Texture\+Cache.\+h$>$}



Inheritance diagram for Texture\+Cache\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=158pt]{classTextureCache__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Texture\+Cache\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=158pt]{classTextureCache__coll__graph}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}{Texture\+Cache} ()
\item 
virtual \hyperlink{classTextureCache_aacfd218a0a417210f696f6da7c351643}{$\sim$\+Texture\+Cache} ()
\item 
virtual std\+::string \hyperlink{classTextureCache_a1e54c198c9f9a242c0fe8989b494f1a1}{get\+Description} () const
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_a3732061bd450e38a7649dfc4c39858ef}{add\+Image} (const std\+::string \&filepath)
\item 
virtual void \hyperlink{classTextureCache_a21e8506a3a65c61bef4f057ef10facba}{add\+Image\+Async} (const std\+::string \&filepath, const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&callback)
\item 
virtual void \hyperlink{classTextureCache_a3de7b70ab03d134d58fdac249c102d65}{unbind\+Image\+Async} (const std\+::string \&filename)
\item 
virtual void \hyperlink{classTextureCache_a92d6cd0e772ecb99b2c140dba4205717}{unbind\+All\+Image\+Async} ()
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_a286a3f1f96a59ebf2addb972e15e87a7}{add\+Image} (Image $\ast$image, const std\+::string \&key)
\item 
\mbox{\Hypertarget{classTextureCache_afbe2231b715b485a544ff9c872e6b540}\label{classTextureCache_afbe2231b715b485a544ff9c872e6b540}} 
C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTexture2D}{Texture2D} $\ast$ {\bfseries add\+U\+I\+Image} (Image $\ast$image, const std\+::string \&key)
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_a0fcfc44c403bb587c5883b0e587723d3}{get\+Texture\+For\+Key} (const std\+::string \&key) const
\item 
\mbox{\Hypertarget{classTextureCache_a42a1e21cee57d60f7c1268e36470e361}\label{classTextureCache_a42a1e21cee57d60f7c1268e36470e361}} 
C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTexture2D}{Texture2D} $\ast$ {\bfseries texture\+For\+Key} (const std\+::string \&key) const
\item 
bool \hyperlink{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}{reload\+Texture} (const std\+::string \&file\+Name)
\item 
void \hyperlink{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}{remove\+All\+Textures} ()
\item 
void \hyperlink{classTextureCache_acbec791c5421295c030e097716787f68}{remove\+Unused\+Textures} ()
\item 
void \hyperlink{classTextureCache_a346fc925fda0b7964bbb57f100275760}{remove\+Texture} (\hyperlink{classTexture2D}{Texture2D} $\ast$texture)
\item 
void \hyperlink{classTextureCache_ad532b26bf9a162d34710aa38f776c134}{remove\+Texture\+For\+Key} (const std\+::string \&key)
\item 
std\+::string \hyperlink{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}{get\+Cached\+Texture\+Info} () const
\item 
void \hyperlink{classTextureCache_ae51af522306e9449d772c3996509a509}{wait\+For\+Quit} ()
\item 
std\+::string \hyperlink{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}{get\+Texture\+File\+Path} (\hyperlink{classTexture2D}{Texture2D} $\ast$texture) const
\item 
void \hyperlink{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}{rename\+Texture\+With\+Key} (const std\+::string \&src\+Name, const std\+::string \&dst\+Name)
\item 
\hyperlink{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}{Texture\+Cache} ()
\item 
virtual \hyperlink{classTextureCache_a711da38733f62e7d36346e750fa92666}{$\sim$\+Texture\+Cache} ()
\item 
virtual std\+::string \hyperlink{classTextureCache_a1e4fd2c1e7bf821300b2bf23e6c70561}{get\+Description} () const
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_a95d8fe88c5a3c5ac20627861d5ac7033}{add\+Image} (const std\+::string \&filepath)
\item 
virtual void \hyperlink{classTextureCache_ac97620a31dc4c03c26d0206b6e834ff2}{add\+Image\+Async} (const std\+::string \&filepath, const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&callback)
\item 
void \hyperlink{classTextureCache_af36a764b691191f78fb76cc20aa8c80d}{add\+Image\+Async} (const std\+::string \&path, const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&callback, const std\+::string \&callback\+Key)
\item 
virtual void \hyperlink{classTextureCache_a02c48302097f8109e604b64018267046}{unbind\+Image\+Async} (const std\+::string \&filename)
\item 
virtual void \hyperlink{classTextureCache_a8cd53b2493af00f76d7e24a19dc2555d}{unbind\+All\+Image\+Async} ()
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_a6215487085c4f04c22bc03d6bce95fbe}{add\+Image} (Image $\ast$image, const std\+::string \&key)
\item 
\mbox{\Hypertarget{classTextureCache_afbe2231b715b485a544ff9c872e6b540}\label{classTextureCache_afbe2231b715b485a544ff9c872e6b540}} 
C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTexture2D}{Texture2D} $\ast$ {\bfseries add\+U\+I\+Image} (Image $\ast$image, const std\+::string \&key)
\item 
\hyperlink{classTexture2D}{Texture2D} $\ast$ \hyperlink{classTextureCache_adb72cb7ee095134531ea8bd03588db94}{get\+Texture\+For\+Key} (const std\+::string \&key) const
\item 
\mbox{\Hypertarget{classTextureCache_a42a1e21cee57d60f7c1268e36470e361}\label{classTextureCache_a42a1e21cee57d60f7c1268e36470e361}} 
C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTexture2D}{Texture2D} $\ast$ {\bfseries texture\+For\+Key} (const std\+::string \&key) const
\item 
bool \hyperlink{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}{reload\+Texture} (const std\+::string \&file\+Name)
\item 
void \hyperlink{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}{remove\+All\+Textures} ()
\item 
void \hyperlink{classTextureCache_acbec791c5421295c030e097716787f68}{remove\+Unused\+Textures} ()
\item 
void \hyperlink{classTextureCache_a346fc925fda0b7964bbb57f100275760}{remove\+Texture} (\hyperlink{classTexture2D}{Texture2D} $\ast$texture)
\item 
void \hyperlink{classTextureCache_ad532b26bf9a162d34710aa38f776c134}{remove\+Texture\+For\+Key} (const std\+::string \&key)
\item 
std\+::string \hyperlink{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}{get\+Cached\+Texture\+Info} () const
\item 
void \hyperlink{classTextureCache_ae51af522306e9449d772c3996509a509}{wait\+For\+Quit} ()
\item 
std\+::string \hyperlink{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}{get\+Texture\+File\+Path} (\hyperlink{classTexture2D}{Texture2D} $\ast$texture) const
\item 
void \hyperlink{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}{rename\+Texture\+With\+Key} (const std\+::string \&src\+Name, const std\+::string \&dst\+Name)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ \hyperlink{classTextureCache_aedd5e47ab3b453d894eab82ae18d80af}{get\+Instance} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ \hyperlink{classTextureCache_a77a4493baac10bdfc2c7c91361a9f622}{shared\+Texture\+Cache} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_a39aaf943d5c4969590a5f0c2f2008d68}{destroy\+Instance} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_a61daeb91b7d2cd8228fd4849384108c1}{purge\+Shared\+Texture\+Cache} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_ab02c8d452f1ac6f8213b5931fbc1e89f}{reload\+All\+Textures} ()
\item 
\mbox{\Hypertarget{classTextureCache_a41c596c1cac94d1ab61f698a835a329f}\label{classTextureCache_a41c596c1cac94d1ab61f698a835a329f}} 
static void {\bfseries set\+E\+T\+C1\+Alpha\+File\+Suffix} (const std\+::string \&suffix)
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ \hyperlink{classTextureCache_aa3b70b207c1fe514b6806695dbc43564}{get\+Instance} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ \hyperlink{classTextureCache_ae5d28e68b30d4d9491db6ab0766eb25c}{shared\+Texture\+Cache} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_aecf51262381fa7b3e85066bb1b0a3b06}{destroy\+Instance} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_ab45bcaee3f6fd43a4d1dc29ff9107b4e}{purge\+Shared\+Texture\+Cache} ()
\item 
static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void \hyperlink{classTextureCache_ac70068345cc5744cf0be99ad51615275}{reload\+All\+Textures} ()
\item 
\mbox{\Hypertarget{classTextureCache_a2524f0fced01a316a4867aefb3ea5cf8}\label{classTextureCache_a2524f0fced01a316a4867aefb3ea5cf8}} 
static void {\bfseries set\+E\+T\+C1\+Alpha\+File\+Suffix} (const std\+::string \&suffix)
\item 
\mbox{\Hypertarget{classTextureCache_a1ada8f4f153f490ccde00eb672b58610}\label{classTextureCache_a1ada8f4f153f490ccde00eb672b58610}} 
static std\+::string {\bfseries get\+E\+T\+C1\+Alpha\+File\+Suffix} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classTextureCache_aea1f31816298888a7eefdf42d7919432}\label{classTextureCache_aea1f31816298888a7eefdf42d7919432}} 
std\+::thread $\ast$ {\bfseries \+\_\+loading\+Thread}
\item 
\mbox{\Hypertarget{classTextureCache_a4752665f2610093e710de5296217e613}\label{classTextureCache_a4752665f2610093e710de5296217e613}} 
std\+::deque$<$ \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} $\ast$ $>$ {\bfseries \+\_\+async\+Struct\+Queue}
\item 
\mbox{\Hypertarget{classTextureCache_a14ef80c78dee3ef26138317d8395060c}\label{classTextureCache_a14ef80c78dee3ef26138317d8395060c}} 
std\+::deque$<$ \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} $\ast$ $>$ {\bfseries \+\_\+request\+Queue}
\item 
\mbox{\Hypertarget{classTextureCache_a7f5bc5e852856e5c2762ff17dba9c3cb}\label{classTextureCache_a7f5bc5e852856e5c2762ff17dba9c3cb}} 
std\+::deque$<$ \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} $\ast$ $>$ {\bfseries \+\_\+response\+Queue}
\item 
\mbox{\Hypertarget{classTextureCache_a11d20bdcc9a52e6be22fc54ceafbb812}\label{classTextureCache_a11d20bdcc9a52e6be22fc54ceafbb812}} 
std\+::mutex {\bfseries \+\_\+request\+Mutex}
\item 
\mbox{\Hypertarget{classTextureCache_a4d492edf8421f9ecf58e25d932e79116}\label{classTextureCache_a4d492edf8421f9ecf58e25d932e79116}} 
std\+::mutex {\bfseries \+\_\+response\+Mutex}
\item 
\mbox{\Hypertarget{classTextureCache_a538bd77f97be3ad8286d91f159da4fd9}\label{classTextureCache_a538bd77f97be3ad8286d91f159da4fd9}} 
std\+::condition\+\_\+variable {\bfseries \+\_\+sleep\+Condition}
\item 
\mbox{\Hypertarget{classTextureCache_ae77a610b43e55879fce685ad98f03a37}\label{classTextureCache_ae77a610b43e55879fce685ad98f03a37}} 
bool {\bfseries \+\_\+need\+Quit}
\item 
\mbox{\Hypertarget{classTextureCache_af55a60b971c03ac5d46713cd53e39e4a}\label{classTextureCache_af55a60b971c03ac5d46713cd53e39e4a}} 
int {\bfseries \+\_\+async\+Ref\+Count}
\item 
\mbox{\Hypertarget{classTextureCache_a3b65419f3cbcd4a18a1ebbc26dfc66de}\label{classTextureCache_a3b65419f3cbcd4a18a1ebbc26dfc66de}} 
std\+::unordered\+\_\+map$<$ std\+::string, \hyperlink{classTexture2D}{Texture2D} $\ast$ $>$ {\bfseries \+\_\+textures}
\end{DoxyCompactItemize}
\subsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classTextureCache_a4918a56d5253decf8f5f91491235b7b2}\label{classTextureCache_a4918a56d5253decf8f5f91491235b7b2}} 
static std\+::string {\bfseries s\+\_\+etc1\+Alpha\+File\+Suffix} = \char`\"{}@alpha\char`\"{}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Singleton that handles the loading of textures. Once the texture is loaded, the next time it will return. A reference of the previously loaded texture reducing G\+PU \& C\+PU memory. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}\label{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}} 
\index{Texture\+Cache@{Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\index{Texture\+Cache@{Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{Texture\+Cache()}{TextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Texture\+Cache\+::\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

ctor \mbox{\Hypertarget{classTextureCache_aacfd218a0a417210f696f6da7c351643}\label{classTextureCache_aacfd218a0a417210f696f6da7c351643}} 
\index{Texture\+Cache@{Texture\+Cache}!````~Texture\+Cache@{$\sim$\+Texture\+Cache}}
\index{````~Texture\+Cache@{$\sim$\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{$\sim$\+Texture\+Cache()}{~TextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Texture\+Cache\+::$\sim$\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

NA  NA \mbox{\Hypertarget{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}\label{classTextureCache_aaec6e0e3c0b4c5bfed1c31187cea44c4}} 
\index{Texture\+Cache@{Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\index{Texture\+Cache@{Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{Texture\+Cache()}{TextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Texture\+Cache\+::\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

ctor \mbox{\Hypertarget{classTextureCache_a711da38733f62e7d36346e750fa92666}\label{classTextureCache_a711da38733f62e7d36346e750fa92666}} 
\index{Texture\+Cache@{Texture\+Cache}!````~Texture\+Cache@{$\sim$\+Texture\+Cache}}
\index{````~Texture\+Cache@{$\sim$\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{$\sim$\+Texture\+Cache()}{~TextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual Texture\+Cache\+::$\sim$\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

NA  NA 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classTextureCache_a3732061bd450e38a7649dfc4c39858ef}\label{classTextureCache_a3732061bd450e38a7649dfc4c39858ef}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image@{add\+Image}}
\index{add\+Image@{add\+Image}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image()}{addImage()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D} $\ast$ Texture\+Cache\+::add\+Image (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filepath }\end{DoxyParamCaption})}

Returns a \hyperlink{classTexture2D}{Texture2D} object given an filename. If the filename was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D}. Object and it will return it. It will use the filename as a key. Otherwise it will return a reference of a previously loaded image. Supported image extensions\+: .png, .bmp, .tiff, .jpeg, .pvr. 
\begin{DoxyParams}{Parameters}
{\em filepath} & A null terminated string. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classTextureCache_a95d8fe88c5a3c5ac20627861d5ac7033}\label{classTextureCache_a95d8fe88c5a3c5ac20627861d5ac7033}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image@{add\+Image}}
\index{add\+Image@{add\+Image}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image()}{addImage()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D}$\ast$ Texture\+Cache\+::add\+Image (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filepath }\end{DoxyParamCaption})}

Returns a \hyperlink{classTexture2D}{Texture2D} object given an filename. If the filename was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D}. Object and it will return it. It will use the filename as a key. Otherwise it will return a reference of a previously loaded image. Supported image extensions\+: .png, .bmp, .tiff, .jpeg, .pvr. 
\begin{DoxyParams}{Parameters}
{\em filepath} & The file path. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classTextureCache_a286a3f1f96a59ebf2addb972e15e87a7}\label{classTextureCache_a286a3f1f96a59ebf2addb972e15e87a7}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image@{add\+Image}}
\index{add\+Image@{add\+Image}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image()}{addImage()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D} $\ast$ Texture\+Cache\+::add\+Image (\begin{DoxyParamCaption}\item[{Image $\ast$}]{image,  }\item[{const std\+::string \&}]{key }\end{DoxyParamCaption})}

Returns a \hyperlink{classTexture2D}{Texture2D} object given an Image. If the image was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D} object and it will return it. Otherwise it will return a reference of a previously loaded image. 
\begin{DoxyParams}{Parameters}
{\em key} & The \char`\"{}key\char`\"{} parameter will be used as the \char`\"{}key\char`\"{} for the cache. If \char`\"{}key\char`\"{} is nil, then a new texture will be created each time. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classTextureCache_a6215487085c4f04c22bc03d6bce95fbe}\label{classTextureCache_a6215487085c4f04c22bc03d6bce95fbe}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image@{add\+Image}}
\index{add\+Image@{add\+Image}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image()}{addImage()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D}$\ast$ Texture\+Cache\+::add\+Image (\begin{DoxyParamCaption}\item[{Image $\ast$}]{image,  }\item[{const std\+::string \&}]{key }\end{DoxyParamCaption})}

Returns a \hyperlink{classTexture2D}{Texture2D} object given an Image. If the image was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D} object and it will return it. Otherwise it will return a reference of a previously loaded image. 
\begin{DoxyParams}{Parameters}
{\em key} & The \char`\"{}key\char`\"{} parameter will be used as the \char`\"{}key\char`\"{} for the cache. If \char`\"{}key\char`\"{} is nil, then a new texture will be created each time. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classTextureCache_a21e8506a3a65c61bef4f057ef10facba}\label{classTextureCache_a21e8506a3a65c61bef4f057ef10facba}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image\+Async@{add\+Image\+Async}}
\index{add\+Image\+Async@{add\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image\+Async()}{addImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void Texture\+Cache\+::add\+Image\+Async (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path,  }\item[{const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&}]{callback }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Returns a \hyperlink{classTexture2D}{Texture2D} object given a file image. If the file image was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D} object and it will return it. Otherwise it will load a texture in a new thread, and when the image is loaded, the callback will be called with the \hyperlink{classTexture2D}{Texture2D} as a parameter. The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback. Supported image extensions\+: .png, .jpg 
\begin{DoxyParams}{Parameters}
{\em filepath} & A null terminated string. \\
\hline
{\em callback} & A callback function would be invoked after the image is loaded. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+8
\end{DoxySince}
The add\+Image\+Async logic follow the steps\+:
\begin{DoxyItemize}
\item find the image has been add or not, if not add an \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+request\+Queue (GL thread)
\item get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+request\+Queue, load res and fill image data to Async\+Struct.\+image, then add \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+response\+Queue (Load thread)
\item on schedule callback, get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+response\+Queue, convert image to texture, then delete \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} (GL thread)
\end{DoxyItemize}

the Critical Area include these members\+:
\begin{DoxyItemize}
\item \+\_\+request\+Queue\+: locked by \+\_\+request\+Mutex
\item \+\_\+response\+Queue\+: locked by \+\_\+response\+Mutex
\end{DoxyItemize}

the object\textquotesingle{}s life time\+:
\begin{DoxyItemize}
\item \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct}\+: construct and destruct in GL thread
\item image data\+: new in Load thread, delete in GL thread(by Image instance)
\end{DoxyItemize}

Note\+:
\begin{DoxyItemize}
\item all \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} referenced in \+\_\+async\+Struct\+Queue, for unbind function use.
\end{DoxyItemize}

How to deal add image many times?
\begin{DoxyItemize}
\item At first, this situation is abnormal, we only ensure the logic is correct.
\item If the image has been loaded, the after load image call will return immediately.
\item If the image request is in queue already, there will be more than one request in queue,
\item In add\+Image\+Async\+Callback, will deduplicate the request to ensure only create one texture.
\end{DoxyItemize}

Does process all response in add\+Image\+Async\+Callback consume more time?
\begin{DoxyItemize}
\item Convert image to texture faster than load image from disk, so this isn\textquotesingle{}t a problem.
\end{DoxyItemize}

The add\+Image\+Async logic follow the steps\+:
\begin{DoxyItemize}
\item find the image has been add or not, if not add an \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+request\+Queue (GL thread)
\item get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+request\+Queue, load res and fill image data to Async\+Struct.\+image, then add \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+response\+Queue (Load thread)
\item on schedule callback, get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+response\+Queue, convert image to texture, then delete \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} (GL thread)
\end{DoxyItemize}

the Critical Area include these members\+:
\begin{DoxyItemize}
\item \+\_\+request\+Queue\+: locked by \+\_\+request\+Mutex
\item \+\_\+response\+Queue\+: locked by \+\_\+response\+Mutex
\end{DoxyItemize}

the object\textquotesingle{}s life time\+:
\begin{DoxyItemize}
\item \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct}\+: construct and destruct in GL thread
\item image data\+: new in Load thread, delete in GL thread(by Image instance)
\end{DoxyItemize}

Note\+:
\begin{DoxyItemize}
\item all \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} referenced in \+\_\+async\+Struct\+Queue, for unbind function use.
\end{DoxyItemize}

How to deal add image many times?
\begin{DoxyItemize}
\item At first, this situation is abnormal, we only ensure the logic is correct.
\item If the image has been loaded, the after load image call will return immediately.
\item If the image request is in queue already, there will be more than one request in queue,
\item In add\+Image\+Async\+Callback, will deduplicate the request to ensure only create one texture.
\end{DoxyItemize}

Does process all response in add\+Image\+Async\+Callback consume more time?
\begin{DoxyItemize}
\item Convert image to texture faster than load image from disk, so this isn\textquotesingle{}t a problem.
\end{DoxyItemize}

Call unbind\+Image\+Async(path) to prevent the call to the callback when the texture is loaded. \mbox{\Hypertarget{classTextureCache_ac97620a31dc4c03c26d0206b6e834ff2}\label{classTextureCache_ac97620a31dc4c03c26d0206b6e834ff2}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image\+Async@{add\+Image\+Async}}
\index{add\+Image\+Async@{add\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image\+Async()}{addImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily virtual void Texture\+Cache\+::add\+Image\+Async (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filepath,  }\item[{const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&}]{callback }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Returns a \hyperlink{classTexture2D}{Texture2D} object given a file image. If the file image was not previously loaded, it will create a new \hyperlink{classTexture2D}{Texture2D} object and it will return it. Otherwise it will load a texture in a new thread, and when the image is loaded, the callback will be called with the \hyperlink{classTexture2D}{Texture2D} as a parameter. The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback. Supported image extensions\+: .png, .jpg 
\begin{DoxyParams}{Parameters}
{\em filepath} & The file path. \\
\hline
{\em callback} & A callback function would be invoked after the image is loaded. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+8 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_af36a764b691191f78fb76cc20aa8c80d}\label{classTextureCache_af36a764b691191f78fb76cc20aa8c80d}} 
\index{Texture\+Cache@{Texture\+Cache}!add\+Image\+Async@{add\+Image\+Async}}
\index{add\+Image\+Async@{add\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{add\+Image\+Async()}{addImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void Texture\+Cache\+::add\+Image\+Async (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path,  }\item[{const std\+::function$<$ void(\hyperlink{classTexture2D}{Texture2D} $\ast$)$>$ \&}]{callback,  }\item[{const std\+::string \&}]{callback\+Key }\end{DoxyParamCaption})}

The add\+Image\+Async logic follow the steps\+:
\begin{DoxyItemize}
\item find the image has been add or not, if not add an \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+request\+Queue (GL thread)
\item get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+request\+Queue, load res and fill image data to Async\+Struct.\+image, then add \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} to \+\_\+response\+Queue (Load thread)
\item on schedule callback, get \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} from \+\_\+response\+Queue, convert image to texture, then delete \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} (GL thread)
\end{DoxyItemize}

the Critical Area include these members\+:
\begin{DoxyItemize}
\item \+\_\+request\+Queue\+: locked by \+\_\+request\+Mutex
\item \+\_\+response\+Queue\+: locked by \+\_\+response\+Mutex
\end{DoxyItemize}

the object\textquotesingle{}s life time\+:
\begin{DoxyItemize}
\item \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct}\+: construct and destruct in GL thread
\item image data\+: new in Load thread, delete in GL thread(by Image instance)
\end{DoxyItemize}

Note\+:
\begin{DoxyItemize}
\item all \hyperlink{structTextureCache_1_1AsyncStruct}{Async\+Struct} referenced in \+\_\+async\+Struct\+Queue, for unbind function use.
\end{DoxyItemize}

How to deal add image many times?
\begin{DoxyItemize}
\item At first, this situation is abnormal, we only ensure the logic is correct.
\item If the image has been loaded, the after load image call will return immediately.
\item If the image request is in queue already, there will be more than one request in queue,
\item In add\+Image\+Async\+Callback, will deduplicate the request to ensure only create one texture.
\end{DoxyItemize}

Does process all response in add\+Image\+Async\+Callback consume more time?
\begin{DoxyItemize}
\item Convert image to texture faster than load image from disk, so this isn\textquotesingle{}t a problem.
\end{DoxyItemize}

The callback\+Key allows to unbind the callback in cases where the loading of path is requested by several sources simultaneously. Each source can then unbind the callback independently as needed whilst a call to unbind\+Image\+Async(path) would be ambiguous. \mbox{\Hypertarget{classTextureCache_a39aaf943d5c4969590a5f0c2f2008d68}\label{classTextureCache_a39aaf943d5c4969590a5f0c2f2008d68}} 
\index{Texture\+Cache@{Texture\+Cache}!destroy\+Instance@{destroy\+Instance}}
\index{destroy\+Instance@{destroy\+Instance}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{destroy\+Instance()}{destroyInstance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::destroy\+Instance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Purges the cache. It releases the retained instance. \begin{DoxySince}{Since}
v0.\+99.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_aecf51262381fa7b3e85066bb1b0a3b06}\label{classTextureCache_aecf51262381fa7b3e85066bb1b0a3b06}} 
\index{Texture\+Cache@{Texture\+Cache}!destroy\+Instance@{destroy\+Instance}}
\index{destroy\+Instance@{destroy\+Instance}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{destroy\+Instance()}{destroyInstance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void Texture\+Cache\+::destroy\+Instance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Purges the cache. It releases the retained instance. \begin{DoxySince}{Since}
v0.\+99.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}\label{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Cached\+Texture\+Info@{get\+Cached\+Texture\+Info}}
\index{get\+Cached\+Texture\+Info@{get\+Cached\+Texture\+Info}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Cached\+Texture\+Info()}{getCachedTextureInfo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Texture\+Cache\+::get\+Cached\+Texture\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Output to C\+C\+L\+OG the current contents of this \hyperlink{classTextureCache}{Texture\+Cache}. This will attempt to calculate the size of each texture, and the total texture memory in use.

\begin{DoxySince}{Since}
v1.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}\label{classTextureCache_ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Cached\+Texture\+Info@{get\+Cached\+Texture\+Info}}
\index{get\+Cached\+Texture\+Info@{get\+Cached\+Texture\+Info}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Cached\+Texture\+Info()}{getCachedTextureInfo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string Texture\+Cache\+::get\+Cached\+Texture\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Output to C\+C\+L\+OG the current contents of this \hyperlink{classTextureCache}{Texture\+Cache}. This will attempt to calculate the size of each texture, and the total texture memory in use.

\begin{DoxySince}{Since}
v1.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a1e54c198c9f9a242c0fe8989b494f1a1}\label{classTextureCache_a1e54c198c9f9a242c0fe8989b494f1a1}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Description@{get\+Description}}
\index{get\+Description@{get\+Description}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Description()}{getDescription()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Texture\+Cache\+::get\+Description (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

NA  NA \mbox{\Hypertarget{classTextureCache_a1e4fd2c1e7bf821300b2bf23e6c70561}\label{classTextureCache_a1e4fd2c1e7bf821300b2bf23e6c70561}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Description@{get\+Description}}
\index{get\+Description@{get\+Description}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Description()}{getDescription()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual std\+::string Texture\+Cache\+::get\+Description (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

NA  NA \mbox{\Hypertarget{classTextureCache_aedd5e47ab3b453d894eab82ae18d80af}\label{classTextureCache_aedd5e47ab3b453d894eab82ae18d80af}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Instance@{get\+Instance}}
\index{get\+Instance@{get\+Instance}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Instance()}{getInstance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ Texture\+Cache\+::get\+Instance (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the shared instance of the cache. \mbox{\Hypertarget{classTextureCache_aa3b70b207c1fe514b6806695dbc43564}\label{classTextureCache_aa3b70b207c1fe514b6806695dbc43564}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Instance@{get\+Instance}}
\index{get\+Instance@{get\+Instance}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Instance()}{getInstance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache}$\ast$ Texture\+Cache\+::get\+Instance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the shared instance of the cache. \mbox{\Hypertarget{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}\label{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Texture\+File\+Path@{get\+Texture\+File\+Path}}
\index{get\+Texture\+File\+Path@{get\+Texture\+File\+Path}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Texture\+File\+Path()}{getTextureFilePath()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Texture\+Cache\+::get\+Texture\+File\+Path (\begin{DoxyParamCaption}\item[{\hyperlink{classTexture2D}{Texture2D} $\ast$}]{texture }\end{DoxyParamCaption}) const}

Get the file path of the texture


\begin{DoxyParams}{Parameters}
{\em texture} & A \hyperlink{classTexture2D}{Texture2D} object pointer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The full path of the file. 
\end{DoxyReturn}
\mbox{\Hypertarget{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}\label{classTextureCache_a4dd4a314af856fd66bb10b53a61fd0ea}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Texture\+File\+Path@{get\+Texture\+File\+Path}}
\index{get\+Texture\+File\+Path@{get\+Texture\+File\+Path}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Texture\+File\+Path()}{getTextureFilePath()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string Texture\+Cache\+::get\+Texture\+File\+Path (\begin{DoxyParamCaption}\item[{\hyperlink{classTexture2D}{Texture2D} $\ast$}]{texture }\end{DoxyParamCaption}) const}

Get the file path of the texture


\begin{DoxyParams}{Parameters}
{\em texture} & A \hyperlink{classTexture2D}{Texture2D} object pointer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The full path of the file. 
\end{DoxyReturn}
\mbox{\Hypertarget{classTextureCache_a0fcfc44c403bb587c5883b0e587723d3}\label{classTextureCache_a0fcfc44c403bb587c5883b0e587723d3}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Texture\+For\+Key@{get\+Texture\+For\+Key}}
\index{get\+Texture\+For\+Key@{get\+Texture\+For\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Texture\+For\+Key()}{getTextureForKey()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D} $\ast$ Texture\+Cache\+::get\+Texture\+For\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{key }\end{DoxyParamCaption}) const}

Returns an already created texture. Returns nil if the texture doesn\textquotesingle{}t exist. 
\begin{DoxyParams}{Parameters}
{\em key} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+99.\+5 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_adb72cb7ee095134531ea8bd03588db94}\label{classTextureCache_adb72cb7ee095134531ea8bd03588db94}} 
\index{Texture\+Cache@{Texture\+Cache}!get\+Texture\+For\+Key@{get\+Texture\+For\+Key}}
\index{get\+Texture\+For\+Key@{get\+Texture\+For\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{get\+Texture\+For\+Key()}{getTextureForKey()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \hyperlink{classTexture2D}{Texture2D}$\ast$ Texture\+Cache\+::get\+Texture\+For\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{key }\end{DoxyParamCaption}) const}

Returns an already created texture. Returns nil if the texture doesn\textquotesingle{}t exist. 
\begin{DoxyParams}{Parameters}
{\em key} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+99.\+5 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a61daeb91b7d2cd8228fd4849384108c1}\label{classTextureCache_a61daeb91b7d2cd8228fd4849384108c1}} 
\index{Texture\+Cache@{Texture\+Cache}!purge\+Shared\+Texture\+Cache@{purge\+Shared\+Texture\+Cache}}
\index{purge\+Shared\+Texture\+Cache@{purge\+Shared\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{purge\+Shared\+Texture\+Cache()}{purgeSharedTextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::purge\+Shared\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000136}{Deprecated}]Use \hyperlink{classTextureCache_a39aaf943d5c4969590a5f0c2f2008d68}{destroy\+Instance()} instead. \end{DoxyRefDesc}
\mbox{\Hypertarget{classTextureCache_ab45bcaee3f6fd43a4d1dc29ff9107b4e}\label{classTextureCache_ab45bcaee3f6fd43a4d1dc29ff9107b4e}} 
\index{Texture\+Cache@{Texture\+Cache}!purge\+Shared\+Texture\+Cache@{purge\+Shared\+Texture\+Cache}}
\index{purge\+Shared\+Texture\+Cache@{purge\+Shared\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{purge\+Shared\+Texture\+Cache()}{purgeSharedTextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void Texture\+Cache\+::purge\+Shared\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000369}{Deprecated}]Use \hyperlink{classTextureCache_a39aaf943d5c4969590a5f0c2f2008d68}{destroy\+Instance()} instead. \end{DoxyRefDesc}
\mbox{\Hypertarget{classTextureCache_ab02c8d452f1ac6f8213b5931fbc1e89f}\label{classTextureCache_ab02c8d452f1ac6f8213b5931fbc1e89f}} 
\index{Texture\+Cache@{Texture\+Cache}!reload\+All\+Textures@{reload\+All\+Textures}}
\index{reload\+All\+Textures@{reload\+All\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{reload\+All\+Textures()}{reloadAllTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::reload\+All\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reload all textures. Should not call it, called by frame work. Now the function do nothing, use Volatile\+Texture\+Mgr\+::reload\+All\+Textures. \mbox{\Hypertarget{classTextureCache_ac70068345cc5744cf0be99ad51615275}\label{classTextureCache_ac70068345cc5744cf0be99ad51615275}} 
\index{Texture\+Cache@{Texture\+Cache}!reload\+All\+Textures@{reload\+All\+Textures}}
\index{reload\+All\+Textures@{reload\+All\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{reload\+All\+Textures()}{reloadAllTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE void Texture\+Cache\+::reload\+All\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reload all textures. Should not call it, called by frame work. Now the function do nothing, use Volatile\+Texture\+Mgr\+::reload\+All\+Textures. \mbox{\Hypertarget{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}\label{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}} 
\index{Texture\+Cache@{Texture\+Cache}!reload\+Texture@{reload\+Texture}}
\index{reload\+Texture@{reload\+Texture}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{reload\+Texture()}{reloadTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Texture\+Cache\+::reload\+Texture (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Name }\end{DoxyParamCaption})}

Reload texture from the image file. If the file image hasn\textquotesingle{}t loaded before, load it. Otherwise the texture will be reloaded from the file image. 
\begin{DoxyParams}{Parameters}
{\em file\+Name} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the reloading is succeed, otherwise return false. 
\end{DoxyReturn}
\mbox{\Hypertarget{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}\label{classTextureCache_a6063d9bceafa8a6f60c498f8e2c15b4a}} 
\index{Texture\+Cache@{Texture\+Cache}!reload\+Texture@{reload\+Texture}}
\index{reload\+Texture@{reload\+Texture}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{reload\+Texture()}{reloadTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Texture\+Cache\+::reload\+Texture (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Name }\end{DoxyParamCaption})}

Reload texture from the image file. If the file image hasn\textquotesingle{}t loaded before, load it. Otherwise the texture will be reloaded from the file image. 
\begin{DoxyParams}{Parameters}
{\em file\+Name} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the reloading is succeed, otherwise return false. 
\end{DoxyReturn}
\mbox{\Hypertarget{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}\label{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+All\+Textures@{remove\+All\+Textures}}
\index{remove\+All\+Textures@{remove\+All\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+All\+Textures()}{removeAllTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+All\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Purges the dictionary of loaded textures. Call this method if you receive the \char`\"{}\+Memory Warning\char`\"{}. In the short term\+: it will free some resources preventing your app from being killed. In the medium term\+: it will allocate more resources. In the long term\+: it will be the same. \mbox{\Hypertarget{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}\label{classTextureCache_a860e0ed7bd403b85e91cec4b03057d61}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+All\+Textures@{remove\+All\+Textures}}
\index{remove\+All\+Textures@{remove\+All\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+All\+Textures()}{removeAllTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+All\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Purges the dictionary of loaded textures. Call this method if you receive the \char`\"{}\+Memory Warning\char`\"{}. In the short term\+: it will free some resources preventing your app from being killed. In the medium term\+: it will allocate more resources. In the long term\+: it will be the same. \mbox{\Hypertarget{classTextureCache_a346fc925fda0b7964bbb57f100275760}\label{classTextureCache_a346fc925fda0b7964bbb57f100275760}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Texture@{remove\+Texture}}
\index{remove\+Texture@{remove\+Texture}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Texture()}{removeTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Texture (\begin{DoxyParamCaption}\item[{\hyperlink{classTexture2D}{Texture2D} $\ast$}]{texture }\end{DoxyParamCaption})}

Deletes a texture from the cache given a texture. \mbox{\Hypertarget{classTextureCache_a346fc925fda0b7964bbb57f100275760}\label{classTextureCache_a346fc925fda0b7964bbb57f100275760}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Texture@{remove\+Texture}}
\index{remove\+Texture@{remove\+Texture}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Texture()}{removeTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Texture (\begin{DoxyParamCaption}\item[{\hyperlink{classTexture2D}{Texture2D} $\ast$}]{texture }\end{DoxyParamCaption})}

Deletes a texture from the cache given a texture. \mbox{\Hypertarget{classTextureCache_ad532b26bf9a162d34710aa38f776c134}\label{classTextureCache_ad532b26bf9a162d34710aa38f776c134}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Texture\+For\+Key@{remove\+Texture\+For\+Key}}
\index{remove\+Texture\+For\+Key@{remove\+Texture\+For\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Texture\+For\+Key()}{removeTextureForKey()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Texture\+For\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{key }\end{DoxyParamCaption})}

Deletes a texture from the cache given a its key name. 
\begin{DoxyParams}{Parameters}
{\em key} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+99.\+4 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_ad532b26bf9a162d34710aa38f776c134}\label{classTextureCache_ad532b26bf9a162d34710aa38f776c134}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Texture\+For\+Key@{remove\+Texture\+For\+Key}}
\index{remove\+Texture\+For\+Key@{remove\+Texture\+For\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Texture\+For\+Key()}{removeTextureForKey()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Texture\+For\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{key }\end{DoxyParamCaption})}

Deletes a texture from the cache given a its key name. 
\begin{DoxyParams}{Parameters}
{\em key} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v0.\+99.\+4 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_acbec791c5421295c030e097716787f68}\label{classTextureCache_acbec791c5421295c030e097716787f68}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Unused\+Textures@{remove\+Unused\+Textures}}
\index{remove\+Unused\+Textures@{remove\+Unused\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Unused\+Textures()}{removeUnusedTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Unused\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Removes unused textures. Textures that have a retain count of 1 will be deleted. It is convenient to call this method after when starting a new \hyperlink{classScene}{Scene}. \begin{DoxySince}{Since}
v0.\+8 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_acbec791c5421295c030e097716787f68}\label{classTextureCache_acbec791c5421295c030e097716787f68}} 
\index{Texture\+Cache@{Texture\+Cache}!remove\+Unused\+Textures@{remove\+Unused\+Textures}}
\index{remove\+Unused\+Textures@{remove\+Unused\+Textures}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{remove\+Unused\+Textures()}{removeUnusedTextures()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::remove\+Unused\+Textures (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Removes unused textures. Textures that have a retain count of 1 will be deleted. It is convenient to call this method after when starting a new \hyperlink{classScene}{Scene}. \begin{DoxySince}{Since}
v0.\+8 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}\label{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}} 
\index{Texture\+Cache@{Texture\+Cache}!rename\+Texture\+With\+Key@{rename\+Texture\+With\+Key}}
\index{rename\+Texture\+With\+Key@{rename\+Texture\+With\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{rename\+Texture\+With\+Key()}{renameTextureWithKey()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::rename\+Texture\+With\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{src\+Name,  }\item[{const std\+::string \&}]{dst\+Name }\end{DoxyParamCaption})}

Reload texture from a new file. This function is mainly for editor, won\textquotesingle{}t suggest use it in game for performance reason.


\begin{DoxyParams}{Parameters}
{\em src\+Name} & Original texture file name. \\
\hline
{\em dst\+Name} & New texture file name.\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v3.\+10 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}\label{classTextureCache_a8735ea61a274834e6b3db7165ce2c26d}} 
\index{Texture\+Cache@{Texture\+Cache}!rename\+Texture\+With\+Key@{rename\+Texture\+With\+Key}}
\index{rename\+Texture\+With\+Key@{rename\+Texture\+With\+Key}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{rename\+Texture\+With\+Key()}{renameTextureWithKey()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::rename\+Texture\+With\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{src\+Name,  }\item[{const std\+::string \&}]{dst\+Name }\end{DoxyParamCaption})}

Reload texture from a new file. This function is mainly for editor, won\textquotesingle{}t suggest use it in game for performance reason.


\begin{DoxyParams}{Parameters}
{\em src\+Name} & Original texture file name. \\
\hline
{\em dst\+Name} & New texture file name.\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v3.\+10 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a77a4493baac10bdfc2c7c91361a9f622}\label{classTextureCache_a77a4493baac10bdfc2c7c91361a9f622}} 
\index{Texture\+Cache@{Texture\+Cache}!shared\+Texture\+Cache@{shared\+Texture\+Cache}}
\index{shared\+Texture\+Cache@{shared\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{shared\+Texture\+Cache()}{sharedTextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classTextureCache}{Texture\+Cache} $\ast$ Texture\+Cache\+::shared\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000135}{Deprecated}]Use \hyperlink{classTextureCache_aedd5e47ab3b453d894eab82ae18d80af}{get\+Instance()} instead. \end{DoxyRefDesc}
\mbox{\Hypertarget{classTextureCache_ae5d28e68b30d4d9491db6ab0766eb25c}\label{classTextureCache_ae5d28e68b30d4d9491db6ab0766eb25c}} 
\index{Texture\+Cache@{Texture\+Cache}!shared\+Texture\+Cache@{shared\+Texture\+Cache}}
\index{shared\+Texture\+Cache@{shared\+Texture\+Cache}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{shared\+Texture\+Cache()}{sharedTextureCache()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static C\+C\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE \hyperlink{classTextureCache}{Texture\+Cache}$\ast$ Texture\+Cache\+::shared\+Texture\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000368}{Deprecated}]Use \hyperlink{classTextureCache_aedd5e47ab3b453d894eab82ae18d80af}{get\+Instance()} instead. \end{DoxyRefDesc}
\mbox{\Hypertarget{classTextureCache_a92d6cd0e772ecb99b2c140dba4205717}\label{classTextureCache_a92d6cd0e772ecb99b2c140dba4205717}} 
\index{Texture\+Cache@{Texture\+Cache}!unbind\+All\+Image\+Async@{unbind\+All\+Image\+Async}}
\index{unbind\+All\+Image\+Async@{unbind\+All\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{unbind\+All\+Image\+Async()}{unbindAllImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::unbind\+All\+Image\+Async (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Unbind all bound image asynchronous load callbacks. \begin{DoxySince}{Since}
v3.\+1 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a8cd53b2493af00f76d7e24a19dc2555d}\label{classTextureCache_a8cd53b2493af00f76d7e24a19dc2555d}} 
\index{Texture\+Cache@{Texture\+Cache}!unbind\+All\+Image\+Async@{unbind\+All\+Image\+Async}}
\index{unbind\+All\+Image\+Async@{unbind\+All\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{unbind\+All\+Image\+Async()}{unbindAllImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void Texture\+Cache\+::unbind\+All\+Image\+Async (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Unbind all bound image asynchronous load callbacks. \begin{DoxySince}{Since}
v3.\+1 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a3de7b70ab03d134d58fdac249c102d65}\label{classTextureCache_a3de7b70ab03d134d58fdac249c102d65}} 
\index{Texture\+Cache@{Texture\+Cache}!unbind\+Image\+Async@{unbind\+Image\+Async}}
\index{unbind\+Image\+Async@{unbind\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{unbind\+Image\+Async()}{unbindImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::unbind\+Image\+Async (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Unbind a specified bound image asynchronous callback. In the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked, the object always need to unbind this callback manually. 
\begin{DoxyParams}{Parameters}
{\em filename} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v3.\+1 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_a02c48302097f8109e604b64018267046}\label{classTextureCache_a02c48302097f8109e604b64018267046}} 
\index{Texture\+Cache@{Texture\+Cache}!unbind\+Image\+Async@{unbind\+Image\+Async}}
\index{unbind\+Image\+Async@{unbind\+Image\+Async}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{unbind\+Image\+Async()}{unbindImageAsync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void Texture\+Cache\+::unbind\+Image\+Async (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Unbind a specified bound image asynchronous callback. In the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked, the object always need to unbind this callback manually. 
\begin{DoxyParams}{Parameters}
{\em filename} & It\textquotesingle{}s the related/absolute path of the file image. \\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
v3.\+1 
\end{DoxySince}
\mbox{\Hypertarget{classTextureCache_ae51af522306e9449d772c3996509a509}\label{classTextureCache_ae51af522306e9449d772c3996509a509}} 
\index{Texture\+Cache@{Texture\+Cache}!wait\+For\+Quit@{wait\+For\+Quit}}
\index{wait\+For\+Quit@{wait\+For\+Quit}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{wait\+For\+Quit()}{waitForQuit()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::wait\+For\+Quit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Called by director, please do not called outside. \mbox{\Hypertarget{classTextureCache_ae51af522306e9449d772c3996509a509}\label{classTextureCache_ae51af522306e9449d772c3996509a509}} 
\index{Texture\+Cache@{Texture\+Cache}!wait\+For\+Quit@{wait\+For\+Quit}}
\index{wait\+For\+Quit@{wait\+For\+Quit}!Texture\+Cache@{Texture\+Cache}}
\subsubsection{\texorpdfstring{wait\+For\+Quit()}{waitForQuit()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Texture\+Cache\+::wait\+For\+Quit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Called by director, please do not called outside. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/pmx/git/\+P\+M\+X/\+Simu\+Cocos/cocos2d/cocos/renderer/C\+C\+Texture\+Cache.\+h\item 
/home/pmx/git/\+P\+M\+X/\+Simu\+Cocos/cocos2d/cocos/renderer/C\+C\+Texture\+Cache.\+cpp\end{DoxyCompactItemize}
