<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: LWS Ringbuffer APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LWS Ringbuffer APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c9d92d25a17879f77e13eb481c5a82d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws_ring *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga3c9d92d25a17879f77e13eb481c5a82d">lws_ring_create</a> (size_t element_len, size_t count, void(*destroy_element)(void *element))</td></tr>
<tr class="separator:ga3c9d92d25a17879f77e13eb481c5a82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e671dbbb18af91d23e78026d49bc6e2"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga0e671dbbb18af91d23e78026d49bc6e2">lws_ring_destroy</a> (struct lws_ring *ring)</td></tr>
<tr class="separator:ga0e671dbbb18af91d23e78026d49bc6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711d92a1046c2a34860a2babd68aec32"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga711d92a1046c2a34860a2babd68aec32">lws_ring_get_count_free_elements</a> (struct lws_ring *ring)</td></tr>
<tr class="separator:ga711d92a1046c2a34860a2babd68aec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3cb460d9af061b5b60dc35d4e2ea95"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga5e3cb460d9af061b5b60dc35d4e2ea95">lws_ring_get_count_waiting_elements</a> (struct lws_ring *ring, uint32_t *tail)</td></tr>
<tr class="separator:ga5e3cb460d9af061b5b60dc35d4e2ea95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00fcaf9c2e3b16e9a667120ae214cc30"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga00fcaf9c2e3b16e9a667120ae214cc30">lws_ring_insert</a> (struct lws_ring *ring, const void *src, size_t max_count)</td></tr>
<tr class="separator:ga00fcaf9c2e3b16e9a667120ae214cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad6706af708096eba401a48f67bf865"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga1ad6706af708096eba401a48f67bf865">lws_ring_consume</a> (struct lws_ring *ring, uint32_t *tail, void *dest, size_t max_count)</td></tr>
<tr class="separator:ga1ad6706af708096eba401a48f67bf865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc75cf61aed9737f54bef9b79b54e58"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga4bc75cf61aed9737f54bef9b79b54e58">lws_ring_get_element</a> (struct lws_ring *ring, uint32_t *tail)</td></tr>
<tr class="separator:ga4bc75cf61aed9737f54bef9b79b54e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ec0634b0a901c4cc9cad33fcd7273b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#gac4ec0634b0a901c4cc9cad33fcd7273b">lws_ring_update_oldest_tail</a> (struct lws_ring *ring, uint32_t tail)</td></tr>
<tr class="separator:gac4ec0634b0a901c4cc9cad33fcd7273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410b651d0668809dcf6e3621edce2794"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga410b651d0668809dcf6e3621edce2794">lws_ring_get_oldest_tail</a> (struct lws_ring *ring)</td></tr>
<tr class="separator:ga410b651d0668809dcf6e3621edce2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b61910109bce5a64a9cd411377ae7b1"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#ga7b61910109bce5a64a9cd411377ae7b1">lws_ring_next_linear_insert_range</a> (struct lws_ring *ring, void **start, size_t *bytes)</td></tr>
<tr class="separator:ga7b61910109bce5a64a9cd411377ae7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef516991b6b0268a639f76a01def2f87"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lws__ring.html#gaef516991b6b0268a639f76a01def2f87">lws_ring_bump_head</a> (struct lws_ring *ring, size_t bytes)</td></tr>
<tr class="separator:gaef516991b6b0268a639f76a01def2f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>lws_ring: generic ringbuffer struct</h2>
<p>Provides an abstract ringbuffer api supporting one head and one or an unlimited number of tails.</p>
<p>All of the members are opaque and manipulated by lws_ring_...() apis.</p>
<p>The lws_ring and its buffer is allocated at runtime on the heap, using</p>
<ul>
<li><a class="el" href="group__lws__ring.html#ga3c9d92d25a17879f77e13eb481c5a82d">lws_ring_create()</a></li>
<li><a class="el" href="group__lws__ring.html#ga0e671dbbb18af91d23e78026d49bc6e2">lws_ring_destroy()</a></li>
</ul>
<p>It may contain any type, the size of the "element" stored in the ring buffer and the number of elements is given at creation time.</p>
<p>When you create the ringbuffer, you can optionally provide an element destroy callback that frees any allocations inside the element. This is then automatically called for elements with no tail behind them, ie, elements which don't have any pending consumer are auto-freed.</p>
<p>Whole elements may be inserted into the ringbuffer and removed from it, using</p>
<ul>
<li><a class="el" href="group__lws__ring.html#ga00fcaf9c2e3b16e9a667120ae214cc30">lws_ring_insert()</a></li>
<li><a class="el" href="group__lws__ring.html#ga1ad6706af708096eba401a48f67bf865">lws_ring_consume()</a></li>
</ul>
<p>You can find out how many whole elements are free or waiting using</p>
<ul>
<li><a class="el" href="group__lws__ring.html#ga711d92a1046c2a34860a2babd68aec32">lws_ring_get_count_free_elements()</a></li>
<li><a class="el" href="group__lws__ring.html#ga5e3cb460d9af061b5b60dc35d4e2ea95">lws_ring_get_count_waiting_elements()</a></li>
</ul>
<p>In addition there are special purpose optional byte-centric apis</p>
<ul>
<li><a class="el" href="group__lws__ring.html#ga7b61910109bce5a64a9cd411377ae7b1">lws_ring_next_linear_insert_range()</a></li>
<li><a class="el" href="group__lws__ring.html#gaef516991b6b0268a639f76a01def2f87">lws_ring_bump_head()</a></li>
</ul>
<p>which let you, eg, read() directly into the ringbuffer without needing an intermediate bounce buffer.</p>
<p>The accessors understand that the ring wraps, and optimizes insertion and consumption into one or two memcpy()s depending on if the head or tail wraps.</p>
<p>lws_ring only supports a single head, but optionally multiple tails with an API to inform it when the "oldest" tail has moved on. You can give NULL where-ever an api asks for a tail pointer, and it will use an internal single tail pointer for convenience.</p>
<p>The "oldest tail", which is the only tail if you give it NULL instead of some other tail, is used to track which elements in the ringbuffer are still unread by anyone.</p>
<ul>
<li><a class="el" href="group__lws__ring.html#gac4ec0634b0a901c4cc9cad33fcd7273b">lws_ring_update_oldest_tail()</a> </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaef516991b6b0268a639f76a01def2f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef516991b6b0268a639f76a01def2f87">&#9670;&nbsp;</a></span>lws_ring_bump_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_ring_bump_head </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#gaef516991b6b0268a639f76a01def2f87">lws_ring_bump_head()</a>: used to write directly into the ring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to operate on </td></tr>
    <tr><td class="paramname">bytes</td><td>the number of bytes you inserted at the current head </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ad6706af708096eba401a48f67bf865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad6706af708096eba401a48f67bf865">&#9670;&nbsp;</a></span>lws_ring_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_ring_consume </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga1ad6706af708096eba401a48f67bf865">lws_ring_consume()</a>: attempt to copy out and remove up to max_count elements to src</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">tail</td><td>a pointer to the tail struct to use, or NULL for single tail </td></tr>
    <tr><td class="paramname">dest</td><td>the array of elements to be inserted. or NULL for no copy </td></tr>
    <tr><td class="paramname">max_count</td><td>the number of available elements at src</td></tr>
  </table>
  </dd>
</dl>
<p>Attempts to copy out as many waiting elements as possible into dest, from the perspective of the given tail, up to max_count. If dest is NULL, the copying out is not done but the elements are logically consumed as usual. NULL dest is useful in combination with <a class="el" href="group__lws__ring.html#ga4bc75cf61aed9737f54bef9b79b54e58">lws_ring_get_element()</a>, where you can use the element direct from the ringbuffer and then call this with NULL dest to logically consume it.</p>
<p>Increments the tail position according to how many elements could be consumed.</p>
<p>Returns the number of elements consumed. </p>

</div>
</div>
<a id="ga3c9d92d25a17879f77e13eb481c5a82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9d92d25a17879f77e13eb481c5a82d">&#9670;&nbsp;</a></span>lws_ring_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws_ring * lws_ring_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *element)&#160;</td>
          <td class="paramname"><em>destroy_element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga3c9d92d25a17879f77e13eb481c5a82d">lws_ring_create()</a>: create a new ringbuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_len</td><td>the size in bytes of one element in the ringbuffer </td></tr>
    <tr><td class="paramname">count</td><td>the number of elements the ringbuffer can contain </td></tr>
    <tr><td class="paramname">destroy_element</td><td>NULL, or callback to be called for each element that is removed from the ringbuffer due to the oldest tail moving beyond it</td></tr>
  </table>
  </dd>
</dl>
<p>Creates the ringbuffer and allocates the storage. Returns the new lws_ring *, or NULL if the allocation failed.</p>
<p>If non-NULL, destroy_element will get called back for every element that is retired from the ringbuffer after the oldest tail has gone past it, and for any element still left in the ringbuffer when it is destroyed. It replaces all other element destruction code in your user code. </p>

</div>
</div>
<a id="ga0e671dbbb18af91d23e78026d49bc6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e671dbbb18af91d23e78026d49bc6e2">&#9670;&nbsp;</a></span>lws_ring_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_ring_destroy </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga0e671dbbb18af91d23e78026d49bc6e2">lws_ring_destroy()</a>: destroy a previously created ringbuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Destroys the ringbuffer allocation and the struct lws_ring itself. </p>

</div>
</div>
<a id="ga711d92a1046c2a34860a2babd68aec32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga711d92a1046c2a34860a2babd68aec32">&#9670;&nbsp;</a></span>lws_ring_get_count_free_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_ring_get_count_free_elements </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga711d92a1046c2a34860a2babd68aec32">lws_ring_get_count_free_elements()</a>: return how many elements can fit in the free space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on</td></tr>
  </table>
  </dd>
</dl>
<p>Returns how much room is left in the ringbuffer for whole element insertion. </p>

</div>
</div>
<a id="ga5e3cb460d9af061b5b60dc35d4e2ea95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e3cb460d9af061b5b60dc35d4e2ea95">&#9670;&nbsp;</a></span>lws_ring_get_count_waiting_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_ring_get_count_waiting_elements </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga5e3cb460d9af061b5b60dc35d4e2ea95">lws_ring_get_count_waiting_elements()</a>: return how many elements can be consumed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">tail</td><td>a pointer to the tail struct to use, or NULL for single tail</td></tr>
  </table>
  </dd>
</dl>
<p>Returns how many elements are waiting to be consumed from the perspective of the tail pointer given. </p>

</div>
</div>
<a id="ga4bc75cf61aed9737f54bef9b79b54e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc75cf61aed9737f54bef9b79b54e58">&#9670;&nbsp;</a></span>lws_ring_get_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const void * lws_ring_get_element </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga4bc75cf61aed9737f54bef9b79b54e58">lws_ring_get_element()</a>: get a pointer to the next waiting element for tail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">tail</td><td>a pointer to the tail struct to use, or NULL for single tail</td></tr>
  </table>
  </dd>
</dl>
<p>Points to the next element that tail would consume, directly in the ringbuffer. This lets you write() or otherwise use the element without having to copy it out somewhere first.</p>
<p>After calling this, you must call lws_ring_consume(ring, &amp;tail, NULL, 1) which will logically consume the element you used up and increment your tail (tail may also be NULL there if you use a single tail).</p>
<p>Returns NULL if no waiting element, or a const void * pointing to it. </p>

</div>
</div>
<a id="ga410b651d0668809dcf6e3621edce2794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410b651d0668809dcf6e3621edce2794">&#9670;&nbsp;</a></span>lws_ring_get_oldest_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN uint32_t lws_ring_get_oldest_tail </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga410b651d0668809dcf6e3621edce2794">lws_ring_get_oldest_tail()</a>: get current oldest available data index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on</td></tr>
  </table>
  </dd>
</dl>
<p>If you are initializing a new ringbuffer consumer, you can set its tail to this to start it from the oldest ringbuffer entry still available. </p>

</div>
</div>
<a id="ga00fcaf9c2e3b16e9a667120ae214cc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00fcaf9c2e3b16e9a667120ae214cc30">&#9670;&nbsp;</a></span>lws_ring_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_ring_insert </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga00fcaf9c2e3b16e9a667120ae214cc30">lws_ring_insert()</a>: attempt to insert up to max_count elements from src</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">src</td><td>the array of elements to be inserted </td></tr>
    <tr><td class="paramname">max_count</td><td>the number of available elements at src</td></tr>
  </table>
  </dd>
</dl>
<p>Attempts to insert as many of the elements at src as possible, up to the maximum max_count. Returns the number of elements actually inserted. </p>

</div>
</div>
<a id="ga7b61910109bce5a64a9cd411377ae7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b61910109bce5a64a9cd411377ae7b1">&#9670;&nbsp;</a></span>lws_ring_next_linear_insert_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_ring_next_linear_insert_range </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#ga7b61910109bce5a64a9cd411377ae7b1">lws_ring_next_linear_insert_range()</a>: used to write directly into the ring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">start</td><td>pointer to a void * set to the start of the next ringbuffer area </td></tr>
    <tr><td class="paramname">bytes</td><td>pointer to a size_t set to the max length you may use from *start</td></tr>
  </table>
  </dd>
</dl>
<p>This provides a low-level, bytewise access directly into the ringbuffer allowing direct insertion of data without having to use a bounce buffer.</p>
<p>The api reports the position and length of the next linear range that can be written in the ringbuffer, ie, up to the point it would wrap, and sets *start and *bytes accordingly. You can then, eg, directly read() into *start for up to *bytes, and use <a class="el" href="group__lws__ring.html#gaef516991b6b0268a639f76a01def2f87">lws_ring_bump_head()</a> to update the lws_ring with what you have done.</p>
<p>Returns nonzero if no insertion is currently possible. </p>

</div>
</div>
<a id="gac4ec0634b0a901c4cc9cad33fcd7273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ec0634b0a901c4cc9cad33fcd7273b">&#9670;&nbsp;</a></span>lws_ring_update_oldest_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_ring_update_oldest_tail </td>
          <td>(</td>
          <td class="paramtype">struct lws_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lws__ring.html#gac4ec0634b0a901c4cc9cad33fcd7273b">lws_ring_update_oldest_tail()</a>: free up elements older than tail for reuse</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the struct lws_ring to report on </td></tr>
    <tr><td class="paramname">tail</td><td>a pointer to the tail struct to use, or NULL for single tail</td></tr>
  </table>
  </dd>
</dl>
<p>If you are using multiple tails, you must use this API to inform the lws_ring when none of the tails still need elements in the fifo any more, by updating it when the "oldest" tail has moved on. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
