<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: Misc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Misc</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6d034fec4d7962b6f20f9e243527c560"><td class="memItemLeft" align="right" valign="top"><a id="ga6d034fec4d7962b6f20f9e243527c560"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga6d034fec4d7962b6f20f9e243527c560">CP_BUFFER_BYTES</a>&#160;&#160;&#160;(32*1024)</td></tr>
<tr class="memdesc:ga6d034fec4d7962b6f20f9e243527c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated size for various Chipmunk buffers. <br /></td></tr>
<tr class="separator:ga6d034fec4d7962b6f20f9e243527c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88bab87ecc7db6cc222679bf6082e9b"><td class="memItemLeft" align="right" valign="top"><a id="gac88bab87ecc7db6cc222679bf6082e9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gac88bab87ecc7db6cc222679bf6082e9b">cpcalloc</a>&#160;&#160;&#160;calloc</td></tr>
<tr class="memdesc:gac88bab87ecc7db6cc222679bf6082e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk calloc() alias. <br /></td></tr>
<tr class="separator:gac88bab87ecc7db6cc222679bf6082e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3544b888840ed34e49bb0559d6849a8"><td class="memItemLeft" align="right" valign="top"><a id="gab3544b888840ed34e49bb0559d6849a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab3544b888840ed34e49bb0559d6849a8">cprealloc</a>&#160;&#160;&#160;realloc</td></tr>
<tr class="memdesc:gab3544b888840ed34e49bb0559d6849a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk realloc() alias. <br /></td></tr>
<tr class="separator:gab3544b888840ed34e49bb0559d6849a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14627263deb67605201281bac734eb04"><td class="memItemLeft" align="right" valign="top"><a id="ga14627263deb67605201281bac734eb04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga14627263deb67605201281bac734eb04">cpfree</a>&#160;&#160;&#160;free</td></tr>
<tr class="memdesc:ga14627263deb67605201281bac734eb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk free() alias. <br /></td></tr>
<tr class="separator:ga14627263deb67605201281bac734eb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02132b57a51a1c26ff6fb11dc046c04"><td class="memItemLeft" align="right" valign="top"><a id="gac02132b57a51a1c26ff6fb11dc046c04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_MAJOR</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:gac02132b57a51a1c26ff6fb11dc046c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015d989acd6a013e84ea8696953172a8"><td class="memItemLeft" align="right" valign="top"><a id="ga015d989acd6a013e84ea8696953172a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_MINOR</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga015d989acd6a013e84ea8696953172a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0311c28764c81d74c3c76570bb92c57f"><td class="memItemLeft" align="right" valign="top"><a id="ga0311c28764c81d74c3c76570bb92c57f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_RELEASE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga0311c28764c81d74c3c76570bb92c57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9abe29a1fe6d1f2041e95f2fb2e2ce1c">CP_CONVEX_HULL</a>(__count__,  __verts__,  __count_var__,  __verts_var__)</td></tr>
<tr class="separator:ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d034fec4d7962b6f20f9e243527c560"><td class="memItemLeft" align="right" valign="top"><a id="ga6d034fec4d7962b6f20f9e243527c560"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga6d034fec4d7962b6f20f9e243527c560">CP_BUFFER_BYTES</a>&#160;&#160;&#160;(32*1024)</td></tr>
<tr class="memdesc:ga6d034fec4d7962b6f20f9e243527c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated size for various Chipmunk buffers. <br /></td></tr>
<tr class="separator:ga6d034fec4d7962b6f20f9e243527c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88bab87ecc7db6cc222679bf6082e9b"><td class="memItemLeft" align="right" valign="top"><a id="gac88bab87ecc7db6cc222679bf6082e9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gac88bab87ecc7db6cc222679bf6082e9b">cpcalloc</a>&#160;&#160;&#160;calloc</td></tr>
<tr class="memdesc:gac88bab87ecc7db6cc222679bf6082e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk calloc() alias. <br /></td></tr>
<tr class="separator:gac88bab87ecc7db6cc222679bf6082e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3544b888840ed34e49bb0559d6849a8"><td class="memItemLeft" align="right" valign="top"><a id="gab3544b888840ed34e49bb0559d6849a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab3544b888840ed34e49bb0559d6849a8">cprealloc</a>&#160;&#160;&#160;realloc</td></tr>
<tr class="memdesc:gab3544b888840ed34e49bb0559d6849a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk realloc() alias. <br /></td></tr>
<tr class="separator:gab3544b888840ed34e49bb0559d6849a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14627263deb67605201281bac734eb04"><td class="memItemLeft" align="right" valign="top"><a id="ga14627263deb67605201281bac734eb04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga14627263deb67605201281bac734eb04">cpfree</a>&#160;&#160;&#160;free</td></tr>
<tr class="memdesc:ga14627263deb67605201281bac734eb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chipmunk free() alias. <br /></td></tr>
<tr class="separator:ga14627263deb67605201281bac734eb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02132b57a51a1c26ff6fb11dc046c04"><td class="memItemLeft" align="right" valign="top"><a id="gac02132b57a51a1c26ff6fb11dc046c04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_MAJOR</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:gac02132b57a51a1c26ff6fb11dc046c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015d989acd6a013e84ea8696953172a8"><td class="memItemLeft" align="right" valign="top"><a id="ga015d989acd6a013e84ea8696953172a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_MINOR</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga015d989acd6a013e84ea8696953172a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0311c28764c81d74c3c76570bb92c57f"><td class="memItemLeft" align="right" valign="top"><a id="ga0311c28764c81d74c3c76570bb92c57f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_VERSION_RELEASE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga0311c28764c81d74c3c76570bb92c57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9abe29a1fe6d1f2041e95f2fb2e2ce1c">CP_CONVEX_HULL</a>(__count__,  __verts__,  __count_var__,  __verts_var__)</td></tr>
<tr class="separator:ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f138b98c73782807d88e76c1c532dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll</a>(type,  it,  start)</td></tr>
<tr class="separator:ga9f138b98c73782807d88e76c1c532dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll</a>(it,  nxt)</td></tr>
<tr class="separator:ga9d94995ca7a1be16bf3d7bd2e449c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp</a>(type,  it,  start)</td></tr>
<tr class="separator:gad973ecfe2ac066ba0ea1ec3695d3e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba92c53b57f3e689f8568b02184a8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp</a>(it,  nxt)</td></tr>
<tr class="separator:gaba92c53b57f3e689f8568b02184a8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6b357f2c1d3fedc78e2c7aaa5186d566"><td class="memItemLeft" align="right" valign="top"><a id="ga6b357f2c1d3fedc78e2c7aaa5186d566"></a>
typedef struct <a class="el" href="structcpArray.html">cpArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpArray</b></td></tr>
<tr class="separator:ga6b357f2c1d3fedc78e2c7aaa5186d566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c80056192ac0574141a88de933b16b3"><td class="memItemLeft" align="right" valign="top"><a id="ga0c80056192ac0574141a88de933b16b3"></a>
typedef struct cpHashSet&#160;</td><td class="memItemRight" valign="bottom"><b>cpHashSet</b></td></tr>
<tr class="separator:ga0c80056192ac0574141a88de933b16b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89830b081a94b2500cc1ca31c43ac006"><td class="memItemLeft" align="right" valign="top"><a id="ga89830b081a94b2500cc1ca31c43ac006"></a>
typedef struct <a class="el" href="structcpBody.html">cpBody</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpBody</b></td></tr>
<tr class="separator:ga89830b081a94b2500cc1ca31c43ac006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16375f8bc5b219cde7560b23443b3a95"><td class="memItemLeft" align="right" valign="top"><a id="ga16375f8bc5b219cde7560b23443b3a95"></a>
typedef struct <a class="el" href="structcpShape.html">cpShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpShape</b></td></tr>
<tr class="separator:ga16375f8bc5b219cde7560b23443b3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0a8c50b9b7b6cdf205f1e446d77b23"><td class="memItemLeft" align="right" valign="top"><a id="gadc0a8c50b9b7b6cdf205f1e446d77b23"></a>
typedef struct <a class="el" href="structcpCircleShape.html">cpCircleShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpCircleShape</b></td></tr>
<tr class="separator:gadc0a8c50b9b7b6cdf205f1e446d77b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75717b3e5384ae67f7b5a7dd9d54c50f"><td class="memItemLeft" align="right" valign="top"><a id="ga75717b3e5384ae67f7b5a7dd9d54c50f"></a>
typedef struct <a class="el" href="structcpSegmentShape.html">cpSegmentShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSegmentShape</b></td></tr>
<tr class="separator:ga75717b3e5384ae67f7b5a7dd9d54c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0977850752deeb7bd3bae3e6e67b088"><td class="memItemLeft" align="right" valign="top"><a id="gac0977850752deeb7bd3bae3e6e67b088"></a>
typedef struct <a class="el" href="structcpPolyShape.html">cpPolyShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPolyShape</b></td></tr>
<tr class="separator:gac0977850752deeb7bd3bae3e6e67b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb40b2f09deac0d0e05605be0701be3"><td class="memItemLeft" align="right" valign="top"><a id="gabdb40b2f09deac0d0e05605be0701be3"></a>
typedef struct <a class="el" href="structcpConstraint.html">cpConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpConstraint</b></td></tr>
<tr class="separator:gabdb40b2f09deac0d0e05605be0701be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842072215937b61bb52852bec19367ad"><td class="memItemLeft" align="right" valign="top"><a id="ga842072215937b61bb52852bec19367ad"></a>
typedef struct <a class="el" href="structcpPinJoint.html">cpPinJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPinJoint</b></td></tr>
<tr class="separator:ga842072215937b61bb52852bec19367ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c80982fc779df42ada48f0f35c326c"><td class="memItemLeft" align="right" valign="top"><a id="ga22c80982fc779df42ada48f0f35c326c"></a>
typedef struct <a class="el" href="structcpSlideJoint.html">cpSlideJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSlideJoint</b></td></tr>
<tr class="separator:ga22c80982fc779df42ada48f0f35c326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be42317226c36d7c3b71175c31bed55"><td class="memItemLeft" align="right" valign="top"><a id="ga6be42317226c36d7c3b71175c31bed55"></a>
typedef struct <a class="el" href="structcpPivotJoint.html">cpPivotJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPivotJoint</b></td></tr>
<tr class="separator:ga6be42317226c36d7c3b71175c31bed55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa4733fb7b33f6650ce92a7d2bf9361"><td class="memItemLeft" align="right" valign="top"><a id="ga4aa4733fb7b33f6650ce92a7d2bf9361"></a>
typedef struct <a class="el" href="structcpGrooveJoint.html">cpGrooveJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpGrooveJoint</b></td></tr>
<tr class="separator:ga4aa4733fb7b33f6650ce92a7d2bf9361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c3629bf0daa6e27aaff6ac1bdc0fb7"><td class="memItemLeft" align="right" valign="top"><a id="gab4c3629bf0daa6e27aaff6ac1bdc0fb7"></a>
typedef struct <a class="el" href="structcpDampedSpring.html">cpDampedSpring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpDampedSpring</b></td></tr>
<tr class="separator:gab4c3629bf0daa6e27aaff6ac1bdc0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48602f8d634857dac76e75f05458aea1"><td class="memItemLeft" align="right" valign="top"><a id="ga48602f8d634857dac76e75f05458aea1"></a>
typedef struct <a class="el" href="structcpDampedRotarySpring.html">cpDampedRotarySpring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpDampedRotarySpring</b></td></tr>
<tr class="separator:ga48602f8d634857dac76e75f05458aea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54615af04b79ce2b9f2dfedc8e702da3"><td class="memItemLeft" align="right" valign="top"><a id="ga54615af04b79ce2b9f2dfedc8e702da3"></a>
typedef struct <a class="el" href="structcpRotaryLimitJoint.html">cpRotaryLimitJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpRotaryLimitJoint</b></td></tr>
<tr class="separator:ga54615af04b79ce2b9f2dfedc8e702da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574d87330384b10b88666948ea424a50"><td class="memItemLeft" align="right" valign="top"><a id="ga574d87330384b10b88666948ea424a50"></a>
typedef struct <a class="el" href="structcpRatchetJoint.html">cpRatchetJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpRatchetJoint</b></td></tr>
<tr class="separator:ga574d87330384b10b88666948ea424a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac590a81b11f1ee5ae26108e24a5b6074"><td class="memItemLeft" align="right" valign="top"><a id="gac590a81b11f1ee5ae26108e24a5b6074"></a>
typedef struct <a class="el" href="structcpGearJoint.html">cpGearJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpGearJoint</b></td></tr>
<tr class="separator:gac590a81b11f1ee5ae26108e24a5b6074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946a6726ce9067b29e944ff0f9309120"><td class="memItemLeft" align="right" valign="top"><a id="ga946a6726ce9067b29e944ff0f9309120"></a>
typedef struct cpSimpleMotorJoint&#160;</td><td class="memItemRight" valign="bottom"><b>cpSimpleMotorJoint</b></td></tr>
<tr class="separator:ga946a6726ce9067b29e944ff0f9309120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27db8fe21c73da2f139b0f28ded9818"><td class="memItemLeft" align="right" valign="top"><a id="gad27db8fe21c73da2f139b0f28ded9818"></a>
typedef struct <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpCollisionHandler</b></td></tr>
<tr class="separator:gad27db8fe21c73da2f139b0f28ded9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878866fdedeef4e18219aef96b040cfa"><td class="memItemLeft" align="right" valign="top"><a id="ga878866fdedeef4e18219aef96b040cfa"></a>
typedef struct <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpContactPointSet</b></td></tr>
<tr class="separator:ga878866fdedeef4e18219aef96b040cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771a9d6a062a6097f0e6bb1b2682e93f"><td class="memItemLeft" align="right" valign="top"><a id="ga771a9d6a062a6097f0e6bb1b2682e93f"></a>
typedef struct <a class="el" href="structcpArbiter.html">cpArbiter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpArbiter</b></td></tr>
<tr class="separator:ga771a9d6a062a6097f0e6bb1b2682e93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8838f85d2e2ba627fc4c9208fb1a4682"><td class="memItemLeft" align="right" valign="top"><a id="ga8838f85d2e2ba627fc4c9208fb1a4682"></a>
typedef struct <a class="el" href="structcpSpace.html">cpSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpace</b></td></tr>
<tr class="separator:ga8838f85d2e2ba627fc4c9208fb1a4682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b357f2c1d3fedc78e2c7aaa5186d566"><td class="memItemLeft" align="right" valign="top"><a id="ga6b357f2c1d3fedc78e2c7aaa5186d566"></a>
typedef struct <a class="el" href="structcpArray.html">cpArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpArray</b></td></tr>
<tr class="separator:ga6b357f2c1d3fedc78e2c7aaa5186d566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c80056192ac0574141a88de933b16b3"><td class="memItemLeft" align="right" valign="top"><a id="ga0c80056192ac0574141a88de933b16b3"></a>
typedef struct cpHashSet&#160;</td><td class="memItemRight" valign="bottom"><b>cpHashSet</b></td></tr>
<tr class="separator:ga0c80056192ac0574141a88de933b16b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89830b081a94b2500cc1ca31c43ac006"><td class="memItemLeft" align="right" valign="top"><a id="ga89830b081a94b2500cc1ca31c43ac006"></a>
typedef struct <a class="el" href="structcpBody.html">cpBody</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpBody</b></td></tr>
<tr class="separator:ga89830b081a94b2500cc1ca31c43ac006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16375f8bc5b219cde7560b23443b3a95"><td class="memItemLeft" align="right" valign="top"><a id="ga16375f8bc5b219cde7560b23443b3a95"></a>
typedef struct <a class="el" href="structcpShape.html">cpShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpShape</b></td></tr>
<tr class="separator:ga16375f8bc5b219cde7560b23443b3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0a8c50b9b7b6cdf205f1e446d77b23"><td class="memItemLeft" align="right" valign="top"><a id="gadc0a8c50b9b7b6cdf205f1e446d77b23"></a>
typedef struct <a class="el" href="structcpCircleShape.html">cpCircleShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpCircleShape</b></td></tr>
<tr class="separator:gadc0a8c50b9b7b6cdf205f1e446d77b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75717b3e5384ae67f7b5a7dd9d54c50f"><td class="memItemLeft" align="right" valign="top"><a id="ga75717b3e5384ae67f7b5a7dd9d54c50f"></a>
typedef struct <a class="el" href="structcpSegmentShape.html">cpSegmentShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSegmentShape</b></td></tr>
<tr class="separator:ga75717b3e5384ae67f7b5a7dd9d54c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0977850752deeb7bd3bae3e6e67b088"><td class="memItemLeft" align="right" valign="top"><a id="gac0977850752deeb7bd3bae3e6e67b088"></a>
typedef struct <a class="el" href="structcpPolyShape.html">cpPolyShape</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPolyShape</b></td></tr>
<tr class="separator:gac0977850752deeb7bd3bae3e6e67b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb40b2f09deac0d0e05605be0701be3"><td class="memItemLeft" align="right" valign="top"><a id="gabdb40b2f09deac0d0e05605be0701be3"></a>
typedef struct <a class="el" href="structcpConstraint.html">cpConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpConstraint</b></td></tr>
<tr class="separator:gabdb40b2f09deac0d0e05605be0701be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842072215937b61bb52852bec19367ad"><td class="memItemLeft" align="right" valign="top"><a id="ga842072215937b61bb52852bec19367ad"></a>
typedef struct <a class="el" href="structcpPinJoint.html">cpPinJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPinJoint</b></td></tr>
<tr class="separator:ga842072215937b61bb52852bec19367ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c80982fc779df42ada48f0f35c326c"><td class="memItemLeft" align="right" valign="top"><a id="ga22c80982fc779df42ada48f0f35c326c"></a>
typedef struct <a class="el" href="structcpSlideJoint.html">cpSlideJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSlideJoint</b></td></tr>
<tr class="separator:ga22c80982fc779df42ada48f0f35c326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be42317226c36d7c3b71175c31bed55"><td class="memItemLeft" align="right" valign="top"><a id="ga6be42317226c36d7c3b71175c31bed55"></a>
typedef struct <a class="el" href="structcpPivotJoint.html">cpPivotJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpPivotJoint</b></td></tr>
<tr class="separator:ga6be42317226c36d7c3b71175c31bed55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa4733fb7b33f6650ce92a7d2bf9361"><td class="memItemLeft" align="right" valign="top"><a id="ga4aa4733fb7b33f6650ce92a7d2bf9361"></a>
typedef struct <a class="el" href="structcpGrooveJoint.html">cpGrooveJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpGrooveJoint</b></td></tr>
<tr class="separator:ga4aa4733fb7b33f6650ce92a7d2bf9361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c3629bf0daa6e27aaff6ac1bdc0fb7"><td class="memItemLeft" align="right" valign="top"><a id="gab4c3629bf0daa6e27aaff6ac1bdc0fb7"></a>
typedef struct <a class="el" href="structcpDampedSpring.html">cpDampedSpring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpDampedSpring</b></td></tr>
<tr class="separator:gab4c3629bf0daa6e27aaff6ac1bdc0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48602f8d634857dac76e75f05458aea1"><td class="memItemLeft" align="right" valign="top"><a id="ga48602f8d634857dac76e75f05458aea1"></a>
typedef struct <a class="el" href="structcpDampedRotarySpring.html">cpDampedRotarySpring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpDampedRotarySpring</b></td></tr>
<tr class="separator:ga48602f8d634857dac76e75f05458aea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54615af04b79ce2b9f2dfedc8e702da3"><td class="memItemLeft" align="right" valign="top"><a id="ga54615af04b79ce2b9f2dfedc8e702da3"></a>
typedef struct <a class="el" href="structcpRotaryLimitJoint.html">cpRotaryLimitJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpRotaryLimitJoint</b></td></tr>
<tr class="separator:ga54615af04b79ce2b9f2dfedc8e702da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574d87330384b10b88666948ea424a50"><td class="memItemLeft" align="right" valign="top"><a id="ga574d87330384b10b88666948ea424a50"></a>
typedef struct <a class="el" href="structcpRatchetJoint.html">cpRatchetJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpRatchetJoint</b></td></tr>
<tr class="separator:ga574d87330384b10b88666948ea424a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac590a81b11f1ee5ae26108e24a5b6074"><td class="memItemLeft" align="right" valign="top"><a id="gac590a81b11f1ee5ae26108e24a5b6074"></a>
typedef struct <a class="el" href="structcpGearJoint.html">cpGearJoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpGearJoint</b></td></tr>
<tr class="separator:gac590a81b11f1ee5ae26108e24a5b6074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946a6726ce9067b29e944ff0f9309120"><td class="memItemLeft" align="right" valign="top"><a id="ga946a6726ce9067b29e944ff0f9309120"></a>
typedef struct cpSimpleMotorJoint&#160;</td><td class="memItemRight" valign="bottom"><b>cpSimpleMotorJoint</b></td></tr>
<tr class="separator:ga946a6726ce9067b29e944ff0f9309120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27db8fe21c73da2f139b0f28ded9818"><td class="memItemLeft" align="right" valign="top"><a id="gad27db8fe21c73da2f139b0f28ded9818"></a>
typedef struct <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpCollisionHandler</b></td></tr>
<tr class="separator:gad27db8fe21c73da2f139b0f28ded9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878866fdedeef4e18219aef96b040cfa"><td class="memItemLeft" align="right" valign="top"><a id="ga878866fdedeef4e18219aef96b040cfa"></a>
typedef struct <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpContactPointSet</b></td></tr>
<tr class="separator:ga878866fdedeef4e18219aef96b040cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771a9d6a062a6097f0e6bb1b2682e93f"><td class="memItemLeft" align="right" valign="top"><a id="ga771a9d6a062a6097f0e6bb1b2682e93f"></a>
typedef struct <a class="el" href="structcpArbiter.html">cpArbiter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpArbiter</b></td></tr>
<tr class="separator:ga771a9d6a062a6097f0e6bb1b2682e93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8838f85d2e2ba627fc4c9208fb1a4682"><td class="memItemLeft" align="right" valign="top"><a id="ga8838f85d2e2ba627fc4c9208fb1a4682"></a>
typedef struct <a class="el" href="structcpSpace.html">cpSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpace</b></td></tr>
<tr class="separator:ga8838f85d2e2ba627fc4c9208fb1a4682"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafa2103fb2fd788fded1131e53f00681a"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gafa2103fb2fd788fded1131e53f00681a">cpMomentForCircle</a> (cpFloat m, cpFloat r1, cpFloat r2, <a class="el" href="structcpVect.html">cpVect</a> offset)</td></tr>
<tr class="separator:gafa2103fb2fd788fded1131e53f00681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a50f3dfa695db703759e550db16bce"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga55a50f3dfa695db703759e550db16bce">cpAreaForCircle</a> (cpFloat r1, cpFloat r2)</td></tr>
<tr class="separator:ga55a50f3dfa695db703759e550db16bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9548fe7830d426bde625d39d4687e6be"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga9548fe7830d426bde625d39d4687e6be">cpMomentForSegment</a> (cpFloat m, <a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, cpFloat radius)</td></tr>
<tr class="separator:ga9548fe7830d426bde625d39d4687e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5758bdfd93aec5d3f3780a1ff29aad37"><td class="memItemLeft" align="right" valign="top"><a id="ga5758bdfd93aec5d3f3780a1ff29aad37"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga5758bdfd93aec5d3f3780a1ff29aad37">cpAreaForSegment</a> (<a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, cpFloat radius)</td></tr>
<tr class="memdesc:ga5758bdfd93aec5d3f3780a1ff29aad37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the area of a fattened (capsule shaped) line segment. <br /></td></tr>
<tr class="separator:ga5758bdfd93aec5d3f3780a1ff29aad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69a0e62a94f55c347eb66160963ff6e"><td class="memItemLeft" align="right" valign="top"><a id="gaa69a0e62a94f55c347eb66160963ff6e"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaa69a0e62a94f55c347eb66160963ff6e">cpMomentForPoly</a> (cpFloat m, int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts, <a class="el" href="structcpVect.html">cpVect</a> offset, cpFloat radius)</td></tr>
<tr class="memdesc:gaa69a0e62a94f55c347eb66160963ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the moment of inertia for a solid polygon shape assuming it's center of gravity is at it's centroid. The offset is added to each vertex. <br /></td></tr>
<tr class="separator:gaa69a0e62a94f55c347eb66160963ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc17e58f105411e2d66c09f8047d822"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga2bc17e58f105411e2d66c09f8047d822">cpAreaForPoly</a> (const int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts, cpFloat radius)</td></tr>
<tr class="separator:ga2bc17e58f105411e2d66c09f8047d822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd18beae9cbd2b6847747cc1d933bfd"><td class="memItemLeft" align="right" valign="top"><a id="gaedd18beae9cbd2b6847747cc1d933bfd"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaedd18beae9cbd2b6847747cc1d933bfd">cpCentroidForPoly</a> (const int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts)</td></tr>
<tr class="memdesc:gaedd18beae9cbd2b6847747cc1d933bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the natural centroid of a polygon. <br /></td></tr>
<tr class="separator:gaedd18beae9cbd2b6847747cc1d933bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840facfe3f57151e1a8634b6047a45ef"><td class="memItemLeft" align="right" valign="top"><a id="ga840facfe3f57151e1a8634b6047a45ef"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga840facfe3f57151e1a8634b6047a45ef">cpMomentForBox</a> (cpFloat m, cpFloat width, cpFloat height)</td></tr>
<tr class="memdesc:ga840facfe3f57151e1a8634b6047a45ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the moment of inertia for a solid box. <br /></td></tr>
<tr class="separator:ga840facfe3f57151e1a8634b6047a45ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a01a4b99c3976c1a9b4df14efe04552"><td class="memItemLeft" align="right" valign="top"><a id="ga4a01a4b99c3976c1a9b4df14efe04552"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga4a01a4b99c3976c1a9b4df14efe04552">cpMomentForBox2</a> (cpFloat m, <a class="el" href="structcpBB.html">cpBB</a> box)</td></tr>
<tr class="memdesc:ga4a01a4b99c3976c1a9b4df14efe04552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the moment of inertia for a solid box. <br /></td></tr>
<tr class="separator:ga4a01a4b99c3976c1a9b4df14efe04552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ed1fc4d2c987c3e4df3cb16b12a156"><td class="memItemLeft" align="right" valign="top">CP_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull</a> (int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts, <a class="el" href="structcpVect.html">cpVect</a> *result, int *first, cpFloat tol)</td></tr>
<tr class="separator:ga94ed1fc4d2c987c3e4df3cb16b12a156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2163492f17db959a36967adb73d823b4"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga2163492f17db959a36967adb73d823b4">lws_snprintf</a> (char *str, size_t size, const char *format,...) LWS_FORMAT(3)</td></tr>
<tr class="separator:ga2163492f17db959a36967adb73d823b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f906c6be0ca80efd813f694569dd4a"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga58f906c6be0ca80efd813f694569dd4a">lws_get_random</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, void *buf, int len)</td></tr>
<tr class="separator:ga58f906c6be0ca80efd813f694569dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace5171b1dbbc03ec89a98f8afdb5c9af"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gace5171b1dbbc03ec89a98f8afdb5c9af">lws_daemonize</a> (const char *_lock_path)</td></tr>
<tr class="separator:gace5171b1dbbc03ec89a98f8afdb5c9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6abfc0b2bd5b2f09281a4432bb2f5f0"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gac6abfc0b2bd5b2f09281a4432bb2f5f0">lws_get_library_version</a> (void)</td></tr>
<tr class="separator:gac6abfc0b2bd5b2f09281a4432bb2f5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa194584fff9698f3b280658f770ccd0f"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaa194584fff9698f3b280658f770ccd0f">lws_wsi_user</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gaa194584fff9698f3b280658f770ccd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d23abbe3fe1d53592b29c597a8245ba"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga8d23abbe3fe1d53592b29c597a8245ba">lws_set_wsi_user</a> (struct <a class="el" href="structlws.html">lws</a> *wsi, void *user)</td></tr>
<tr class="separator:ga8d23abbe3fe1d53592b29c597a8245ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec0d9faac5d3a5824d765c287c043aa"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga1ec0d9faac5d3a5824d765c287c043aa">lws_parse_uri</a> (char *p, const char **prot, const char **ads, int *port, const char **path)</td></tr>
<tr class="separator:ga1ec0d9faac5d3a5824d765c287c043aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bf2635033710b25f931b57ed663e1e"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga33bf2635033710b25f931b57ed663e1e">lws_now_secs</a> (void)</td></tr>
<tr class="separator:ga33bf2635033710b25f931b57ed663e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af4f7d2dd375aeedcfa7eb0e1101c4b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws__context.html">lws_context</a> *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga0af4f7d2dd375aeedcfa7eb0e1101c4b">lws_get_context</a> (const struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga0af4f7d2dd375aeedcfa7eb0e1101c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629f48268fd1856b54b11172991b97d9"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga629f48268fd1856b54b11172991b97d9">lws_get_count_threads</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context)</td></tr>
<tr class="separator:ga629f48268fd1856b54b11172991b97d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbca442411f4af9753ab9738a4973d4"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gafdbca442411f4af9753ab9738a4973d4">lws_get_parent</a> (const struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gafdbca442411f4af9753ab9738a4973d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc9fe90471eb724ba314baa21e5e18c"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga7fc9fe90471eb724ba314baa21e5e18c">lws_get_child</a> (const struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga7fc9fe90471eb724ba314baa21e5e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385fa63d2b574ba63a3436686e08c178"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga385fa63d2b574ba63a3436686e08c178">lws_set_parent_carries_io</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga385fa63d2b574ba63a3436686e08c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ddea90114f8d232cda0f999b67b140"><td class="memItemLeft" align="right" valign="top"><a id="gad8ddea90114f8d232cda0f999b67b140"></a>
LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_opaque_parent_data</b> (const struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gad8ddea90114f8d232cda0f999b67b140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf29b5287677dd0cfa84923071d9d7f0"><td class="memItemLeft" align="right" valign="top"><a id="gaaf29b5287677dd0cfa84923071d9d7f0"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>lws_set_opaque_parent_data</b> (struct <a class="el" href="structlws.html">lws</a> *wsi, void *data)</td></tr>
<tr class="separator:gaaf29b5287677dd0cfa84923071d9d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac31670e4570265d658cff17a498bb64"><td class="memItemLeft" align="right" valign="top"><a id="gaac31670e4570265d658cff17a498bb64"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_child_pending_on_writable</b> (const struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gaac31670e4570265d658cff17a498bb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32749399b86d74655c266213b802bc34"><td class="memItemLeft" align="right" valign="top"><a id="ga32749399b86d74655c266213b802bc34"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>lws_clear_child_pending_on_writable</b> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga32749399b86d74655c266213b802bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad999456da40e0300661f2d44f38fd80"><td class="memItemLeft" align="right" valign="top"><a id="gaad999456da40e0300661f2d44f38fd80"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_close_length</b> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gaad999456da40e0300661f2d44f38fd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c862adfc241948a7e8b03d515e8e034"><td class="memItemLeft" align="right" valign="top"><a id="ga4c862adfc241948a7e8b03d515e8e034"></a>
LWS_VISIBLE LWS_EXTERN unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_close_payload</b> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga4c862adfc241948a7e8b03d515e8e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f748977e0f53e9f8889aacfd1ed8a62"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga1f748977e0f53e9f8889aacfd1ed8a62">lws_get_network_wsi</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga1f748977e0f53e9f8889aacfd1ed8a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eac9ba30f8ae8bdd4a6e5ebad20493e"><td class="memItemLeft" align="right" valign="top"><a id="ga4eac9ba30f8ae8bdd4a6e5ebad20493e"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_read</b> (struct <a class="el" href="structlws.html">lws</a> *wsi, unsigned char *buf, lws_filepos_t len)</td></tr>
<tr class="separator:ga4eac9ba30f8ae8bdd4a6e5ebad20493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3f42965ee4c564fcd317ed95ee5604"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gadb3f42965ee4c564fcd317ed95ee5604">lws_set_allocator</a> (void *(*realloc)(void *ptr, size_t size, const char *reason))</td></tr>
<tr class="separator:gadb3f42965ee4c564fcd317ed95ee5604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e705d498e8c8500649a26ba30a1e106"><td class="memItemLeft" align="right" valign="top"><a id="ga0e705d498e8c8500649a26ba30a1e106"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_read</b> (struct <a class="el" href="structlws.html">lws</a> *wsi, unsigned char *buf, size_t len)</td></tr>
<tr class="separator:ga0e705d498e8c8500649a26ba30a1e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab321ed812f46f6dc7ef9e3ca6f00cf1b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gab321ed812f46f6dc7ef9e3ca6f00cf1b">lws_set_allocator</a> (void *(*realloc)(void *ptr, size_t size))</td></tr>
<tr class="separator:gab321ed812f46f6dc7ef9e3ca6f00cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga421f2f17b14cd75176f18c0a85074a8c"><td class="memItemLeft" align="right" valign="top"><a id="ga421f2f17b14cd75176f18c0a85074a8c"></a>
CP_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga421f2f17b14cd75176f18c0a85074a8c">cpVersionString</a></td></tr>
<tr class="memdesc:ga421f2f17b14cd75176f18c0a85074a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version string. <br /></td></tr>
<tr class="separator:ga421f2f17b14cd75176f18c0a85074a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421f2f17b14cd75176f18c0a85074a8c"><td class="memItemLeft" align="right" valign="top"><a id="ga421f2f17b14cd75176f18c0a85074a8c"></a>
CP_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#ga421f2f17b14cd75176f18c0a85074a8c">cpVersionString</a></td></tr>
<tr class="memdesc:ga421f2f17b14cd75176f18c0a85074a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version string. <br /></td></tr>
<tr class="separator:ga421f2f17b14cd75176f18c0a85074a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>Miscellaneous APIs</h2>
<p>Various APIs outside of other categories </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abe29a1fe6d1f2041e95f2fb2e2ce1c">&#9670;&nbsp;</a></span>CP_CONVEX_HULL <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CP_CONVEX_HULL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__count__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__verts__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__count_var__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__verts_var__&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="structcpVect.html">cpVect</a> *__verts_var__ = (<a class="code" href="structcpVect.html">cpVect</a> *)alloca(__count__*<span class="keyword">sizeof</span>(<a class="code" href="structcpVect.html">cpVect</a>)); \</div><div class="line">int __count_var__ = <a class="code" href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull</a>(__count__, __verts__, __verts_var__, NULL, 0.0); \</div><div class="ttc" id="group__misc_html_ga94ed1fc4d2c987c3e4df3cb16b12a156"><div class="ttname"><a href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull</a></div><div class="ttdeci">CP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol)</div></div>
<div class="ttc" id="structcpVect_html"><div class="ttname"><a href="structcpVect.html">cpVect</a></div><div class="ttdef"><b>Definition:</b> chipmunk_types.h:224</div></div>
</div><!-- fragment --><p>Convenience macro to work with cpConvexHull. <code>count</code> and <code>verts</code> is the input array passed to <a class="el" href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull()</a>. <code>count_var</code> and <code>verts_var</code> are the names of the variables the macro creates to store the result. The output vertex array is allocated on the stack using alloca() so it will be freed automatically, but cannot be returned from the current scope. </p>

</div>
</div>
<a id="ga9abe29a1fe6d1f2041e95f2fb2e2ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abe29a1fe6d1f2041e95f2fb2e2ce1c">&#9670;&nbsp;</a></span>CP_CONVEX_HULL <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CP_CONVEX_HULL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__count__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__verts__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__count_var__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__verts_var__&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="structcpVect.html">cpVect</a> *__verts_var__ = (<a class="code" href="structcpVect.html">cpVect</a> *)alloca(__count__*<span class="keyword">sizeof</span>(<a class="code" href="structcpVect.html">cpVect</a>)); \</div><div class="line">int __count_var__ = <a class="code" href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull</a>(__count__, __verts__, __verts_var__, NULL, 0.0); \</div><div class="ttc" id="group__misc_html_ga94ed1fc4d2c987c3e4df3cb16b12a156"><div class="ttname"><a href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull</a></div><div class="ttdeci">CP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol)</div></div>
<div class="ttc" id="structcpVect_html"><div class="ttname"><a href="structcpVect.html">cpVect</a></div><div class="ttdef"><b>Definition:</b> chipmunk_types.h:224</div></div>
</div><!-- fragment --><p>Convenience macro to work with cpConvexHull. <code>count</code> and <code>verts</code> is the input array passed to <a class="el" href="group__misc.html#ga94ed1fc4d2c987c3e4df3cb16b12a156">cpConvexHull()</a>. <code>count_var</code> and <code>verts_var</code> are the names of the variables the macro creates to store the result. The output vertex array is allocated on the stack using alloca() so it will be freed automatically, but cannot be returned from the current scope. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9d94995ca7a1be16bf3d7bd2e449c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d94995ca7a1be16bf3d7bd2e449c812">&#9670;&nbsp;</a></span>lws_end_foreach_ll <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = it-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9d94995ca7a1be16bf3d7bd2e449c812">lws_end_foreach_ll()</a>: linkedlist iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="gaba92c53b57f3e689f8568b02184a8d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba92c53b57f3e689f8568b02184a8d84">&#9670;&nbsp;</a></span>lws_end_foreach_llp <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_end_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nxt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">it = &amp;(*(it))-&gt;nxt; \</div><div class="line">    } \</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gaba92c53b57f3e689f8568b02184a8d84">lws_end_foreach_llp()</a>: linkedlist pointer iterator helper end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>same iterator var name given when starting </td></tr>
    <tr><td class="paramname">nxt</td><td>member name in the iterator pointing to next <a class="el" href="protocollist-p.html">list</a> element</td></tr>
  </table>
  </dd>
</dl>
<p>This helper is the partner for <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a> that ends the while loop. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="ga9f138b98c73782807d88e76c1c532dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f138b98c73782807d88e76c1c532dc2">&#9670;&nbsp;</a></span>lws_start_foreach_ll <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_ll</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = start; \</div><div class="line">    while (it) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>: linkedlist iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz * </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#ga9f138b98c73782807d88e76c1c532dc2">lws_start_foreach_ll()</a>. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<a id="gad973ecfe2ac066ba0ea1ec3695d3e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973ecfe2ac066ba0ea1ec3695d3e896">&#9670;&nbsp;</a></span>lws_start_foreach_llp <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lws_start_foreach_llp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">    type it = &amp;(start); \</div><div class="line">    while (*(it)) {</div></div><!-- fragment --><p><a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>: linkedlist pointer iterator helper start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of iteration, eg, struct xyz ** </td></tr>
    <tr><td class="paramname">it</td><td>iterator var name to create </td></tr>
    <tr><td class="paramname">start</td><td>start of <a class="el" href="protocollist-p.html">list</a></td></tr>
  </table>
  </dd>
</dl>
<p>This helper creates an iterator and starts a while (it) { loop. The iterator runs through the linked <a class="el" href="protocollist-p.html">list</a> starting at the address of start and ends when it gets a NULL. The while loop should be terminated using <a class="el" href="group__misc.html#gad973ecfe2ac066ba0ea1ec3695d3e896">lws_start_foreach_llp()</a>.</p>
<p>This helper variant iterates using a pointer to the previous linked-list element. That allows you to easily delete <a class="el" href="protocollist-p.html">list</a> members by rewriting the previous pointer to the element's next pointer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga55a50f3dfa695db703759e550db16bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a50f3dfa695db703759e550db16bce">&#9670;&nbsp;</a></span>cpAreaForCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpAreaForCircle </td>
          <td>(</td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate area of a hollow circle. <code>r1</code> and <code>r2</code> are the inner and outer diameters. A solid circle has an inner diameter of 0. </p>

</div>
</div>
<a id="ga2bc17e58f105411e2d66c09f8047d822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc17e58f105411e2d66c09f8047d822">&#9670;&nbsp;</a></span>cpAreaForPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpAreaForPoly </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcpVect.html">cpVect</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the signed area of a polygon. A Clockwise winding gives positive area. This is probably backwards from what you expect, but matches Chipmunk's the winding for poly shapes. </p>

</div>
</div>
<a id="ga94ed1fc4d2c987c3e4df3cb16b12a156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ed1fc4d2c987c3e4df3cb16b12a156">&#9670;&nbsp;</a></span>cpConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT int cpConvexHull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcpVect.html">cpVect</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpVect.html">cpVect</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the convex hull of a given set of points. Returns the count of points in the hull. <code>result</code> must be a pointer to a <code><a class="el" href="structcpVect.html">cpVect</a></code> array with at least <code>count</code> elements. If <code>verts</code> == <code>result</code>, then <code>verts</code> will be reduced inplace. <code>first</code> is an optional pointer to an integer to store where the first vertex in the hull came from (i.e. verts[first] == result[0]) <code>tol</code> is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull. </p>

</div>
</div>
<a id="gafa2103fb2fd788fded1131e53f00681a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa2103fb2fd788fded1131e53f00681a">&#9670;&nbsp;</a></span>cpMomentForCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpMomentForCircle </td>
          <td>(</td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpVect.html">cpVect</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the moment of inertia for a circle. <code>r1</code> and <code>r2</code> are the inner and outer diameters. A solid circle has an inner diameter of 0. </p>

</div>
</div>
<a id="ga9548fe7830d426bde625d39d4687e6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9548fe7830d426bde625d39d4687e6be">&#9670;&nbsp;</a></span>cpMomentForSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpMomentForSegment </td>
          <td>(</td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpVect.html">cpVect</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpVect.html">cpVect</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpFloat&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the moment of inertia for a line segment. Beveling radius is not supported. </p>

</div>
</div>
<a id="gace5171b1dbbc03ec89a98f8afdb5c9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace5171b1dbbc03ec89a98f8afdb5c9af">&#9670;&nbsp;</a></span>lws_daemonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_daemonize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_lock_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gace5171b1dbbc03ec89a98f8afdb5c9af">lws_daemonize()</a>: make current process run in the background</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lock_path</td><td>the filepath to write the lock file</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classSpawn.html" title="Spawn a new action immediately. ">Spawn</a> lws as a background process, taking care of various things</p>
<p><a class="el" href="group__misc.html#gace5171b1dbbc03ec89a98f8afdb5c9af">lws_daemonize()</a>: fill a buffer with platform random data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lock_path</td><td>the filepath to write the lock file</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classSpawn.html" title="Spawn a new action immediately. ">Spawn</a> lws as a background process, taking care of various things </p>

</div>
</div>
<a id="ga7fc9fe90471eb724ba314baa21e5e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc9fe90471eb724ba314baa21e5e18c">&#9670;&nbsp;</a></span>lws_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> *LWS_WARN_UNUSED_RESULT lws_get_child </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga7fc9fe90471eb724ba314baa21e5e18c">lws_get_child()</a> - get child wsi or NULL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>lws connection</td></tr>
  </table>
  </dd>
</dl>
<p>Allows you to find a related wsi from the parent wsi. </p>

</div>
</div>
<a id="ga0af4f7d2dd375aeedcfa7eb0e1101c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0af4f7d2dd375aeedcfa7eb0e1101c4b">&#9670;&nbsp;</a></span>lws_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws__context.html">lws_context</a>* LWS_WARN_UNUSED_RESULT lws_get_context </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_get_context - Allow getting <a class="el" href="structlws__context.html">lws_context</a> from a Websocket connection instance</p>
<p>With this function, users can access context in the callback function. Otherwise users may have to declare context as a global variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance</td></tr>
  </table>
  </dd>
</dl>
<p>lws_get_context - Allow geting <a class="el" href="structlws__context.html">lws_context</a> from a Websocket connection instance</p>
<p>With this function, users can access context in the callback function. Otherwise users may have to declare context as a global variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga629f48268fd1856b54b11172991b97d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629f48268fd1856b54b11172991b97d9">&#9670;&nbsp;</a></span>lws_get_count_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_get_count_threads </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga629f48268fd1856b54b11172991b97d9">lws_get_count_threads()</a>: how many service threads the context uses</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the lws context</td></tr>
  </table>
  </dd>
</dl>
<p>By default this is always 1, if you asked for more than lws can handle it will clip the number of threads. So you can use this to find out how many threads are actually in use. </p>

</div>
</div>
<a id="gac6abfc0b2bd5b2f09281a4432bb2f5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6abfc0b2bd5b2f09281a4432bb2f5f0">&#9670;&nbsp;</a></span>lws_get_library_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* LWS_WARN_UNUSED_RESULT lws_get_library_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gac6abfc0b2bd5b2f09281a4432bb2f5f0">lws_get_library_version()</a>: return string describing the version of lws</p>
<p>On unix, also includes the git describe </p>

</div>
</div>
<a id="ga1f748977e0f53e9f8889aacfd1ed8a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f748977e0f53e9f8889aacfd1ed8a62">&#9670;&nbsp;</a></span>lws_get_network_wsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> * lws_get_network_wsi </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga1f748977e0f53e9f8889aacfd1ed8a62">lws_get_network_wsi()</a> - Returns wsi that has the tcp connection for this wsi</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>wsi you have</td></tr>
  </table>
  </dd>
</dl>
<p>Returns wsi that has the tcp connection (which may be the incoming wsi)</p>
<p>HTTP/1 connections will always return the incoming wsi HTTP/2 connections may return a different wsi that has the tcp connection </p>

</div>
</div>
<a id="gafdbca442411f4af9753ab9738a4973d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbca442411f4af9753ab9738a4973d4">&#9670;&nbsp;</a></span>lws_get_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws.html">lws</a> *LWS_WARN_UNUSED_RESULT lws_get_parent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gafdbca442411f4af9753ab9738a4973d4">lws_get_parent()</a> - get parent wsi or NULL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>lws connection</td></tr>
  </table>
  </dd>
</dl>
<p>Specialized wsi like cgi stdin/out/err are associated to a parent wsi, this allows you to get their parent. </p>

</div>
</div>
<a id="ga58f906c6be0ca80efd813f694569dd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f906c6be0ca80efd813f694569dd4a">&#9670;&nbsp;</a></span>lws_get_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_get_random </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga58f906c6be0ca80efd813f694569dd4a">lws_get_random()</a>: fill a buffer with platform random data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the lws context </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to fill </td></tr>
    <tr><td class="paramname">len</td><td>how much to fill</td></tr>
  </table>
  </dd>
</dl>
<p>This is intended to be called from the LWS_CALLBACK_RECEIVE callback if it's interested to see if the frame it's dealing with was sent in binary mode. </p>

</div>
</div>
<a id="ga33bf2635033710b25f931b57ed663e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bf2635033710b25f931b57ed663e1e">&#9670;&nbsp;</a></span>lws_now_secs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN unsigned long lws_now_secs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga33bf2635033710b25f931b57ed663e1e">lws_now_secs()</a>: return seconds since 1970-1-1 </p>

</div>
</div>
<a id="ga1ec0d9faac5d3a5824d765c287c043aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec0d9faac5d3a5824d765c287c043aa">&#9670;&nbsp;</a></span>lws_parse_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_parse_uri </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_parse_uri: cut up prot:/ads:port/path into pieces Notice it does so by dropping '\0' into input string and the leading / on the path is consequently lost</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>incoming uri string.. will get written to </td></tr>
    <tr><td class="paramname">prot</td><td>result pointer for protocol part (<a href="https://">https://</a>) </td></tr>
    <tr><td class="paramname">ads</td><td>result pointer for address part </td></tr>
    <tr><td class="paramname">port</td><td>result pointer for port part </td></tr>
    <tr><td class="paramname">path</td><td>result pointer for path part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab321ed812f46f6dc7ef9e3ca6f00cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab321ed812f46f6dc7ef9e3ca6f00cf1b">&#9670;&nbsp;</a></span>lws_set_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_allocator </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *ptr, size_t size)&#160;</td>
          <td class="paramname"><em>realloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gadb3f42965ee4c564fcd317ed95ee5604">lws_set_allocator()</a> - custom allocator support</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realloc</td><td>Allows you to replace the allocator (and deallocator) used by lws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb3f42965ee4c564fcd317ed95ee5604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3f42965ee4c564fcd317ed95ee5604">&#9670;&nbsp;</a></span>lws_set_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_allocator </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *ptr, size_t size, const char *reason)&#160;</td>
          <td class="paramname"><em>realloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gadb3f42965ee4c564fcd317ed95ee5604">lws_set_allocator()</a> - custom allocator support</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realloc</td><td>Allows you to replace the allocator (and deallocator) used by lws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga385fa63d2b574ba63a3436686e08c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385fa63d2b574ba63a3436686e08c178">&#9670;&nbsp;</a></span>lws_set_parent_carries_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_parent_carries_io </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_parent_carries_io() - mark wsi as needing to send messages via parent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>child lws connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d23abbe3fe1d53592b29c597a8245ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d23abbe3fe1d53592b29c597a8245ba">&#9670;&nbsp;</a></span>lws_set_wsi_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_wsi_user </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_wsi_set_user() - set the user data associated with the client connection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>lws connection </td></tr>
    <tr><td class="paramname">user</td><td>user data</td></tr>
  </table>
  </dd>
</dl>
<p>By default lws allocates this and it's not legal to externally set it yourself. However client connections may have it set externally when the connection is created... if so, this api can be used to modify it at runtime additionally. </p>

</div>
</div>
<a id="ga2163492f17db959a36967adb73d823b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2163492f17db959a36967adb73d823b4">&#9670;&nbsp;</a></span>lws_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#ga2163492f17db959a36967adb73d823b4">lws_snprintf()</a>: snprintf that truncates the returned length too</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>destination buffer </td></tr>
    <tr><td class="paramname">size</td><td>bytes left in destination buffer </td></tr>
    <tr><td class="paramname">format</td><td>format string </td></tr>
    <tr><td class="paramname">...</td><td>args for format</td></tr>
  </table>
  </dd>
</dl>
<p>This lets you correctly truncate buffers by concatenating lengths, if you reach the limit the reported length doesn't exceed the limit. </p>

</div>
</div>
<a id="gaa194584fff9698f3b280658f770ccd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa194584fff9698f3b280658f770ccd0f">&#9670;&nbsp;</a></span>lws_wsi_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void* lws_wsi_user </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__misc.html#gaa194584fff9698f3b280658f770ccd0f">lws_wsi_user()</a> - get the user data associated with the connection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>lws connection</td></tr>
  </table>
  </dd>
</dl>
<p>Not normally needed since it's passed into the callback </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
