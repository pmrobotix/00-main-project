<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: Callback when writeable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Callback when writeable</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga941caaa468bc507b1cae52275f58800d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga941caaa468bc507b1cae52275f58800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe4655c7eeb3eb1671b2323ec6b3107"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#gabbe4655c7eeb3eb1671b2323ec6b3107">lws_callback_on_writable_all_protocol</a> (const struct <a class="el" href="structlws__context.html">lws_context</a> *context, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol)</td></tr>
<tr class="separator:gabbe4655c7eeb3eb1671b2323ec6b3107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8570860e191b62db264f2bac67354ea8"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#ga8570860e191b62db264f2bac67354ea8">lws_callback_on_writable_all_protocol_vhost</a> (const struct lws_vhost *vhost, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol)</td></tr>
<tr class="separator:ga8570860e191b62db264f2bac67354ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf04bbe089f47c971c6408c5efe2ac70"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#gacf04bbe089f47c971c6408c5efe2ac70">lws_callback_all_protocol</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol, int reason)</td></tr>
<tr class="separator:gacf04bbe089f47c971c6408c5efe2ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f893903d9de29c3de5631efad7dd9e6"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#ga9f893903d9de29c3de5631efad7dd9e6">lws_callback_all_protocol_vhost</a> (struct lws_vhost *vh, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol, int reason) LWS_WARN_DEPRECATED</td></tr>
<tr class="separator:ga9f893903d9de29c3de5631efad7dd9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8aa7b8173694221d59443b3516ec85"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#ga0c8aa7b8173694221d59443b3516ec85">lws_callback_all_protocol_vhost_args</a> (struct lws_vhost *vh, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol, int reason, void *argp, size_t len)</td></tr>
<tr class="separator:ga0c8aa7b8173694221d59443b3516ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60939cf0c073d933fde3d17f3591caf5"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#ga60939cf0c073d933fde3d17f3591caf5">lws_callback_vhost_protocols</a> (struct <a class="el" href="structlws.html">lws</a> *wsi, int reason, void *in, int len)</td></tr>
<tr class="separator:ga60939cf0c073d933fde3d17f3591caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3d524a84d2be08ac85153bc158504b"><td class="memItemLeft" align="right" valign="top"><a id="gaad3d524a84d2be08ac85153bc158504b"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_callback_http_dummy</b> (struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gaad3d524a84d2be08ac85153bc158504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa709e02a10558753c851e58f1e2c16ba"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#gaa709e02a10558753c851e58f1e2c16ba">lws_get_socket_fd</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gaa709e02a10558753c851e58f1e2c16ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4643fe16b0940ae5b68b4ee6195cbde"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callback-when-writeable.html#gac4643fe16b0940ae5b68b4ee6195cbde">lws_get_peer_write_allowance</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:gac4643fe16b0940ae5b68b4ee6195cbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>Callback When Writeable</h2>
<p>lws can only write data on a connection when it is able to accept more data without blocking.</p>
<p>So a basic requirement is we should only use the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> apis when the connection we want to write on says that he can accept more data.</p>
<p>When lws cannot complete your send at the time, it will buffer the data and send it in the background, suppressing any further WRITEABLE callbacks on that connection until it completes. So it is important to write new things in a new writeable callback.</p>
<p>These apis reflect the various ways we can indicate we would like to be called back when one or more connections is writeable. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacf04bbe089f47c971c6408c5efe2ac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf04bbe089f47c971c6408c5efe2ac70">&#9670;&nbsp;</a></span>lws_callback_all_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_all_protocol </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#gacf04bbe089f47c971c6408c5efe2ac70">lws_callback_all_protocol()</a> - Callback all connections using the given protocol with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="structlws__context.html">lws_context</a> </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on ALL VHOSTS</li>
<li>When: before returning</li>
<li>What: reason</li>
</ul>
<p>This isn't normally what you want... normally any update of connection- specific information can wait until a network-related callback like rx, writable, or close.</p>
<p><a class="el" href="group__callback-when-writeable.html#gacf04bbe089f47c971c6408c5efe2ac70">lws_callback_all_protocol()</a> - Callback all connections using the given protocol with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="structlws__context.html">lws_context</a> </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on ALL VHOSTS</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: reason </li>
</ul>

</div>
</div>
<a id="ga9f893903d9de29c3de5631efad7dd9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f893903d9de29c3de5631efad7dd9e6">&#9670;&nbsp;</a></span>lws_callback_all_protocol_vhost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_all_protocol_vhost </td>
          <td>(</td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#ga9f893903d9de29c3de5631efad7dd9e6">lws_callback_all_protocol_vhost()</a> - Callback all connections using the given protocol with the given reason. This is deprecated since v2.4: use lws_callback_all_protocol_vhost_args</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vh</td><td>Vhost whose connections will get callbacks </td></tr>
    <tr><td class="paramname">protocol</td><td>Which protocol to match. NULL means all. </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on GIVEN VHOST ONLY</li>
<li>When: now</li>
<li>What: reason</li>
</ul>
<p><a class="el" href="group__callback-when-writeable.html#ga9f893903d9de29c3de5631efad7dd9e6">lws_callback_all_protocol_vhost()</a> - Callback all connections using the given protocol with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vh</td><td>Vhost whose connections will get callbacks </td></tr>
    <tr><td class="paramname">protocol</td><td>Which protocol to match </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on GIVEN VHOST ONLY</li>
<li>When: now</li>
<li>What: reason </li>
</ul>

</div>
</div>
<a id="ga0c8aa7b8173694221d59443b3516ec85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8aa7b8173694221d59443b3516ec85">&#9670;&nbsp;</a></span>lws_callback_all_protocol_vhost_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE int lws_callback_all_protocol_vhost_args </td>
          <td>(</td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#ga0c8aa7b8173694221d59443b3516ec85">lws_callback_all_protocol_vhost_args()</a> - Callback all connections using the given protocol with the given reason and args</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vh</td><td>Vhost whose connections will get callbacks </td></tr>
    <tr><td class="paramname">protocol</td><td>Which protocol to match. NULL means all. </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index </td></tr>
    <tr><td class="paramname">argp</td><td>Callback "in" parameter </td></tr>
    <tr><td class="paramname">len</td><td>Callback "len" parameter</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on GIVEN VHOST ONLY</li>
<li>When: now</li>
<li>What: reason </li>
</ul>

</div>
</div>
<a id="ga941caaa468bc507b1cae52275f58800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941caaa468bc507b1cae52275f58800d">&#9670;&nbsp;</a></span>lws_callback_on_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> - Request a callback when this socket becomes able to be written to without blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance to get callback for</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: only this wsi</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: LWS_CALLBACK_*_WRITEABLE </li>
</ul>

</div>
</div>
<a id="gabbe4655c7eeb3eb1671b2323ec6b3107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbe4655c7eeb3eb1671b2323ec6b3107">&#9670;&nbsp;</a></span>lws_callback_on_writable_all_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable_all_protocol </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#gabbe4655c7eeb3eb1671b2323ec6b3107">lws_callback_on_writable_all_protocol()</a> - Request a callback for all connections using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="structlws__context.html">lws_context</a> </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on ANY VHOST</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: LWS_CALLBACK_*_WRITEABLE</li>
</ul>
<p><a class="el" href="group__callback-when-writeable.html#gabbe4655c7eeb3eb1671b2323ec6b3107">lws_callback_on_writable_all_protocol()</a> - Request a callback for all connections on same vhost using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td><a class="el" href="structlws__context.html">lws_context</a> </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on ANY VHOST</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: LWS_CALLBACK_*_WRITEABLE </li>
</ul>

</div>
</div>
<a id="ga8570860e191b62db264f2bac67354ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8570860e191b62db264f2bac67354ea8">&#9670;&nbsp;</a></span>lws_callback_on_writable_all_protocol_vhost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable_all_protocol_vhost </td>
          <td>(</td>
          <td class="paramtype">const struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vhost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#ga8570860e191b62db264f2bac67354ea8">lws_callback_on_writable_all_protocol_vhost()</a> - Request a callback for all connections on same vhost using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vhost</td><td>Only consider connections on this lws_vhost </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on GIVEN VHOST ONLY</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: LWS_CALLBACK_*_WRITEABLE</li>
</ul>
<p><a class="el" href="group__callback-when-writeable.html#ga8570860e191b62db264f2bac67354ea8">lws_callback_on_writable_all_protocol_vhost()</a> - Request a callback for all connections using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vhost</td><td>Only consider connections on this lws_vhost </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on GIVEN VHOST ONLY</li>
<li>When: when the individual connection becomes writeable</li>
<li>What: LWS_CALLBACK_*_WRITEABLE </li>
</ul>

</div>
</div>
<a id="ga60939cf0c073d933fde3d17f3591caf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60939cf0c073d933fde3d17f3591caf5">&#9670;&nbsp;</a></span>lws_callback_vhost_protocols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_vhost_protocols </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#ga60939cf0c073d933fde3d17f3591caf5">lws_callback_vhost_protocols()</a> - Callback all protocols enabled on a vhost with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>wsi whose vhost will get callbacks </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index </td></tr>
    <tr><td class="paramname">in</td><td>in argument to callback </td></tr>
    <tr><td class="paramname">len</td><td>len argument to callback</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Which: connections using this protocol on same VHOST as wsi ONLY</li>
<li>When: now</li>
<li>What: reason </li>
</ul>

</div>
</div>
<a id="gac4643fe16b0940ae5b68b4ee6195cbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4643fe16b0940ae5b68b4ee6195cbde">&#9670;&nbsp;</a></span>lws_get_peer_write_allowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_get_peer_write_allowance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#gac4643fe16b0940ae5b68b4ee6195cbde">lws_get_peer_write_allowance()</a> - get the amount of data writeable to peer if known</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance</td></tr>
  </table>
  </dd>
</dl>
<p>if the protocol does not have any guidance, returns -1. Currently only http2 connections get send window information from this API. But your code should use it so it can work properly with any protocol.</p>
<p>If nonzero return is the amount of payload data the peer or intermediary has reported it has buffer space for. That has NO relationship with the amount of buffer space your OS can accept on this connection for a write action.</p>
<p>This number represents the maximum you could send to the peer or intermediary on this connection right now without the protocol complaining.</p>
<p>lws manages accounting for send window updates and payload writes automatically, so this number reflects the situation at the peer or intermediary dynamically. </p>

</div>
</div>
<a id="gaa709e02a10558753c851e58f1e2c16ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa709e02a10558753c851e58f1e2c16ba">&#9670;&nbsp;</a></span>lws_get_socket_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_get_socket_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__callback-when-writeable.html#gaa709e02a10558753c851e58f1e2c16ba">lws_get_socket_fd()</a> - returns the socket file descriptor</p>
<p>You will not need this unless you are doing something special</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
