<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Node Class Reference<div class="ingroups"><a class="el" href="group____2d.html">2D Nodes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> is the base element of the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph. Elements of the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph must be <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> objects or subclasses of it. The most common <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> objects are: <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>, <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a>, <a class="el" href="classSprite.html">Sprite</a>, <a class="el" href="classMenu.html" title="A Menu for touch handling. ">Menu</a>, <a class="el" href="classLabel.html" title="Label is a subclass of Node that knows how to render text labels. ">Label</a>.  
 <a href="classNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cocos2d_2cocos_22d_2CCNode_8h_source.html">CCNode.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classRef.html">Ref</a>, and <a class="el" href="classRef.html">Ref</a>.</p>

<p>Inherited by <a class="el" href="class____NodeRGBA.html">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html">__NodeRGBA</a>, <a class="el" href="classAssetsManager.html">AssetsManager</a>, <a class="el" href="classAssetsManager.html">AssetsManager</a>, <a class="el" href="classAtlasNode.html">AtlasNode</a>, <a class="el" href="classAtlasNode.html">AtlasNode</a>, <a class="el" href="classAttachNode.html">AttachNode</a>, <a class="el" href="classAttachNode.html">AttachNode</a>, <a class="el" href="classBaseLight.html">BaseLight</a>, <a class="el" href="classBaseLight.html">BaseLight</a>, <a class="el" href="classCamera.html">Camera</a>, <a class="el" href="classCamera.html">Camera</a>, <a class="el" href="classClippingNode.html">ClippingNode</a>, <a class="el" href="classClippingNode.html">ClippingNode</a>, <a class="el" href="classClippingRectangleNode.html">ClippingRectangleNode</a>, <a class="el" href="classClippingRectangleNode.html">ClippingRectangleNode</a>, <a class="el" href="classDrawNode.html">DrawNode</a>, <a class="el" href="classDrawNode.html">DrawNode</a>, <a class="el" href="classexperimental_1_1TMXLayer.html">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html">experimental::TMXTiledMap</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html">experimental::TMXTiledMap</a>, <a class="el" href="classLabel.html">Label</a>, <a class="el" href="classLabel.html">Label</a>, <a class="el" href="classLayer.html">Layer</a>, <a class="el" href="classLayer.html">Layer</a>, <a class="el" href="classMenuItem.html">MenuItem</a>, <a class="el" href="classMenuItem.html">MenuItem</a>, <a class="el" href="classMotionStreak.html">MotionStreak</a>, <a class="el" href="classMotionStreak.html">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html">MotionStreak3D</a>, <a class="el" href="classNodeGrid.html">NodeGrid</a>, <a class="el" href="classNodeGrid.html">NodeGrid</a>, <a class="el" href="classParallaxNode.html">ParallaxNode</a>, <a class="el" href="classParallaxNode.html">ParallaxNode</a>, <a class="el" href="classParticleBatchNode.html">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html">ParticleBatchNode</a>, <a class="el" href="classParticleSystem.html">ParticleSystem</a>, <a class="el" href="classParticleSystem.html">ParticleSystem</a>, <a class="el" href="classParticleSystem3D.html">ParticleSystem3D</a>, <a class="el" href="classParticleSystem3D.html">ParticleSystem3D</a>, <a class="el" href="classProgressTimer.html">ProgressTimer</a>, <a class="el" href="classProgressTimer.html">ProgressTimer</a>, <a class="el" href="classProtectedNode.html">ProtectedNode</a>, <a class="el" href="classProtectedNode.html">ProtectedNode</a>, <a class="el" href="classRenderTexture.html">RenderTexture</a>, <a class="el" href="classRenderTexture.html">RenderTexture</a>, <a class="el" href="classScene.html">Scene</a>, <a class="el" href="classScene.html">Scene</a>, <a class="el" href="classSkybox.html">Skybox</a>, <a class="el" href="classSkybox.html">Skybox</a>, <a class="el" href="classSprite.html">Sprite</a>, <a class="el" href="classSprite.html">Sprite</a>, <a class="el" href="classSprite3D.html">Sprite3D</a>, <a class="el" href="classSprite3D.html">Sprite3D</a>, <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a>, <a class="el" href="classTableViewCell.html">TableViewCell</a>, <a class="el" href="classTableViewCell.html">TableViewCell</a>, <a class="el" href="classTerrain.html">Terrain</a>, <a class="el" href="classTerrain.html">Terrain</a>, <a class="el" href="classTMXTiledMap.html">TMXTiledMap</a>, <a class="el" href="classTMXTiledMap.html">TMXTiledMap</a>, and <a class="el" href="classui_1_1Scale9Sprite.html">ui::Scale9Sprite</a>.</p>
<div class="dynheader">
Collaboration diagram for Node:</div>
<div class="dyncontent">
<div class="center"><img src="classNode__coll__graph.png" border="0" usemap="#Node_coll__map" alt="Collaboration graph"/></div>
<map name="Node_coll__map" id="Node_coll__map">
<area shape="rect" id="node4" href="struct__hashElement.html" title="_hashElement" alt="" coords="1437,2065,1543,2092"/>
<area shape="rect" id="node7" href="classAction.html" title="Base class for Action objects. " alt="" coords="1181,2071,1239,2097"/>
<area shape="rect" id="node9" href="classGLProgramState.html" title="GLProgramState" alt="" coords="2589,953,2708,980"/>
<area shape="rect" id="node12" href="classDirector.html" title="Class that creates and handles the main Window and manages how and when to execute the Scenes..." alt="" coords="2049,1448,2117,1475"/>
<area shape="rect" id="node24" href="classEventListener.html" title="The base class of event listener. If you need custom listener which with different callback..." alt="" coords="1159,751,1261,777"/>
<area shape="rect" id="node29" href="classAtlasNode.html" title="AtlasNode is a subclass of Node that implements the RGBAProtocol and TextureProtocol protocol..." alt="" coords="1169,1427,1251,1453"/>
<area shape="rect" id="node36" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. " alt="" coords="1747,813,1805,840"/>
<area shape="rect" id="node37" href="classCamera.html" title="Camera" alt="" coords="2049,792,2117,819"/>
<area shape="rect" id="node45" href="classEvent.html" title="Base class of all kinds of events. " alt="" coords="1182,1369,1238,1396"/>
<area shape="rect" id="node2" href="classRef.html" title="Ref" alt="" coords="241,861,284,888"/>
<area shape="rect" id="node3" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single..." alt="" coords="1721,1996,1831,2023"/>
<area shape="rect" id="node10" href="classGLProgram.html" title="GLProgram" alt="" coords="2384,1055,2472,1081"/>
<area shape="rect" id="node25" href="classGroupCommandManager.html" title="GroupCommandManager" alt="" coords="487,449,653,476"/>
<area shape="rect" id="node27" href="classEventDispatcher.html" title="This class manages event listener subscriptions and event dispatching. " alt="" coords="511,799,629,825"/>
<area shape="rect" id="node32" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ..." alt="" coords="530,371,610,397"/>
<area shape="rect" id="node38" href="classexperimental_1_1FrameBuffer.html" title="experimental::FrameBuffer" alt="" coords="677,736,853,763"/>
<area shape="rect" id="node39" href="classGLView.html" title="By GLView you can operate the frame information of EGL view through some function. " alt="" coords="1176,1793,1244,1820"/>
<area shape="rect" id="node46" href="classTextureCache.html" title="Singleton that handles the loading of textures. Once the texture is loaded, the next time it will ret..." alt="" coords="518,1459,622,1485"/>
<area shape="rect" id="node5" href="structUT__hash__handle.html" title="UT_hash_handle" alt="" coords="5,2133,125,2160"/>
<area shape="rect" id="node6" href="structUT__hash__table.html" title="UT_hash_table" alt="" coords="207,2199,318,2225"/>
<area shape="rect" id="node33" href="struct__hashSelectorEntry.html" title="_hashSelectorEntry" alt="" coords="195,239,331,265"/>
<area shape="rect" id="node35" href="struct__hashUpdateEntry.html" title="_hashUpdateEntry" alt="" coords="197,603,328,629"/>
<area shape="rect" id="node8" href="classClonable.html" title="Clonable" alt="" coords="909,2133,983,2160"/>
<area shape="rect" id="node20" href="classTrianglesCommand.html" title="TrianglesCommand" alt="" coords="2857,2109,2992,2136"/>
<area shape="rect" id="node22" href="classMeshCommand.html" title="MeshCommand" alt="" coords="2867,953,2982,980"/>
<area shape="rect" id="node11" href="structGLProgram_1_1UniformFlags.html" title="GLProgram::UniformFlags" alt="" coords="1996,1055,2171,1081"/>
<area shape="rect" id="node13" href="classRenderer.html" title="Renderer" alt="" coords="3413,928,3488,955"/>
<area shape="rect" id="node14" href="structV3F__C4B__T2F.html" title="V3F_C4B_T2F" alt="" coords="2029,211,2138,237"/>
<area shape="rect" id="node15" href="classVec3.html" title="Vec3" alt="" coords="1750,536,1802,563"/>
<area shape="rect" id="node16" href="structTex2F.html" title="Tex2F" alt="" coords="1747,5,1805,32"/>
<area shape="rect" id="node17" href="structColor4B.html" title="Color4B" alt="" coords="1741,212,1811,239"/>
<area shape="rect" id="node18" href="structColor4F.html" title="Color4F" alt="" coords="3125,901,3193,928"/>
<area shape="rect" id="node19" href="structRenderer_1_1TriBatchToDraw.html" title="Renderer::TriBatchToDraw" alt="" coords="3069,1697,3248,1724"/>
<area shape="rect" id="node21" href="classMat4.html" title="Mat4" alt="" coords="545,2279,595,2305"/>
<area shape="rect" id="node23" href="classEventListenerCustom.html" title="Custom event listener. " alt="" coords="1416,751,1564,777"/>
<area shape="rect" id="node26" href="classSize.html" title="Size" alt="" coords="546,1859,594,1885"/>
<area shape="rect" id="node40" href="classRect.html" title="Rect" alt="" coords="921,1629,971,1656"/>
<area shape="rect" id="node28" href="classLabelAtlas.html" title="LabelAtlas is a subclass of AtlasNode. " alt="" coords="1449,1484,1531,1511"/>
<area shape="rect" id="node30" href="structColor3B.html" title="Color3B" alt="" coords="535,1333,605,1360"/>
<area shape="rect" id="node34" href="struct__listEntry.html" title="_listEntry" alt="" coords="224,343,301,369"/>
<area shape="rect" id="node41" href="classVec2.html" title="Vec2" alt="" coords="544,1695,596,1721"/>
<area shape="rect" id="node42" href="classVRIRenderer.html" title="VRIRenderer" alt="" coords="897,1731,995,1757"/>
<area shape="rect" id="node43" href="structGLContextAttrs.html" title="GLContextAttrs" alt="" coords="889,1781,1003,1808"/>
<area shape="rect" id="node44" href="classEventCustom.html" title="Custom event. " alt="" coords="1439,1369,1541,1396"/>
<area shape="rect" id="node47" href="classVector.html" title="Vector\&lt; Scene *\&gt;" alt="" coords="1713,1448,1839,1475"/>
<area shape="rect" id="node48" href="classQuaternion.html" title="Quaternion" alt="" coords="527,1076,613,1103"/>
<area shape="rect" id="node49" href="classVector.html" title="Vector\&lt; Node *\&gt;" alt="" coords="510,1127,630,1153"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80347cd8f3e30ff3faace5bf580cbc37"><td class="memItemLeft" align="right" valign="top"><a id="a80347cd8f3e30ff3faace5bf580cbc37"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>FLAGS_TRANSFORM_DIRTY</b> = (1 &lt;&lt; 0), 
<b>FLAGS_CONTENT_SIZE_DIRTY</b> = (1 &lt;&lt; 1), 
<b>FLAGS_RENDER_AS_3D</b> = (1 &lt;&lt; 3), 
<b>FLAGS_DIRTY_MASK</b> = (FLAGS_TRANSFORM_DIRTY | FLAGS_CONTENT_SIZE_DIRTY)
 }</td></tr>
<tr class="separator:a80347cd8f3e30ff3faace5bf580cbc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5541f9d4c99ae10697c6b4fa62fab4"><td class="memItemLeft" align="right" valign="top"><a id="aab5541f9d4c99ae10697c6b4fa62fab4"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>FLAGS_TRANSFORM_DIRTY</b> = (1 &lt;&lt; 0), 
<b>FLAGS_CONTENT_SIZE_DIRTY</b> = (1 &lt;&lt; 1), 
<b>FLAGS_RENDER_AS_3D</b> = (1 &lt;&lt; 3), 
<b>FLAGS_DIRTY_MASK</b> = (FLAGS_TRANSFORM_DIRTY | FLAGS_CONTENT_SIZE_DIRTY)
 }</td></tr>
<tr class="separator:aab5541f9d4c99ae10697c6b4fa62fab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebd879ffa85ad31896051073e1d7a6d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aebd879ffa85ad31896051073e1d7a6d8">isRunning</a> () const</td></tr>
<tr class="separator:aebd879ffa85ad31896051073e1d7a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc543c82cc9b139cfb57f65eb770fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0fc543c82cc9b139cfb57f65eb770fb0">scheduleUpdateWithPriorityLua</a> (int handler, int priority)</td></tr>
<tr class="separator:a0fc543c82cc9b139cfb57f65eb770fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2de84c6cdeec9cd647d236c30ee0567"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a> ()</td></tr>
<tr class="separator:aa2de84c6cdeec9cd647d236c30ee0567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf85087a15901deb7c6c1231634c8ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abcf85087a15901deb7c6c1231634c8ab">draw</a> (<a class="el" href="classRenderer.html">Renderer</a> *renderer, const <a class="el" href="classMat4.html">Mat4</a> &amp;transform, uint32_t flags)</td></tr>
<tr class="separator:abcf85087a15901deb7c6c1231634c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9c2703e4e4fd4ac75cae4593ef78f"><td class="memItemLeft" align="right" valign="top"><a id="a0ee9c2703e4e4fd4ac75cae4593ef78f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>draw</b> () final</td></tr>
<tr class="separator:a0ee9c2703e4e4fd4ac75cae4593ef78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d794a5e30745611ec33881a625edf26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7d794a5e30745611ec33881a625edf26">visit</a> (<a class="el" href="classRenderer.html">Renderer</a> *renderer, const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform, uint32_t parentFlags)</td></tr>
<tr class="separator:a7d794a5e30745611ec33881a625edf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751486a54cdcb7f75db9f11be8469818"><td class="memItemLeft" align="right" valign="top"><a id="a751486a54cdcb7f75db9f11be8469818"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> () final</td></tr>
<tr class="separator:a751486a54cdcb7f75db9f11be8469818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a61a356773de436f80e55228ea01b66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5a61a356773de436f80e55228ea01b66">getScene</a> () const</td></tr>
<tr class="separator:a5a61a356773de436f80e55228ea01b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3849315467fdb992b273fbd3b3fc66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7b3849315467fdb992b273fbd3b3fc66">getBoundingBox</a> () const</td></tr>
<tr class="separator:a7b3849315467fdb992b273fbd3b3fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744d16609dfc7609e889129b8672afb"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="classRect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7744d16609dfc7609e889129b8672afb">boundingBox</a> () const</td></tr>
<tr class="separator:a7744d16609dfc7609e889129b8672afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add71c94aeabd15707311742797d21bb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#add71c94aeabd15707311742797d21bb3">setEventDispatcher</a> (<a class="el" href="classEventDispatcher.html">EventDispatcher</a> *dispatcher)</td></tr>
<tr class="separator:add71c94aeabd15707311742797d21bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba7b287241f031b271d7d680f070f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEventDispatcher.html">EventDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae6ba7b287241f031b271d7d680f070f3">getEventDispatcher</a> () const</td></tr>
<tr class="separator:ae6ba7b287241f031b271d7d680f070f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999cce3763ea09e74014245c770ea97"><td class="memItemLeft" align="right" valign="top">virtual GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab999cce3763ea09e74014245c770ea97">getOpacity</a> () const</td></tr>
<tr class="separator:ab999cce3763ea09e74014245c770ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f9c61560c8862ebdaecbf79bf8a1b6"><td class="memItemLeft" align="right" valign="top">virtual GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac4f9c61560c8862ebdaecbf79bf8a1b6">getDisplayedOpacity</a> () const</td></tr>
<tr class="separator:ac4f9c61560c8862ebdaecbf79bf8a1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a9db63bfa3d466ee7c9d79c35352d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae41a9db63bfa3d466ee7c9d79c35352d">setOpacity</a> (GLubyte opacity)</td></tr>
<tr class="separator:ae41a9db63bfa3d466ee7c9d79c35352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0122884e7e1ce310b8b68abfbb245b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3a0122884e7e1ce310b8b68abfbb245b">updateDisplayedOpacity</a> (GLubyte parentOpacity)</td></tr>
<tr class="separator:a3a0122884e7e1ce310b8b68abfbb245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f5da3b20b08356467db7ce95cf9f54"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a79f5da3b20b08356467db7ce95cf9f54">isCascadeOpacityEnabled</a> () const</td></tr>
<tr class="separator:a79f5da3b20b08356467db7ce95cf9f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b08f1d19bb0345f6fb40d9a3e3b4a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a56b08f1d19bb0345f6fb40d9a3e3b4a4">setCascadeOpacityEnabled</a> (bool cascadeOpacityEnabled)</td></tr>
<tr class="separator:a56b08f1d19bb0345f6fb40d9a3e3b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06721d272f5a59e02e355d95be25bb99"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a06721d272f5a59e02e355d95be25bb99">getColor</a> () const</td></tr>
<tr class="separator:a06721d272f5a59e02e355d95be25bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899760bbad414bfbe9fb51473e99c3eb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a899760bbad414bfbe9fb51473e99c3eb">getDisplayedColor</a> () const</td></tr>
<tr class="separator:a899760bbad414bfbe9fb51473e99c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45037de5b13602263b1ce51b50cafdd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af45037de5b13602263b1ce51b50cafdd">setColor</a> (const <a class="el" href="structColor3B.html">Color3B</a> &amp;color)</td></tr>
<tr class="separator:af45037de5b13602263b1ce51b50cafdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac733bae7b9590f8da746cbc3d1337a2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac733bae7b9590f8da746cbc3d1337a2f">updateDisplayedColor</a> (const <a class="el" href="structColor3B.html">Color3B</a> &amp;parentColor)</td></tr>
<tr class="separator:ac733bae7b9590f8da746cbc3d1337a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf874f1b388e773ca80732b1134508be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abf874f1b388e773ca80732b1134508be">isCascadeColorEnabled</a> () const</td></tr>
<tr class="separator:abf874f1b388e773ca80732b1134508be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7f2dde1e3a7d56880f59f1480955e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4e7f2dde1e3a7d56880f59f1480955e7">setCascadeColorEnabled</a> (bool cascadeColorEnabled)</td></tr>
<tr class="separator:a4e7f2dde1e3a7d56880f59f1480955e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978c5435ab23f76e9efdf0f7e9e288e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a978c5435ab23f76e9efdf0f7e9e288e5">setOpacityModifyRGB</a> (bool value)</td></tr>
<tr class="separator:a978c5435ab23f76e9efdf0f7e9e288e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ce32d2088e2bb3426608334f1091c5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae6ce32d2088e2bb3426608334f1091c5">isOpacityModifyRGB</a> () const</td></tr>
<tr class="separator:ae6ce32d2088e2bb3426608334f1091c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c42f72323ef791d720b9083f480cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a69c42f72323ef791d720b9083f480cb4">setOnEnterCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:a69c42f72323ef791d720b9083f480cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b097bc5f33406aa84f0b31cabc8c91"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad7b097bc5f33406aa84f0b31cabc8c91">getOnEnterCallback</a> () const</td></tr>
<tr class="separator:ad7b097bc5f33406aa84f0b31cabc8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e2254c47969bfa81be037230738367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a82e2254c47969bfa81be037230738367">setOnExitCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:a82e2254c47969bfa81be037230738367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4c33e5b8ef5770d0f4d8ed410e596"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab0b4c33e5b8ef5770d0f4d8ed410e596">getOnExitCallback</a> () const</td></tr>
<tr class="separator:ab0b4c33e5b8ef5770d0f4d8ed410e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad666c48b3a6952c3c4b6c4c1eb446ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aad666c48b3a6952c3c4b6c4c1eb446ad">setonEnterTransitionDidFinishCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:aad666c48b3a6952c3c4b6c4c1eb446ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af905ed9ea4b7884fdb9be2b8b2fbcf53"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af905ed9ea4b7884fdb9be2b8b2fbcf53">getonEnterTransitionDidFinishCallback</a> () const</td></tr>
<tr class="separator:af905ed9ea4b7884fdb9be2b8b2fbcf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0270c92c148c57b0605aae8298e356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aca0270c92c148c57b0605aae8298e356">setonExitTransitionDidStartCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:aca0270c92c148c57b0605aae8298e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d572d520d31dd83ed3eedd2b78d4e"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a306d572d520d31dd83ed3eedd2b78d4e">getonExitTransitionDidStartCallback</a> () const</td></tr>
<tr class="separator:a306d572d520d31dd83ed3eedd2b78d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c849d2d0bd878a4e3dd1a52ab90fee8"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1c849d2d0bd878a4e3dd1a52ab90fee8">getCameraMask</a> () const</td></tr>
<tr class="separator:a1c849d2d0bd878a4e3dd1a52ab90fee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0403546687b2cb6fc211fb461e33ba4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0403546687b2cb6fc211fb461e33ba4d">setCameraMask</a> (unsigned short mask, bool applyChildren=true)</td></tr>
<tr class="separator:a0403546687b2cb6fc211fb461e33ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6293815ad5f410cf3e1378fcb98b2ff7"><td class="memItemLeft" align="right" valign="top"><a id="a6293815ad5f410cf3e1378fcb98b2ff7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:a6293815ad5f410cf3e1378fcb98b2ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc885c0dbeceaa3857b52dff68ed4b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af5dc885c0dbeceaa3857b52dff68ed4b">isRunning</a> () const</td></tr>
<tr class="separator:af5dc885c0dbeceaa3857b52dff68ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc543c82cc9b139cfb57f65eb770fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0fc543c82cc9b139cfb57f65eb770fb0">scheduleUpdateWithPriorityLua</a> (int handler, int priority)</td></tr>
<tr class="separator:a0fc543c82cc9b139cfb57f65eb770fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f07dff5b7089859092bece5f328aa5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4f07dff5b7089859092bece5f328aa5d">cleanup</a> ()</td></tr>
<tr class="separator:a4f07dff5b7089859092bece5f328aa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8fdadb6e26b198cb15920e4d998754"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6f8fdadb6e26b198cb15920e4d998754">draw</a> (<a class="el" href="classRenderer.html">Renderer</a> *renderer, const <a class="el" href="classMat4.html">Mat4</a> &amp;transform, uint32_t flags)</td></tr>
<tr class="separator:a6f8fdadb6e26b198cb15920e4d998754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae847c0d9a021be8f256ac206b0698bf6"><td class="memItemLeft" align="right" valign="top"><a id="ae847c0d9a021be8f256ac206b0698bf6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>draw</b> () final</td></tr>
<tr class="separator:ae847c0d9a021be8f256ac206b0698bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76252604e0e9e0f8a8830c97993133f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a76252604e0e9e0f8a8830c97993133f4">visit</a> (<a class="el" href="classRenderer.html">Renderer</a> *renderer, const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform, uint32_t parentFlags)</td></tr>
<tr class="separator:a76252604e0e9e0f8a8830c97993133f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826b7591e66c7bbf344e0bfd6d8ea5ed"><td class="memItemLeft" align="right" valign="top"><a id="a826b7591e66c7bbf344e0bfd6d8ea5ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> () final</td></tr>
<tr class="separator:a826b7591e66c7bbf344e0bfd6d8ea5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0150253ebac47b36dfcdf8f8f8696"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adab0150253ebac47b36dfcdf8f8f8696">getScene</a> () const</td></tr>
<tr class="separator:adab0150253ebac47b36dfcdf8f8f8696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d421a217968b87898b7a7382ff7e1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a18d421a217968b87898b7a7382ff7e1b">getBoundingBox</a> () const</td></tr>
<tr class="separator:a18d421a217968b87898b7a7382ff7e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744d16609dfc7609e889129b8672afb"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="classRect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7744d16609dfc7609e889129b8672afb">boundingBox</a> () const</td></tr>
<tr class="separator:a7744d16609dfc7609e889129b8672afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c33fba3541a982e253f9d6c908daaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a07c33fba3541a982e253f9d6c908daaa">setEventDispatcher</a> (<a class="el" href="classEventDispatcher.html">EventDispatcher</a> *dispatcher)</td></tr>
<tr class="separator:a07c33fba3541a982e253f9d6c908daaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba7b287241f031b271d7d680f070f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEventDispatcher.html">EventDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae6ba7b287241f031b271d7d680f070f3">getEventDispatcher</a> () const</td></tr>
<tr class="separator:ae6ba7b287241f031b271d7d680f070f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46206e9eb52b57c070446613659fe310"><td class="memItemLeft" align="right" valign="top">virtual GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a46206e9eb52b57c070446613659fe310">getOpacity</a> () const</td></tr>
<tr class="separator:a46206e9eb52b57c070446613659fe310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bba31d0e8774ac3fe5c517bfe86e97"><td class="memItemLeft" align="right" valign="top">virtual GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a81bba31d0e8774ac3fe5c517bfe86e97">getDisplayedOpacity</a> () const</td></tr>
<tr class="separator:a81bba31d0e8774ac3fe5c517bfe86e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add84cdfdadeb8862c2149a57a565017c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#add84cdfdadeb8862c2149a57a565017c">setOpacity</a> (GLubyte opacity)</td></tr>
<tr class="separator:add84cdfdadeb8862c2149a57a565017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed685e5e2976c1387525aae96f39f4f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aed685e5e2976c1387525aae96f39f4f5">updateDisplayedOpacity</a> (GLubyte parentOpacity)</td></tr>
<tr class="separator:aed685e5e2976c1387525aae96f39f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d78071b3146583829431d79ffc6ae08"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9d78071b3146583829431d79ffc6ae08">isCascadeOpacityEnabled</a> () const</td></tr>
<tr class="separator:a9d78071b3146583829431d79ffc6ae08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e36b274a6ee75f4931611b4c53f6180"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9e36b274a6ee75f4931611b4c53f6180">setCascadeOpacityEnabled</a> (bool cascadeOpacityEnabled)</td></tr>
<tr class="separator:a9e36b274a6ee75f4931611b4c53f6180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9507fbd163ea92784f52f4cd15c000d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af9507fbd163ea92784f52f4cd15c000d">getColor</a> () const</td></tr>
<tr class="separator:af9507fbd163ea92784f52f4cd15c000d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285caec57206ce980b727b86e1976f7"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1285caec57206ce980b727b86e1976f7">getDisplayedColor</a> () const</td></tr>
<tr class="separator:a1285caec57206ce980b727b86e1976f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2360069ccef753ff1f9665d0e2d3f83a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2360069ccef753ff1f9665d0e2d3f83a">setColor</a> (const <a class="el" href="structColor3B.html">Color3B</a> &amp;color)</td></tr>
<tr class="separator:a2360069ccef753ff1f9665d0e2d3f83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e96bdf8038cd786486941f2f5a712ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9e96bdf8038cd786486941f2f5a712ea">updateDisplayedColor</a> (const <a class="el" href="structColor3B.html">Color3B</a> &amp;parentColor)</td></tr>
<tr class="separator:a9e96bdf8038cd786486941f2f5a712ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ade1991e3cff2c032d50fc7f7392764"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4ade1991e3cff2c032d50fc7f7392764">isCascadeColorEnabled</a> () const</td></tr>
<tr class="separator:a4ade1991e3cff2c032d50fc7f7392764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0638fb9f5b4c522e75ee4ad01393bb48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0638fb9f5b4c522e75ee4ad01393bb48">setCascadeColorEnabled</a> (bool cascadeColorEnabled)</td></tr>
<tr class="separator:a0638fb9f5b4c522e75ee4ad01393bb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03297671eb3440831666a3aa25875f1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a03297671eb3440831666a3aa25875f1d">setOpacityModifyRGB</a> (bool value)</td></tr>
<tr class="separator:a03297671eb3440831666a3aa25875f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bb22bd30b2ab6f1534518db6895b87"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af7bb22bd30b2ab6f1534518db6895b87">isOpacityModifyRGB</a> () const</td></tr>
<tr class="separator:af7bb22bd30b2ab6f1534518db6895b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c42f72323ef791d720b9083f480cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a69c42f72323ef791d720b9083f480cb4">setOnEnterCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:a69c42f72323ef791d720b9083f480cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b097bc5f33406aa84f0b31cabc8c91"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad7b097bc5f33406aa84f0b31cabc8c91">getOnEnterCallback</a> () const</td></tr>
<tr class="separator:ad7b097bc5f33406aa84f0b31cabc8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e2254c47969bfa81be037230738367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a82e2254c47969bfa81be037230738367">setOnExitCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:a82e2254c47969bfa81be037230738367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4c33e5b8ef5770d0f4d8ed410e596"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab0b4c33e5b8ef5770d0f4d8ed410e596">getOnExitCallback</a> () const</td></tr>
<tr class="separator:ab0b4c33e5b8ef5770d0f4d8ed410e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad666c48b3a6952c3c4b6c4c1eb446ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aad666c48b3a6952c3c4b6c4c1eb446ad">setonEnterTransitionDidFinishCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:aad666c48b3a6952c3c4b6c4c1eb446ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af905ed9ea4b7884fdb9be2b8b2fbcf53"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af905ed9ea4b7884fdb9be2b8b2fbcf53">getonEnterTransitionDidFinishCallback</a> () const</td></tr>
<tr class="separator:af905ed9ea4b7884fdb9be2b8b2fbcf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0270c92c148c57b0605aae8298e356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aca0270c92c148c57b0605aae8298e356">setonExitTransitionDidStartCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="separator:aca0270c92c148c57b0605aae8298e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d572d520d31dd83ed3eedd2b78d4e"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a306d572d520d31dd83ed3eedd2b78d4e">getonExitTransitionDidStartCallback</a> () const</td></tr>
<tr class="separator:a306d572d520d31dd83ed3eedd2b78d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c849d2d0bd878a4e3dd1a52ab90fee8"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1c849d2d0bd878a4e3dd1a52ab90fee8">getCameraMask</a> () const</td></tr>
<tr class="separator:a1c849d2d0bd878a4e3dd1a52ab90fee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9901c9b33e733877b2c4a47af38787d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad9901c9b33e733877b2c4a47af38787d">setCameraMask</a> (unsigned short mask, bool applyChildren=true)</td></tr>
<tr class="separator:ad9901c9b33e733877b2c4a47af38787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e2db56bbd63f35deb06da5e64a574d"><td class="memItemLeft" align="right" valign="top"><a id="ae5e2db56bbd63f35deb06da5e64a574d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:ae5e2db56bbd63f35deb06da5e64a574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setters &amp; Getters for Graphic Properties</div></td></tr>
<tr class="memitem:aee4e616c2d55b722226aae1e68b4946f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder</a> (int localZOrder)</td></tr>
<tr class="separator:aee4e616c2d55b722226aae1e68b4946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88b083cf8714fe62a3180ca790073a4"><td class="memItemLeft" align="right" valign="top"><a id="ae88b083cf8714fe62a3180ca790073a4"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setZOrder</b> (int localZOrder)</td></tr>
<tr class="separator:ae88b083cf8714fe62a3180ca790073a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9228657d144a272e8ac471c5a9b9e0dc"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9228657d144a272e8ac471c5a9b9e0dc">_setLocalZOrder</a> (int z)</td></tr>
<tr class="separator:a9228657d144a272e8ac471c5a9b9e0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75318d1418261ae7e8856ba2868b5a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a75318d1418261ae7e8856ba2868b5a81">updateOrderOfArrival</a> ()</td></tr>
<tr class="separator:a75318d1418261ae7e8856ba2868b5a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9c743ae124b0c1a2d6f0a28a1f06dd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9a9c743ae124b0c1a2d6f0a28a1f06dd">getLocalZOrder</a> () const</td></tr>
<tr class="separator:a9a9c743ae124b0c1a2d6f0a28a1f06dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8637477bb812d66559eb8ca6b6f5c854"><td class="memItemLeft" align="right" valign="top"><a id="a8637477bb812d66559eb8ca6b6f5c854"></a>
virtual CC_DEPRECATED_ATTRIBUTE int&#160;</td><td class="memItemRight" valign="bottom"><b>getZOrder</b> () const</td></tr>
<tr class="separator:a8637477bb812d66559eb8ca6b6f5c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a5b9cb9a408d04008c4935a4776566"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a32a5b9cb9a408d04008c4935a4776566">setGlobalZOrder</a> (float globalZOrder)</td></tr>
<tr class="separator:a32a5b9cb9a408d04008c4935a4776566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5a7920169dbe5f21a59029bb04c166"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afa5a7920169dbe5f21a59029bb04c166">getGlobalZOrder</a> () const</td></tr>
<tr class="separator:afa5a7920169dbe5f21a59029bb04c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7f04074f7f49972e152788c090b877"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acf7f04074f7f49972e152788c090b877">setScaleX</a> (float scaleX)</td></tr>
<tr class="memdesc:acf7f04074f7f49972e152788c090b877"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleX setter  <a href="#acf7f04074f7f49972e152788c090b877">More...</a><br /></td></tr>
<tr class="separator:acf7f04074f7f49972e152788c090b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27040ef8ab59ccf42b87d6ddc8d794e6"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a27040ef8ab59ccf42b87d6ddc8d794e6">getScaleX</a> () const</td></tr>
<tr class="memdesc:a27040ef8ab59ccf42b87d6ddc8d794e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleX getter  <a href="#a27040ef8ab59ccf42b87d6ddc8d794e6">More...</a><br /></td></tr>
<tr class="separator:a27040ef8ab59ccf42b87d6ddc8d794e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec805a1fa9e8e1038556e468138bb804"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aec805a1fa9e8e1038556e468138bb804">setScaleY</a> (float scaleY)</td></tr>
<tr class="memdesc:aec805a1fa9e8e1038556e468138bb804"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleY setter  <a href="#aec805a1fa9e8e1038556e468138bb804">More...</a><br /></td></tr>
<tr class="separator:aec805a1fa9e8e1038556e468138bb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87661ab8940512baf2e7639ea55ff87"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab87661ab8940512baf2e7639ea55ff87">getScaleY</a> () const</td></tr>
<tr class="memdesc:ab87661ab8940512baf2e7639ea55ff87"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleY getter  <a href="#ab87661ab8940512baf2e7639ea55ff87">More...</a><br /></td></tr>
<tr class="separator:ab87661ab8940512baf2e7639ea55ff87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79518b90226335e0997552687eb7b33f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a79518b90226335e0997552687eb7b33f">setScaleZ</a> (float scaleZ)</td></tr>
<tr class="memdesc:a79518b90226335e0997552687eb7b33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleY setter  <a href="#a79518b90226335e0997552687eb7b33f">More...</a><br /></td></tr>
<tr class="separator:a79518b90226335e0997552687eb7b33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b55ddbe04d126953e1db8606d9a9ecd"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0b55ddbe04d126953e1db8606d9a9ecd">getScaleZ</a> () const</td></tr>
<tr class="memdesc:a0b55ddbe04d126953e1db8606d9a9ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaleY getter  <a href="#a0b55ddbe04d126953e1db8606d9a9ecd">More...</a><br /></td></tr>
<tr class="separator:a0b55ddbe04d126953e1db8606d9a9ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0955a52f51a9d6c8b0c9267b1e8668"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acf0955a52f51a9d6c8b0c9267b1e8668">setScale</a> (float scale)</td></tr>
<tr class="memdesc:acf0955a52f51a9d6c8b0c9267b1e8668"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale setter  <a href="#acf0955a52f51a9d6c8b0c9267b1e8668">More...</a><br /></td></tr>
<tr class="separator:acf0955a52f51a9d6c8b0c9267b1e8668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9926440d4edab1020d348a2b950307c"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac9926440d4edab1020d348a2b950307c">getScale</a> () const</td></tr>
<tr class="memdesc:ac9926440d4edab1020d348a2b950307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale getter  <a href="#ac9926440d4edab1020d348a2b950307c">More...</a><br /></td></tr>
<tr class="separator:ac9926440d4edab1020d348a2b950307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f8130cfd505a5c327c4cc66fe4fa69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a31f8130cfd505a5c327c4cc66fe4fa69">setScale</a> (float scaleX, float scaleY)</td></tr>
<tr class="memdesc:a31f8130cfd505a5c327c4cc66fe4fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale setter  <a href="#a31f8130cfd505a5c327c4cc66fe4fa69">More...</a><br /></td></tr>
<tr class="separator:a31f8130cfd505a5c327c4cc66fe4fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffbf25763ef5f15eeae7227779505bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8ffbf25763ef5f15eeae7227779505bc">setPosition</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="memdesc:a8ffbf25763ef5f15eeae7227779505bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">position setter  <a href="#a8ffbf25763ef5f15eeae7227779505bc">More...</a><br /></td></tr>
<tr class="separator:a8ffbf25763ef5f15eeae7227779505bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3665662090ae9ebd3820ee4e7199da7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3665662090ae9ebd3820ee4e7199da7b">setNormalizedPosition</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="memdesc:a3665662090ae9ebd3820ee4e7199da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">position setter  <a href="#a3665662090ae9ebd3820ee4e7199da7b">More...</a><br /></td></tr>
<tr class="separator:a3665662090ae9ebd3820ee4e7199da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c78c6feace91b27b6cbb12ee16e8eb0"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1c78c6feace91b27b6cbb12ee16e8eb0">getPosition</a> () const</td></tr>
<tr class="memdesc:a1c78c6feace91b27b6cbb12ee16e8eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">position getter  <a href="#a1c78c6feace91b27b6cbb12ee16e8eb0">More...</a><br /></td></tr>
<tr class="separator:a1c78c6feace91b27b6cbb12ee16e8eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9887ca06e6ecc7e19806927036bf8b57"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9887ca06e6ecc7e19806927036bf8b57">getNormalizedPosition</a> () const</td></tr>
<tr class="memdesc:a9887ca06e6ecc7e19806927036bf8b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">position getter  <a href="#a9887ca06e6ecc7e19806927036bf8b57">More...</a><br /></td></tr>
<tr class="separator:a9887ca06e6ecc7e19806927036bf8b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8545c103ef1b35e5076dbedab93af5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaa8545c103ef1b35e5076dbedab93af5">setPosition</a> (float x, float y)</td></tr>
<tr class="separator:aaa8545c103ef1b35e5076dbedab93af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f30e9a2dda896b2ffff1885b33a98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a216f30e9a2dda896b2ffff1885b33a98">getPosition</a> (float *x, float *y) const</td></tr>
<tr class="separator:a216f30e9a2dda896b2ffff1885b33a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dfc73d6122a95778d5d9db3d1fd913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae1dfc73d6122a95778d5d9db3d1fd913">setPositionX</a> (float x)</td></tr>
<tr class="separator:ae1dfc73d6122a95778d5d9db3d1fd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b27cd8bc98960789fbd2b574666a25"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad4b27cd8bc98960789fbd2b574666a25">getPositionX</a> (void) const</td></tr>
<tr class="separator:ad4b27cd8bc98960789fbd2b574666a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c97d36655f0daa71a5f6c715d2b0470"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5c97d36655f0daa71a5f6c715d2b0470">setPositionY</a> (float y)</td></tr>
<tr class="separator:a5c97d36655f0daa71a5f6c715d2b0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab411fb5477789b7b96477b18c0f83"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae2ab411fb5477789b7b96477b18c0f83">getPositionY</a> (void) const</td></tr>
<tr class="separator:ae2ab411fb5477789b7b96477b18c0f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eee02836d359b1469cf8a1484b485f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa9eee02836d359b1469cf8a1484b485f">setPosition3D</a> (const <a class="el" href="classVec3.html">Vec3</a> &amp;position)</td></tr>
<tr class="separator:aa9eee02836d359b1469cf8a1484b485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617dd2eb9af75a66ebaff0d3c99285e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8617dd2eb9af75a66ebaff0d3c99285e">getPosition3D</a> () const</td></tr>
<tr class="separator:a8617dd2eb9af75a66ebaff0d3c99285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea9bcbb6e5972122c590b930b5a90b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaea9bcbb6e5972122c590b930b5a90b9">setPositionZ</a> (float positionZ)</td></tr>
<tr class="separator:aaea9bcbb6e5972122c590b930b5a90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6caed983c3f8d7686ebd602bb27de08"><td class="memItemLeft" align="right" valign="top"><a id="ae6caed983c3f8d7686ebd602bb27de08"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setVertexZ</b> (float vertexZ)</td></tr>
<tr class="separator:ae6caed983c3f8d7686ebd602bb27de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6023aabdeeff9cf981ad81e6aaed9c"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0c6023aabdeeff9cf981ad81e6aaed9c">getPositionZ</a> () const</td></tr>
<tr class="separator:a0c6023aabdeeff9cf981ad81e6aaed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e0714dcf9b018f0bfddc4e1d48257b"><td class="memItemLeft" align="right" valign="top"><a id="af9e0714dcf9b018f0bfddc4e1d48257b"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexZ</b> () const</td></tr>
<tr class="separator:af9e0714dcf9b018f0bfddc4e1d48257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cf4d7b304b57a3f593d9eecde3ac7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a48cf4d7b304b57a3f593d9eecde3ac7f">setSkewX</a> (float skewX)</td></tr>
<tr class="separator:a48cf4d7b304b57a3f593d9eecde3ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb23628a9cef9c16cfcfd955a51ac8bd"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adb23628a9cef9c16cfcfd955a51ac8bd">getSkewX</a> () const</td></tr>
<tr class="separator:adb23628a9cef9c16cfcfd955a51ac8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f4c4be8099a0d4bca1464c51f81f94"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac1f4c4be8099a0d4bca1464c51f81f94">setSkewY</a> (float skewY)</td></tr>
<tr class="separator:ac1f4c4be8099a0d4bca1464c51f81f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260877f2b51c284555fc272c7ba28f46"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a260877f2b51c284555fc272c7ba28f46">getSkewY</a> () const</td></tr>
<tr class="separator:a260877f2b51c284555fc272c7ba28f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd45cb48a51df7c257675f527e3f277"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4dd45cb48a51df7c257675f527e3f277">setAnchorPoint</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;anchorPoint)</td></tr>
<tr class="separator:a4dd45cb48a51df7c257675f527e3f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391027410f7f45889938090feb631cba"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a391027410f7f45889938090feb631cba">getAnchorPoint</a> () const</td></tr>
<tr class="memdesc:a391027410f7f45889938090feb631cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">anchorPoint getter  <a href="#a391027410f7f45889938090feb631cba">More...</a><br /></td></tr>
<tr class="separator:a391027410f7f45889938090feb631cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288b900788ed2db5eddb9d84751a3602"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a288b900788ed2db5eddb9d84751a3602">getAnchorPointInPoints</a> () const</td></tr>
<tr class="separator:a288b900788ed2db5eddb9d84751a3602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade113d7fc9244f58ac98a4712da49818"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ade113d7fc9244f58ac98a4712da49818">setContentSize</a> (const <a class="el" href="classSize.html">Size</a> &amp;contentSize)</td></tr>
<tr class="separator:ade113d7fc9244f58ac98a4712da49818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828836a62dbf0862ecaa99a72babc13"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classSize.html">Size</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3828836a62dbf0862ecaa99a72babc13">getContentSize</a> () const</td></tr>
<tr class="memdesc:a3828836a62dbf0862ecaa99a72babc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">contentSize getter  <a href="#a3828836a62dbf0862ecaa99a72babc13">More...</a><br /></td></tr>
<tr class="separator:a3828836a62dbf0862ecaa99a72babc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d9f6f838941a2a8ae18420757af158"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad8d9f6f838941a2a8ae18420757af158">setVisible</a> (bool visible)</td></tr>
<tr class="memdesc:ad8d9f6f838941a2a8ae18420757af158"><td class="mdescLeft">&#160;</td><td class="mdescRight">isVisible setter  <a href="#ad8d9f6f838941a2a8ae18420757af158">More...</a><br /></td></tr>
<tr class="separator:ad8d9f6f838941a2a8ae18420757af158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff189524c62c6cb446cc19e3a79ab4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#accff189524c62c6cb446cc19e3a79ab4">isVisible</a> () const</td></tr>
<tr class="memdesc:accff189524c62c6cb446cc19e3a79ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">isVisible getter  <a href="#accff189524c62c6cb446cc19e3a79ab4">More...</a><br /></td></tr>
<tr class="separator:accff189524c62c6cb446cc19e3a79ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dda439f77712f0d9b405ce887df676"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a62dda439f77712f0d9b405ce887df676">setRotation</a> (float rotation)</td></tr>
<tr class="memdesc:a62dda439f77712f0d9b405ce887df676"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation setter  <a href="#a62dda439f77712f0d9b405ce887df676">More...</a><br /></td></tr>
<tr class="separator:a62dda439f77712f0d9b405ce887df676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7139bc3ea6705d41bb65a4fb7ddb6c"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aca7139bc3ea6705d41bb65a4fb7ddb6c">getRotation</a> () const</td></tr>
<tr class="memdesc:aca7139bc3ea6705d41bb65a4fb7ddb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation getter  <a href="#aca7139bc3ea6705d41bb65a4fb7ddb6c">More...</a><br /></td></tr>
<tr class="separator:aca7139bc3ea6705d41bb65a4fb7ddb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce988bebd6c8b804d8bfdfafd511c40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2ce988bebd6c8b804d8bfdfafd511c40">setRotation3D</a> (const <a class="el" href="classVec3.html">Vec3</a> &amp;rotation)</td></tr>
<tr class="separator:a2ce988bebd6c8b804d8bfdfafd511c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabcf9427f303b0adf32bb7513706e2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aeabcf9427f303b0adf32bb7513706e2c">getRotation3D</a> () const</td></tr>
<tr class="separator:aeabcf9427f303b0adf32bb7513706e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c0b9e9afc4668320d90c340e5727e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a59c0b9e9afc4668320d90c340e5727e7">setRotationQuat</a> (const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:a59c0b9e9afc4668320d90c340e5727e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5beb5903cd9dc3258b513e742d1a0d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQuaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad5beb5903cd9dc3258b513e742d1a0d0">getRotationQuat</a> () const</td></tr>
<tr class="separator:ad5beb5903cd9dc3258b513e742d1a0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a533225994dbfe125c3421df4cbb38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a66a533225994dbfe125c3421df4cbb38">setRotationSkewX</a> (float rotationX)</td></tr>
<tr class="separator:a66a533225994dbfe125c3421df4cbb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bd25ac980529f8a410523a42ab6e2a"><td class="memItemLeft" align="right" valign="top"><a id="ad1bd25ac980529f8a410523a42ab6e2a"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setRotationX</b> (float rotationX)</td></tr>
<tr class="separator:ad1bd25ac980529f8a410523a42ab6e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23faa37bc1d55b7c4b6cba94a62fce"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2e23faa37bc1d55b7c4b6cba94a62fce">getRotationSkewX</a> () const</td></tr>
<tr class="separator:a2e23faa37bc1d55b7c4b6cba94a62fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0fe1e486b4d0bbbc7e2a4203865285"><td class="memItemLeft" align="right" valign="top"><a id="aac0fe1e486b4d0bbbc7e2a4203865285"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationX</b> () const</td></tr>
<tr class="separator:aac0fe1e486b4d0bbbc7e2a4203865285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901c5fbd2327fbd6fd14771fd45d71af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a901c5fbd2327fbd6fd14771fd45d71af">setRotationSkewY</a> (float rotationY)</td></tr>
<tr class="separator:a901c5fbd2327fbd6fd14771fd45d71af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f99fb391706801bd5c162654a8786c"><td class="memItemLeft" align="right" valign="top"><a id="a66f99fb391706801bd5c162654a8786c"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setRotationY</b> (float rotationY)</td></tr>
<tr class="separator:a66f99fb391706801bd5c162654a8786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cad8b8118f9530baa3f26659cc1f406"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6cad8b8118f9530baa3f26659cc1f406">getRotationSkewY</a> () const</td></tr>
<tr class="separator:a6cad8b8118f9530baa3f26659cc1f406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61900edf93cad256bd250f69e02065"><td class="memItemLeft" align="right" valign="top"><a id="aee61900edf93cad256bd250f69e02065"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationY</b> () const</td></tr>
<tr class="separator:aee61900edf93cad256bd250f69e02065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad218be5dafbfc529444c1e619841260e"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad218be5dafbfc529444c1e619841260e">setGLServerState</a> (int serverState)</td></tr>
<tr class="separator:ad218be5dafbfc529444c1e619841260e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4817ce95fa64827e8a58645e5b5854ae"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4817ce95fa64827e8a58645e5b5854ae">getGLServerState</a> () const</td></tr>
<tr class="separator:a4817ce95fa64827e8a58645e5b5854ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e8f6a6a46358d6faf8683e720d47b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a75e8f6a6a46358d6faf8683e720d47b5">setIgnoreAnchorPointForPosition</a> (bool ignore)</td></tr>
<tr class="memdesc:a75e8f6a6a46358d6faf8683e720d47b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">isRelativeAnchorPoint setter  <a href="#a75e8f6a6a46358d6faf8683e720d47b5">More...</a><br /></td></tr>
<tr class="separator:a75e8f6a6a46358d6faf8683e720d47b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b28e27b22e7473e902771db3581e4"><td class="memItemLeft" align="right" valign="top"><a id="af57b28e27b22e7473e902771db3581e4"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreAnchorPointForPosition</b> (bool ignore)</td></tr>
<tr class="separator:af57b28e27b22e7473e902771db3581e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997a39d72ed74207a8ff7b5fe921be9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1997a39d72ed74207a8ff7b5fe921be9">isIgnoreAnchorPointForPosition</a> () const</td></tr>
<tr class="memdesc:a1997a39d72ed74207a8ff7b5fe921be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">isRelativeAnchorPoint getter  <a href="#a1997a39d72ed74207a8ff7b5fe921be9">More...</a><br /></td></tr>
<tr class="separator:a1997a39d72ed74207a8ff7b5fe921be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a240c11ff1bbc265e46bbc2e1d34179"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3a240c11ff1bbc265e46bbc2e1d34179">setLocalZOrder</a> (std::int32_t localZOrder)</td></tr>
<tr class="separator:a3a240c11ff1bbc265e46bbc2e1d34179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc612dbd8cd0226aaaff754b4162984b"><td class="memItemLeft" align="right" valign="top"><a id="adc612dbd8cd0226aaaff754b4162984b"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setZOrder</b> (std::int32_t localZOrder)</td></tr>
<tr class="separator:adc612dbd8cd0226aaaff754b4162984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab4e6bbde6dad91266f8fde8e25b77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae0ab4e6bbde6dad91266f8fde8e25b77">_setLocalZOrder</a> (std::int32_t z)</td></tr>
<tr class="separator:ae0ab4e6bbde6dad91266f8fde8e25b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75318d1418261ae7e8856ba2868b5a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a75318d1418261ae7e8856ba2868b5a81">updateOrderOfArrival</a> ()</td></tr>
<tr class="separator:a75318d1418261ae7e8856ba2868b5a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f41047bd53b12c645a429246e31ea4"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a03f41047bd53b12c645a429246e31ea4">getLocalZOrder</a> () const</td></tr>
<tr class="separator:a03f41047bd53b12c645a429246e31ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8121dfe765cf4cb25ba7c8ca2c5fc741"><td class="memItemLeft" align="right" valign="top"><a id="a8121dfe765cf4cb25ba7c8ca2c5fc741"></a>
virtual CC_DEPRECATED_ATTRIBUTE std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getZOrder</b> () const</td></tr>
<tr class="separator:a8121dfe765cf4cb25ba7c8ca2c5fc741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad45bcba0411770b5ef88f5409d06bb2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aad45bcba0411770b5ef88f5409d06bb2">setGlobalZOrder</a> (float globalZOrder)</td></tr>
<tr class="separator:aad45bcba0411770b5ef88f5409d06bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5a7920169dbe5f21a59029bb04c166"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afa5a7920169dbe5f21a59029bb04c166">getGlobalZOrder</a> () const</td></tr>
<tr class="separator:afa5a7920169dbe5f21a59029bb04c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8182769547584d8d7297b7a946da4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a49f8182769547584d8d7297b7a946da4">setScaleX</a> (float scaleX)</td></tr>
<tr class="separator:a49f8182769547584d8d7297b7a946da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef411875aa6c675e72de13f91235694"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3ef411875aa6c675e72de13f91235694">getScaleX</a> () const</td></tr>
<tr class="separator:a3ef411875aa6c675e72de13f91235694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464e6b40bc036450fed05f8c74103e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af464e6b40bc036450fed05f8c74103e7">setScaleY</a> (float scaleY)</td></tr>
<tr class="separator:af464e6b40bc036450fed05f8c74103e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634136734ab9cce2a3797a621b788c68"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a634136734ab9cce2a3797a621b788c68">getScaleY</a> () const</td></tr>
<tr class="separator:a634136734ab9cce2a3797a621b788c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaafb9dc116fdf029f51c7d3e6011a7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aeaafb9dc116fdf029f51c7d3e6011a7f">setScaleZ</a> (float scaleZ)</td></tr>
<tr class="separator:aeaafb9dc116fdf029f51c7d3e6011a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac40998528bbad71f1aca2cfab032aca"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aac40998528bbad71f1aca2cfab032aca">getScaleZ</a> () const</td></tr>
<tr class="separator:aac40998528bbad71f1aca2cfab032aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666da31a8bf7f106409ea8aef707f215"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a666da31a8bf7f106409ea8aef707f215">setScale</a> (float scale)</td></tr>
<tr class="separator:a666da31a8bf7f106409ea8aef707f215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a6e8e0d7cc140bf3aa55b5898d8f5d"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af8a6e8e0d7cc140bf3aa55b5898d8f5d">getScale</a> () const</td></tr>
<tr class="separator:af8a6e8e0d7cc140bf3aa55b5898d8f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3e5ab7d2a14b166ba539f0db9010e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4a3e5ab7d2a14b166ba539f0db9010e3">setScale</a> (float scaleX, float scaleY)</td></tr>
<tr class="separator:a4a3e5ab7d2a14b166ba539f0db9010e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ed194c372246c8018222d303faa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a63f9ed194c372246c8018222d303faa7">setPosition</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="separator:a63f9ed194c372246c8018222d303faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4014e9c3840ed79bf9e5b5193e1f1a4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4014e9c3840ed79bf9e5b5193e1f1a4b">setPositionNormalized</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="memdesc:a4014e9c3840ed79bf9e5b5193e1f1a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">position setter  <a href="#a4014e9c3840ed79bf9e5b5193e1f1a4b">More...</a><br /></td></tr>
<tr class="separator:a4014e9c3840ed79bf9e5b5193e1f1a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4779b7bb240c9a6467142a360685c"><td class="memItemLeft" align="right" valign="top"><a id="ab3b4779b7bb240c9a6467142a360685c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setNormalizedPosition</b> (const <a class="el" href="classVec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="separator:ab3b4779b7bb240c9a6467142a360685c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9123d87921aefc06960a5089c995d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a47e9123d87921aefc06960a5089c995d">getPosition</a> () const</td></tr>
<tr class="separator:a47e9123d87921aefc06960a5089c995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d2fb3ed00ccc33d22c1f903622950f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae9d2fb3ed00ccc33d22c1f903622950f">getPositionNormalized</a> () const</td></tr>
<tr class="memdesc:ae9d2fb3ed00ccc33d22c1f903622950f"><td class="mdescLeft">&#160;</td><td class="mdescRight">position getter  <a href="#ae9d2fb3ed00ccc33d22c1f903622950f">More...</a><br /></td></tr>
<tr class="separator:ae9d2fb3ed00ccc33d22c1f903622950f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468e84257f42e045c3ffcb68aaa363f1"><td class="memItemLeft" align="right" valign="top"><a id="a468e84257f42e045c3ffcb68aaa363f1"></a>
virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNormalizedPosition</b> () const</td></tr>
<tr class="separator:a468e84257f42e045c3ffcb68aaa363f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23be53d56922c9ee20ff63ec296a1f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa23be53d56922c9ee20ff63ec296a1f7">setPosition</a> (float x, float y)</td></tr>
<tr class="separator:aa23be53d56922c9ee20ff63ec296a1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48898f3e8629cf9f7da78b0ae0c68ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad48898f3e8629cf9f7da78b0ae0c68ae">getPosition</a> (float *x, float *y) const</td></tr>
<tr class="separator:ad48898f3e8629cf9f7da78b0ae0c68ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b26ff930ebb0b241bc40b7f573be417"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2b26ff930ebb0b241bc40b7f573be417">setPositionX</a> (float x)</td></tr>
<tr class="separator:a2b26ff930ebb0b241bc40b7f573be417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39284a5629f41cc50054e538ab28f5ab"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a39284a5629f41cc50054e538ab28f5ab">getPositionX</a> (void) const</td></tr>
<tr class="separator:a39284a5629f41cc50054e538ab28f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec74667c8b24b5164e536b999bc8eaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acec74667c8b24b5164e536b999bc8eaa">setPositionY</a> (float y)</td></tr>
<tr class="separator:acec74667c8b24b5164e536b999bc8eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6335e604f0c11512e45f607f38e72ec"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac6335e604f0c11512e45f607f38e72ec">getPositionY</a> (void) const</td></tr>
<tr class="separator:ac6335e604f0c11512e45f607f38e72ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3343ed96ab373ab30bef52123179a86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad3343ed96ab373ab30bef52123179a86">setPosition3D</a> (const <a class="el" href="classVec3.html">Vec3</a> &amp;position)</td></tr>
<tr class="separator:ad3343ed96ab373ab30bef52123179a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3cc76f19c34ce2d4edd48bece7731b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7c3cc76f19c34ce2d4edd48bece7731b">getPosition3D</a> () const</td></tr>
<tr class="separator:a7c3cc76f19c34ce2d4edd48bece7731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44e31f8e5d05e54e5594228406ed76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acf44e31f8e5d05e54e5594228406ed76">setPositionZ</a> (float positionZ)</td></tr>
<tr class="separator:acf44e31f8e5d05e54e5594228406ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6caed983c3f8d7686ebd602bb27de08"><td class="memItemLeft" align="right" valign="top"><a id="ae6caed983c3f8d7686ebd602bb27de08"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setVertexZ</b> (float vertexZ)</td></tr>
<tr class="separator:ae6caed983c3f8d7686ebd602bb27de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e59f1a76dd9a1307730da7018b551b"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a05e59f1a76dd9a1307730da7018b551b">getPositionZ</a> () const</td></tr>
<tr class="separator:a05e59f1a76dd9a1307730da7018b551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e0714dcf9b018f0bfddc4e1d48257b"><td class="memItemLeft" align="right" valign="top"><a id="af9e0714dcf9b018f0bfddc4e1d48257b"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexZ</b> () const</td></tr>
<tr class="separator:af9e0714dcf9b018f0bfddc4e1d48257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a875e4c96d5ef4286d8fa31062047"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a237a875e4c96d5ef4286d8fa31062047">setSkewX</a> (float skewX)</td></tr>
<tr class="separator:a237a875e4c96d5ef4286d8fa31062047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b2e936143dfd1622c568b2d56792b"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adb7b2e936143dfd1622c568b2d56792b">getSkewX</a> () const</td></tr>
<tr class="separator:adb7b2e936143dfd1622c568b2d56792b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa785fa12d35c571bac718f7b025cc684"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa785fa12d35c571bac718f7b025cc684">setSkewY</a> (float skewY)</td></tr>
<tr class="separator:aa785fa12d35c571bac718f7b025cc684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a75fa3bd0937f475c0846692d232f"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a005a75fa3bd0937f475c0846692d232f">getSkewY</a> () const</td></tr>
<tr class="separator:a005a75fa3bd0937f475c0846692d232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa861dc1d80a74801ee198a7a63a58a55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa861dc1d80a74801ee198a7a63a58a55">setAnchorPoint</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;anchorPoint)</td></tr>
<tr class="separator:aa861dc1d80a74801ee198a7a63a58a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38378d77548a5c7bab5370f05882bb2f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a38378d77548a5c7bab5370f05882bb2f">getAnchorPoint</a> () const</td></tr>
<tr class="separator:a38378d77548a5c7bab5370f05882bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a34e8bc876a6c391a31e8263237f844"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3a34e8bc876a6c391a31e8263237f844">getAnchorPointInPoints</a> () const</td></tr>
<tr class="separator:a3a34e8bc876a6c391a31e8263237f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cee4ec181c4f879e14e32c7c4b96ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af2cee4ec181c4f879e14e32c7c4b96ca">setContentSize</a> (const <a class="el" href="classSize.html">Size</a> &amp;contentSize)</td></tr>
<tr class="separator:af2cee4ec181c4f879e14e32c7c4b96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2f3f01d27d07883359139fce9d628a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classSize.html">Size</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7f2f3f01d27d07883359139fce9d628a">getContentSize</a> () const</td></tr>
<tr class="separator:a7f2f3f01d27d07883359139fce9d628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dd28750fa14ef6e2ec4525c4491ad8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa6dd28750fa14ef6e2ec4525c4491ad8">setVisible</a> (bool visible)</td></tr>
<tr class="separator:aa6dd28750fa14ef6e2ec4525c4491ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2595262a2b597f9d254ba6cfdae713c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2595262a2b597f9d254ba6cfdae713c0">isVisible</a> () const</td></tr>
<tr class="separator:a2595262a2b597f9d254ba6cfdae713c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e0cda8797b5b94398a123bfe600f21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad2e0cda8797b5b94398a123bfe600f21">setRotation</a> (float rotation)</td></tr>
<tr class="separator:ad2e0cda8797b5b94398a123bfe600f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd3900c64525f5b76b0ba7cd489f440"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2bd3900c64525f5b76b0ba7cd489f440">getRotation</a> () const</td></tr>
<tr class="separator:a2bd3900c64525f5b76b0ba7cd489f440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53b989e70e96a62f2aabaa26094f4b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad53b989e70e96a62f2aabaa26094f4b0">setRotation3D</a> (const <a class="el" href="classVec3.html">Vec3</a> &amp;rotation)</td></tr>
<tr class="separator:ad53b989e70e96a62f2aabaa26094f4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aab6e44008bf374051cc87c76d9079f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9aab6e44008bf374051cc87c76d9079f">getRotation3D</a> () const</td></tr>
<tr class="separator:a9aab6e44008bf374051cc87c76d9079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da11f365bd691d42161cca0c729e5e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3da11f365bd691d42161cca0c729e5e5">setRotationQuat</a> (const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:a3da11f365bd691d42161cca0c729e5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6200a7e63f7ccccabc82a7a4554e7d36"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQuaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6200a7e63f7ccccabc82a7a4554e7d36">getRotationQuat</a> () const</td></tr>
<tr class="separator:a6200a7e63f7ccccabc82a7a4554e7d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c7e9e926cf94379b437a41eba0b111"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a63c7e9e926cf94379b437a41eba0b111">setRotationSkewX</a> (float rotationX)</td></tr>
<tr class="separator:a63c7e9e926cf94379b437a41eba0b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bd25ac980529f8a410523a42ab6e2a"><td class="memItemLeft" align="right" valign="top"><a id="ad1bd25ac980529f8a410523a42ab6e2a"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setRotationX</b> (float rotationX)</td></tr>
<tr class="separator:ad1bd25ac980529f8a410523a42ab6e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1102a3896c8af0bd11d1cf9a8b89f4fa"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1102a3896c8af0bd11d1cf9a8b89f4fa">getRotationSkewX</a> () const</td></tr>
<tr class="separator:a1102a3896c8af0bd11d1cf9a8b89f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0fe1e486b4d0bbbc7e2a4203865285"><td class="memItemLeft" align="right" valign="top"><a id="aac0fe1e486b4d0bbbc7e2a4203865285"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationX</b> () const</td></tr>
<tr class="separator:aac0fe1e486b4d0bbbc7e2a4203865285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8744ead180b08a285e56f59e5e178c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abb8744ead180b08a285e56f59e5e178c">setRotationSkewY</a> (float rotationY)</td></tr>
<tr class="separator:abb8744ead180b08a285e56f59e5e178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f99fb391706801bd5c162654a8786c"><td class="memItemLeft" align="right" valign="top"><a id="a66f99fb391706801bd5c162654a8786c"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setRotationY</b> (float rotationY)</td></tr>
<tr class="separator:a66f99fb391706801bd5c162654a8786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3ba7aeb143dbf516bfbdff965ee53a"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acd3ba7aeb143dbf516bfbdff965ee53a">getRotationSkewY</a> () const</td></tr>
<tr class="separator:acd3ba7aeb143dbf516bfbdff965ee53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61900edf93cad256bd250f69e02065"><td class="memItemLeft" align="right" valign="top"><a id="aee61900edf93cad256bd250f69e02065"></a>
virtual CC_DEPRECATED_ATTRIBUTE float&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationY</b> () const</td></tr>
<tr class="separator:aee61900edf93cad256bd250f69e02065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb3c79871dc219ae8345fc72c7a00de"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5eb3c79871dc219ae8345fc72c7a00de">setGLServerState</a> (int)</td></tr>
<tr class="separator:a5eb3c79871dc219ae8345fc72c7a00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4817ce95fa64827e8a58645e5b5854ae"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4817ce95fa64827e8a58645e5b5854ae">getGLServerState</a> () const</td></tr>
<tr class="separator:a4817ce95fa64827e8a58645e5b5854ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bedb5e314188f86e32fd986c449b28b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0bedb5e314188f86e32fd986c449b28b">setIgnoreAnchorPointForPosition</a> (bool ignore)</td></tr>
<tr class="separator:a0bedb5e314188f86e32fd986c449b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b28e27b22e7473e902771db3581e4"><td class="memItemLeft" align="right" valign="top"><a id="af57b28e27b22e7473e902771db3581e4"></a>
virtual CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreAnchorPointForPosition</b> (bool ignore)</td></tr>
<tr class="separator:af57b28e27b22e7473e902771db3581e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083fb03ef1904b0b0d4bc12c40a23f5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a083fb03ef1904b0b0d4bc12c40a23f5c">isIgnoreAnchorPointForPosition</a> () const</td></tr>
<tr class="separator:a083fb03ef1904b0b0d4bc12c40a23f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tag &amp; User data</div></td></tr>
<tr class="memitem:a9f18b6db8146f2660e8761bb9557d1fe"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9f18b6db8146f2660e8761bb9557d1fe">getTag</a> () const</td></tr>
<tr class="memdesc:a9f18b6db8146f2660e8761bb9557d1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag getter  <a href="#a9f18b6db8146f2660e8761bb9557d1fe">More...</a><br /></td></tr>
<tr class="separator:a9f18b6db8146f2660e8761bb9557d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ecfc5e9e398e70dfe2e158f926c16f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a41ecfc5e9e398e70dfe2e158f926c16f">setTag</a> (int tag)</td></tr>
<tr class="memdesc:a41ecfc5e9e398e70dfe2e158f926c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag setter  <a href="#a41ecfc5e9e398e70dfe2e158f926c16f">More...</a><br /></td></tr>
<tr class="separator:a41ecfc5e9e398e70dfe2e158f926c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddaa1e6fdada0bec680128d9e732162"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2ddaa1e6fdada0bec680128d9e732162">getName</a> () const</td></tr>
<tr class="separator:a2ddaa1e6fdada0bec680128d9e732162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519730c66b26e65c6539a908e6905edc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a519730c66b26e65c6539a908e6905edc">setName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a519730c66b26e65c6539a908e6905edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeacb9cc8c8730d3ee8359ef42d5318d"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afeacb9cc8c8730d3ee8359ef42d5318d">getUserData</a> ()</td></tr>
<tr class="separator:afeacb9cc8c8730d3ee8359ef42d5318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7eb64c4811677bc4ea83562981caf6"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8f7eb64c4811677bc4ea83562981caf6">getUserData</a> () const</td></tr>
<tr class="separator:a8f7eb64c4811677bc4ea83562981caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f1d7702df679c5d07772bcfd316a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad07f1d7702df679c5d07772bcfd316a2">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:ad07f1d7702df679c5d07772bcfd316a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">userData setter  <a href="#ad07f1d7702df679c5d07772bcfd316a2">More...</a><br /></td></tr>
<tr class="separator:ad07f1d7702df679c5d07772bcfd316a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246218e1f2be9fc931be00c9c42a7817"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a246218e1f2be9fc931be00c9c42a7817">getUserObject</a> ()</td></tr>
<tr class="separator:a246218e1f2be9fc931be00c9c42a7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc05a48edd6e805bbe970fd62a4a48d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6bc05a48edd6e805bbe970fd62a4a48d">getUserObject</a> () const</td></tr>
<tr class="separator:a6bc05a48edd6e805bbe970fd62a4a48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ccf509ea89dcbd94e3b1d383aeda6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa9ccf509ea89dcbd94e3b1d383aeda6f">setUserObject</a> (<a class="el" href="classRef.html">Ref</a> *userObject)</td></tr>
<tr class="separator:aa9ccf509ea89dcbd94e3b1d383aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148c44055cf3d6344326b5bbb3ccd26"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac148c44055cf3d6344326b5bbb3ccd26">getTag</a> () const</td></tr>
<tr class="separator:ac148c44055cf3d6344326b5bbb3ccd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07179e61008c76e7a996636267c74a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad07179e61008c76e7a996636267c74a5">setTag</a> (int tag)</td></tr>
<tr class="separator:ad07179e61008c76e7a996636267c74a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484b1fc5cd08d0b422fc4051b125ea44"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a484b1fc5cd08d0b422fc4051b125ea44">getName</a> () const</td></tr>
<tr class="separator:a484b1fc5cd08d0b422fc4051b125ea44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a7d879835c2d3fbcbcdcd8f415938a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a09a7d879835c2d3fbcbcdcd8f415938a">setName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a09a7d879835c2d3fbcbcdcd8f415938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeacb9cc8c8730d3ee8359ef42d5318d"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afeacb9cc8c8730d3ee8359ef42d5318d">getUserData</a> ()</td></tr>
<tr class="separator:afeacb9cc8c8730d3ee8359ef42d5318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7eb64c4811677bc4ea83562981caf6"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8f7eb64c4811677bc4ea83562981caf6">getUserData</a> () const</td></tr>
<tr class="separator:a8f7eb64c4811677bc4ea83562981caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8dc715df27f90ec04f795495836d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9dd8dc715df27f90ec04f795495836d7">setUserData</a> (void *userData)</td></tr>
<tr class="separator:a9dd8dc715df27f90ec04f795495836d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246218e1f2be9fc931be00c9c42a7817"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a246218e1f2be9fc931be00c9c42a7817">getUserObject</a> ()</td></tr>
<tr class="separator:a246218e1f2be9fc931be00c9c42a7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc05a48edd6e805bbe970fd62a4a48d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6bc05a48edd6e805bbe970fd62a4a48d">getUserObject</a> () const</td></tr>
<tr class="separator:a6bc05a48edd6e805bbe970fd62a4a48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306c369ecb71feb0206b277d9bf81fab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a306c369ecb71feb0206b277d9bf81fab">setUserObject</a> (<a class="el" href="classRef.html">Ref</a> *userObject)</td></tr>
<tr class="separator:a306c369ecb71feb0206b277d9bf81fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">GLProgram</div></td></tr>
<tr class="memitem:aae25dd359a8ddb28d552b14269b69ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aae25dd359a8ddb28d552b14269b69ab5">getGLProgram</a> () const</td></tr>
<tr class="separator:aae25dd359a8ddb28d552b14269b69ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd8c8074ec87881efbc5cf9e8f9efe"><td class="memItemLeft" align="right" valign="top"><a id="aadcd8c8074ec87881efbc5cf9e8f9efe"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getShaderProgram</b> () const</td></tr>
<tr class="separator:aadcd8c8074ec87881efbc5cf9e8f9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ac830f1b38ae931da062c0833b2db0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a16ac830f1b38ae931da062c0833b2db0">setGLProgram</a> (<a class="el" href="classGLProgram.html">GLProgram</a> *glprogram)</td></tr>
<tr class="separator:a16ac830f1b38ae931da062c0833b2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579457920a0b016ad2d5f566d54229c2"><td class="memItemLeft" align="right" valign="top"><a id="a579457920a0b016ad2d5f566d54229c2"></a>
CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setShaderProgram</b> (<a class="el" href="classGLProgram.html">GLProgram</a> *glprogram)</td></tr>
<tr class="separator:a579457920a0b016ad2d5f566d54229c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769007fbb26e8b6ef46096100b57bd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGLProgramState.html">GLProgramState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a769007fbb26e8b6ef46096100b57bd20">getGLProgramState</a> () const</td></tr>
<tr class="separator:a769007fbb26e8b6ef46096100b57bd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe706d4e7b601eee9ccc8eb8ecf90c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3fe706d4e7b601eee9ccc8eb8ecf90c0">setGLProgramState</a> (<a class="el" href="classGLProgramState.html">GLProgramState</a> *glProgramState)</td></tr>
<tr class="separator:a3fe706d4e7b601eee9ccc8eb8ecf90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a091621fe09d1ddc54d2f7789a71d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac5a091621fe09d1ddc54d2f7789a71d8">getGLProgram</a> () const</td></tr>
<tr class="separator:ac5a091621fe09d1ddc54d2f7789a71d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd8c8074ec87881efbc5cf9e8f9efe"><td class="memItemLeft" align="right" valign="top"><a id="aadcd8c8074ec87881efbc5cf9e8f9efe"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getShaderProgram</b> () const</td></tr>
<tr class="separator:aadcd8c8074ec87881efbc5cf9e8f9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa257b40f74bea71ab419f2b8d76f6ba4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa257b40f74bea71ab419f2b8d76f6ba4">setGLProgram</a> (<a class="el" href="classGLProgram.html">GLProgram</a> *glprogram)</td></tr>
<tr class="separator:aa257b40f74bea71ab419f2b8d76f6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579457920a0b016ad2d5f566d54229c2"><td class="memItemLeft" align="right" valign="top"><a id="a579457920a0b016ad2d5f566d54229c2"></a>
CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>setShaderProgram</b> (<a class="el" href="classGLProgram.html">GLProgram</a> *glprogram)</td></tr>
<tr class="separator:a579457920a0b016ad2d5f566d54229c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664a40747cd6cb1410a4521b2dca3bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGLProgramState.html">GLProgramState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a664a40747cd6cb1410a4521b2dca3bdc">getGLProgramState</a> () const</td></tr>
<tr class="separator:a664a40747cd6cb1410a4521b2dca3bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe706d4e7b601eee9ccc8eb8ecf90c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3fe706d4e7b601eee9ccc8eb8ecf90c0">setGLProgramState</a> (<a class="el" href="classGLProgramState.html">GLProgramState</a> *glProgramState)</td></tr>
<tr class="separator:a3fe706d4e7b601eee9ccc8eb8ecf90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Callbacks</div></td></tr>
<tr class="memitem:a7f51764c4afd5018a052b9ef71c03374"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7f51764c4afd5018a052b9ef71c03374">onEnter</a> ()</td></tr>
<tr class="separator:a7f51764c4afd5018a052b9ef71c03374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4b2a863042a9ea456e952cf26991d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afef4b2a863042a9ea456e952cf26991d">onEnterTransitionDidFinish</a> ()</td></tr>
<tr class="separator:afef4b2a863042a9ea456e952cf26991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83de835ea315e3179d4293acd8903ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">onExit</a> ()</td></tr>
<tr class="separator:ac83de835ea315e3179d4293acd8903ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11686054c0d2edd292a53aa9702aaece"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a11686054c0d2edd292a53aa9702aaece">onExitTransitionDidStart</a> ()</td></tr>
<tr class="separator:a11686054c0d2edd292a53aa9702aaece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde49eb69aebd860d7b95bf484cd96f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adde49eb69aebd860d7b95bf484cd96f3">onEnter</a> ()</td></tr>
<tr class="separator:adde49eb69aebd860d7b95bf484cd96f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a941a5ea551c52408a8f3df4a64e6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa3a941a5ea551c52408a8f3df4a64e6f">onEnterTransitionDidFinish</a> ()</td></tr>
<tr class="separator:aa3a941a5ea551c52408a8f3df4a64e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97adc8e1de122017736546f33b01455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae97adc8e1de122017736546f33b01455">onExit</a> ()</td></tr>
<tr class="separator:ae97adc8e1de122017736546f33b01455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2a4fe52123f1e928041a961eb679d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a14c2a4fe52123f1e928041a961eb679d">onExitTransitionDidStart</a> ()</td></tr>
<tr class="separator:a14c2a4fe52123f1e928041a961eb679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Actions</div></td></tr>
<tr class="memitem:a2807ac202214bee721a75c098da54bc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2807ac202214bee721a75c098da54bc6">setActionManager</a> (<a class="el" href="classActionManager.html">ActionManager</a> *actionManager)</td></tr>
<tr class="separator:a2807ac202214bee721a75c098da54bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e089841bc08a8753c65b7bb4f96aac5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4e089841bc08a8753c65b7bb4f96aac5">getActionManager</a> ()</td></tr>
<tr class="separator:a4e089841bc08a8753c65b7bb4f96aac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f453eebf3bf1a7a46ef4369f40ee8f1"><td class="memItemLeft" align="right" valign="top"><a id="a5f453eebf3bf1a7a46ef4369f40ee8f1"></a>
virtual const <a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getActionManager</b> () const</td></tr>
<tr class="separator:a5f453eebf3bf1a7a46ef4369f40ee8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b8c313d5c753c5dbabbe68c77f3128"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAction.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a07b8c313d5c753c5dbabbe68c77f3128">runAction</a> (<a class="el" href="classAction.html">Action</a> *action)</td></tr>
<tr class="separator:a07b8c313d5c753c5dbabbe68c77f3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d542784d864cffe325e9e32d180aa6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1d542784d864cffe325e9e32d180aa6d">stopAllActions</a> ()</td></tr>
<tr class="separator:a1d542784d864cffe325e9e32d180aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f07a11c8550f7be6b6215b56ab69723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7f07a11c8550f7be6b6215b56ab69723">stopAction</a> (<a class="el" href="classAction.html">Action</a> *action)</td></tr>
<tr class="separator:a7f07a11c8550f7be6b6215b56ab69723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58833aec8d21bf1ed647865c220c7c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a58833aec8d21bf1ed647865c220c7c49">stopActionByTag</a> (int tag)</td></tr>
<tr class="separator:a58833aec8d21bf1ed647865c220c7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f8518979a58094c1ed2dbbe7ebcb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a70f8518979a58094c1ed2dbbe7ebcb9f">stopAllActionsByTag</a> (int tag)</td></tr>
<tr class="separator:a70f8518979a58094c1ed2dbbe7ebcb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eef67f2b7d8026328d452e9a5ab09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a36eef67f2b7d8026328d452e9a5ab09c">stopActionsByFlags</a> (unsigned int flags)</td></tr>
<tr class="separator:a36eef67f2b7d8026328d452e9a5ab09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26f8b3ec382080393b96921e3a38ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAction.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad26f8b3ec382080393b96921e3a38ad8">getActionByTag</a> (int tag)</td></tr>
<tr class="separator:ad26f8b3ec382080393b96921e3a38ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576446fef9c35a1a06535eb8949df2f3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a576446fef9c35a1a06535eb8949df2f3">getNumberOfRunningActions</a> () const</td></tr>
<tr class="separator:a576446fef9c35a1a06535eb8949df2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7724086be31eda53304e6c9715f6fd21"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7724086be31eda53304e6c9715f6fd21">numberOfRunningActions</a> () const</td></tr>
<tr class="separator:a7724086be31eda53304e6c9715f6fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8736ca61076cf9e27267c51884890348"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8736ca61076cf9e27267c51884890348">setActionManager</a> (<a class="el" href="classActionManager.html">ActionManager</a> *actionManager)</td></tr>
<tr class="separator:a8736ca61076cf9e27267c51884890348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e089841bc08a8753c65b7bb4f96aac5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4e089841bc08a8753c65b7bb4f96aac5">getActionManager</a> ()</td></tr>
<tr class="separator:a4e089841bc08a8753c65b7bb4f96aac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f453eebf3bf1a7a46ef4369f40ee8f1"><td class="memItemLeft" align="right" valign="top"><a id="a5f453eebf3bf1a7a46ef4369f40ee8f1"></a>
virtual const <a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getActionManager</b> () const</td></tr>
<tr class="separator:a5f453eebf3bf1a7a46ef4369f40ee8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af4b13a5b4a595b94d788aaf1961b30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAction.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7af4b13a5b4a595b94d788aaf1961b30">runAction</a> (<a class="el" href="classAction.html">Action</a> *action)</td></tr>
<tr class="separator:a7af4b13a5b4a595b94d788aaf1961b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d542784d864cffe325e9e32d180aa6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1d542784d864cffe325e9e32d180aa6d">stopAllActions</a> ()</td></tr>
<tr class="separator:a1d542784d864cffe325e9e32d180aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f07a11c8550f7be6b6215b56ab69723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7f07a11c8550f7be6b6215b56ab69723">stopAction</a> (<a class="el" href="classAction.html">Action</a> *action)</td></tr>
<tr class="separator:a7f07a11c8550f7be6b6215b56ab69723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58833aec8d21bf1ed647865c220c7c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a58833aec8d21bf1ed647865c220c7c49">stopActionByTag</a> (int tag)</td></tr>
<tr class="separator:a58833aec8d21bf1ed647865c220c7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f8518979a58094c1ed2dbbe7ebcb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a70f8518979a58094c1ed2dbbe7ebcb9f">stopAllActionsByTag</a> (int tag)</td></tr>
<tr class="separator:a70f8518979a58094c1ed2dbbe7ebcb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eef67f2b7d8026328d452e9a5ab09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a36eef67f2b7d8026328d452e9a5ab09c">stopActionsByFlags</a> (unsigned int flags)</td></tr>
<tr class="separator:a36eef67f2b7d8026328d452e9a5ab09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ada94036cba5f5e2bcc0437369fc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAction.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa4ada94036cba5f5e2bcc0437369fc4a">getActionByTag</a> (int tag)</td></tr>
<tr class="separator:aa4ada94036cba5f5e2bcc0437369fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576446fef9c35a1a06535eb8949df2f3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a576446fef9c35a1a06535eb8949df2f3">getNumberOfRunningActions</a> () const</td></tr>
<tr class="separator:a576446fef9c35a1a06535eb8949df2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f360d4398f3748527a281513364d94"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a79f360d4398f3748527a281513364d94">getNumberOfRunningActionsByTag</a> (int tag) const</td></tr>
<tr class="separator:a79f360d4398f3748527a281513364d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7724086be31eda53304e6c9715f6fd21"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7724086be31eda53304e6c9715f6fd21">numberOfRunningActions</a> () const</td></tr>
<tr class="separator:a7724086be31eda53304e6c9715f6fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scheduler and Timer</div></td></tr>
<tr class="memitem:a9f0c84dfabdce76b5251725944ae7706"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9f0c84dfabdce76b5251725944ae7706">setScheduler</a> (<a class="el" href="classScheduler.html">Scheduler</a> *scheduler)</td></tr>
<tr class="separator:a9f0c84dfabdce76b5251725944ae7706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d438ab0f04dfa3af9a72ae608478264"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5d438ab0f04dfa3af9a72ae608478264">getScheduler</a> ()</td></tr>
<tr class="separator:a5d438ab0f04dfa3af9a72ae608478264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57abd1306ae11bd89f2c38bf7e6a4082"><td class="memItemLeft" align="right" valign="top"><a id="a57abd1306ae11bd89f2c38bf7e6a4082"></a>
virtual const <a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> () const</td></tr>
<tr class="separator:a57abd1306ae11bd89f2c38bf7e6a4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a193072ebab587d1932d8af52050e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab9a193072ebab587d1932d8af52050e0">isScheduled</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="separator:ab9a193072ebab587d1932d8af52050e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335b7157808d2c0a38b4de04382749f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a335b7157808d2c0a38b4de04382749f5">isScheduled</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a335b7157808d2c0a38b4de04382749f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9ae5e15fe4d737da30f2b05f84c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8ff9ae5e15fe4d737da30f2b05f84c1c">scheduleUpdate</a> (void)</td></tr>
<tr class="separator:a8ff9ae5e15fe4d737da30f2b05f84c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86137d5229cb83acf5cee129a83b818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa86137d5229cb83acf5cee129a83b818">scheduleUpdateWithPriority</a> (int priority)</td></tr>
<tr class="separator:aa86137d5229cb83acf5cee129a83b818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4252bff36a5ce566ff66f80f9d38ee"><td class="memItemLeft" align="right" valign="top"><a id="a4f4252bff36a5ce566ff66f80f9d38ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unscheduleUpdate</b> (void)</td></tr>
<tr class="separator:a4f4252bff36a5ce566ff66f80f9d38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5957efe46bfe7f83f9adb5b737f7ce11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule</a> (SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)</td></tr>
<tr class="separator:a5957efe46bfe7f83f9adb5b737f7ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf87e23665a003982321d5e4fc98c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7cf87e23665a003982321d5e4fc98c11">schedule</a> (SEL_SCHEDULE selector, float interval)</td></tr>
<tr class="separator:a7cf87e23665a003982321d5e4fc98c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85353a5e8ae9f374001fa9f89ccc9adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a85353a5e8ae9f374001fa9f89ccc9adb">scheduleOnce</a> (SEL_SCHEDULE selector, float delay)</td></tr>
<tr class="separator:a85353a5e8ae9f374001fa9f89ccc9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733ed19d0f4bbffcab1536b43ce8407d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a733ed19d0f4bbffcab1536b43ce8407d">scheduleOnce</a> (const std::function&lt; void(float)&gt; &amp;callback, float delay, const std::string &amp;key)</td></tr>
<tr class="separator:a733ed19d0f4bbffcab1536b43ce8407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0944b744eb47a227780375597ba997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9f0944b744eb47a227780375597ba997">schedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a9f0944b744eb47a227780375597ba997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30934785a4592d0704ce952e47f69664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a30934785a4592d0704ce952e47f69664">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, const std::string &amp;key)</td></tr>
<tr class="separator:a30934785a4592d0704ce952e47f69664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48adc693c721c34a98357c088f2d97a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac48adc693c721c34a98357c088f2d97a">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, const std::string &amp;key)</td></tr>
<tr class="separator:ac48adc693c721c34a98357c088f2d97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac771b98b6729cc3845fd95cc74c3ae41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac771b98b6729cc3845fd95cc74c3ae41">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, unsigned int repeat, float delay, const std::string &amp;key)</td></tr>
<tr class="separator:ac771b98b6729cc3845fd95cc74c3ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fd599a10f38d31fa0c07bfda6cc90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a04fd599a10f38d31fa0c07bfda6cc90c">unschedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a04fd599a10f38d31fa0c07bfda6cc90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7864aa1e9a8391007eca370628d3ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad7864aa1e9a8391007eca370628d3ce7">unschedule</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad7864aa1e9a8391007eca370628d3ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8711d9b97d8b944a95c4227c7e9869f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab8711d9b97d8b944a95c4227c7e9869f">unscheduleAllCallbacks</a> ()</td></tr>
<tr class="separator:ab8711d9b97d8b944a95c4227c7e9869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bc90abb2fd9e8211abcdb2de9d1f76"><td class="memItemLeft" align="right" valign="top"><a id="a11bc90abb2fd9e8211abcdb2de9d1f76"></a>
CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>unscheduleAllSelectors</b> ()</td></tr>
<tr class="separator:a11bc90abb2fd9e8211abcdb2de9d1f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db2011610576bcba564fcf1f47c2e64"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7db2011610576bcba564fcf1f47c2e64">resume</a> (void)</td></tr>
<tr class="separator:a7db2011610576bcba564fcf1f47c2e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1076a4b9c753597c2c719c27d629d855"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1076a4b9c753597c2c719c27d629d855">pause</a> (void)</td></tr>
<tr class="separator:a1076a4b9c753597c2c719c27d629d855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0904e6d8d94df6c5dddc26c230cf4c"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#add0904e6d8d94df6c5dddc26c230cf4c">resumeSchedulerAndActions</a> ()</td></tr>
<tr class="separator:add0904e6d8d94df6c5dddc26c230cf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda89d75f7614e3b7c3d17788a61813b"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abda89d75f7614e3b7c3d17788a61813b">pauseSchedulerAndActions</a> ()</td></tr>
<tr class="separator:abda89d75f7614e3b7c3d17788a61813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32878481ba54b3856ab53c10af13848e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a32878481ba54b3856ab53c10af13848e">update</a> (float delta)</td></tr>
<tr class="separator:a32878481ba54b3856ab53c10af13848e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d543a8e7750e30ba3d1efe0de336de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a06d543a8e7750e30ba3d1efe0de336de">setScheduler</a> (<a class="el" href="classScheduler.html">Scheduler</a> *scheduler)</td></tr>
<tr class="separator:a06d543a8e7750e30ba3d1efe0de336de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d438ab0f04dfa3af9a72ae608478264"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5d438ab0f04dfa3af9a72ae608478264">getScheduler</a> ()</td></tr>
<tr class="separator:a5d438ab0f04dfa3af9a72ae608478264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57abd1306ae11bd89f2c38bf7e6a4082"><td class="memItemLeft" align="right" valign="top"><a id="a57abd1306ae11bd89f2c38bf7e6a4082"></a>
virtual const <a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> () const</td></tr>
<tr class="separator:a57abd1306ae11bd89f2c38bf7e6a4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c1b3796a8de31f3a9a962261f7c7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9b7c1b3796a8de31f3a9a962261f7c7e">isScheduled</a> (SEL_SCHEDULE selector) const</td></tr>
<tr class="separator:a9b7c1b3796a8de31f3a9a962261f7c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3c2f91272c93216d2122848078e574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4c3c2f91272c93216d2122848078e574">isScheduled</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a4c3c2f91272c93216d2122848078e574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9ae5e15fe4d737da30f2b05f84c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8ff9ae5e15fe4d737da30f2b05f84c1c">scheduleUpdate</a> (void)</td></tr>
<tr class="separator:a8ff9ae5e15fe4d737da30f2b05f84c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86137d5229cb83acf5cee129a83b818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa86137d5229cb83acf5cee129a83b818">scheduleUpdateWithPriority</a> (int priority)</td></tr>
<tr class="separator:aa86137d5229cb83acf5cee129a83b818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4252bff36a5ce566ff66f80f9d38ee"><td class="memItemLeft" align="right" valign="top"><a id="a4f4252bff36a5ce566ff66f80f9d38ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unscheduleUpdate</b> (void)</td></tr>
<tr class="separator:a4f4252bff36a5ce566ff66f80f9d38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5957efe46bfe7f83f9adb5b737f7ce11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule</a> (SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)</td></tr>
<tr class="separator:a5957efe46bfe7f83f9adb5b737f7ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf87e23665a003982321d5e4fc98c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7cf87e23665a003982321d5e4fc98c11">schedule</a> (SEL_SCHEDULE selector, float interval)</td></tr>
<tr class="separator:a7cf87e23665a003982321d5e4fc98c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85353a5e8ae9f374001fa9f89ccc9adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a85353a5e8ae9f374001fa9f89ccc9adb">scheduleOnce</a> (SEL_SCHEDULE selector, float delay)</td></tr>
<tr class="separator:a85353a5e8ae9f374001fa9f89ccc9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733ed19d0f4bbffcab1536b43ce8407d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a733ed19d0f4bbffcab1536b43ce8407d">scheduleOnce</a> (const std::function&lt; void(float)&gt; &amp;callback, float delay, const std::string &amp;key)</td></tr>
<tr class="separator:a733ed19d0f4bbffcab1536b43ce8407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0944b744eb47a227780375597ba997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9f0944b744eb47a227780375597ba997">schedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a9f0944b744eb47a227780375597ba997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30934785a4592d0704ce952e47f69664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a30934785a4592d0704ce952e47f69664">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, const std::string &amp;key)</td></tr>
<tr class="separator:a30934785a4592d0704ce952e47f69664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48adc693c721c34a98357c088f2d97a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac48adc693c721c34a98357c088f2d97a">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, const std::string &amp;key)</td></tr>
<tr class="separator:ac48adc693c721c34a98357c088f2d97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac771b98b6729cc3845fd95cc74c3ae41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac771b98b6729cc3845fd95cc74c3ae41">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, unsigned int repeat, float delay, const std::string &amp;key)</td></tr>
<tr class="separator:ac771b98b6729cc3845fd95cc74c3ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fd599a10f38d31fa0c07bfda6cc90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a04fd599a10f38d31fa0c07bfda6cc90c">unschedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a04fd599a10f38d31fa0c07bfda6cc90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7864aa1e9a8391007eca370628d3ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad7864aa1e9a8391007eca370628d3ce7">unschedule</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad7864aa1e9a8391007eca370628d3ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8711d9b97d8b944a95c4227c7e9869f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab8711d9b97d8b944a95c4227c7e9869f">unscheduleAllCallbacks</a> ()</td></tr>
<tr class="separator:ab8711d9b97d8b944a95c4227c7e9869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bc90abb2fd9e8211abcdb2de9d1f76"><td class="memItemLeft" align="right" valign="top"><a id="a11bc90abb2fd9e8211abcdb2de9d1f76"></a>
CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><b>unscheduleAllSelectors</b> ()</td></tr>
<tr class="separator:a11bc90abb2fd9e8211abcdb2de9d1f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7915bc94d66dd198bc93c5034d454b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab7915bc94d66dd198bc93c5034d454b0">resume</a> (void)</td></tr>
<tr class="separator:ab7915bc94d66dd198bc93c5034d454b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f262913d8d4f3f4ce386752b522208f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2f262913d8d4f3f4ce386752b522208f">pause</a> (void)</td></tr>
<tr class="separator:a2f262913d8d4f3f4ce386752b522208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23454950364265a3da67fb9e8becdd1"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac23454950364265a3da67fb9e8becdd1">resumeSchedulerAndActions</a> ()</td></tr>
<tr class="separator:ac23454950364265a3da67fb9e8becdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff40b01310820986b26dd335ec19670"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7ff40b01310820986b26dd335ec19670">pauseSchedulerAndActions</a> ()</td></tr>
<tr class="separator:a7ff40b01310820986b26dd335ec19670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac907777c1012f808043412c76cf9e183"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac907777c1012f808043412c76cf9e183">update</a> (float delta)</td></tr>
<tr class="separator:ac907777c1012f808043412c76cf9e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformations</div></td></tr>
<tr class="memitem:a8583decfa6069f06ec1e9f8080c1ae36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8583decfa6069f06ec1e9f8080c1ae36">updateTransform</a> ()</td></tr>
<tr class="separator:a8583decfa6069f06ec1e9f8080c1ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7235b4a4d449fb7e01459c5c3b24d1eb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7235b4a4d449fb7e01459c5c3b24d1eb">getNodeToParentTransform</a> () const</td></tr>
<tr class="separator:a7235b4a4d449fb7e01459c5c3b24d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1230b4d08c4705599d6600415d27c10b"><td class="memItemLeft" align="right" valign="top"><a id="a1230b4d08c4705599d6600415d27c10b"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeToParentAffineTransform</b> () const</td></tr>
<tr class="separator:a1230b4d08c4705599d6600415d27c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc9a3bec00628f37f4742378bdcfcca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0cc9a3bec00628f37f4742378bdcfcca">getNodeToParentTransform</a> (<a class="el" href="classNode.html">Node</a> *ancestor) const</td></tr>
<tr class="separator:a0cc9a3bec00628f37f4742378bdcfcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4d15c717622a50adb468ccc7fad2f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a72a4d15c717622a50adb468ccc7fad2f">getNodeToParentAffineTransform</a> (<a class="el" href="classNode.html">Node</a> *ancestor) const</td></tr>
<tr class="separator:a72a4d15c717622a50adb468ccc7fad2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36afac09102cefcdf692f20358add455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a36afac09102cefcdf692f20358add455">setNodeToParentTransform</a> (const <a class="el" href="classMat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a36afac09102cefcdf692f20358add455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab242ac36f0e26f5ef1f89e4a5fa4f02c"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab242ac36f0e26f5ef1f89e4a5fa4f02c">nodeToParentTransform</a> () const</td></tr>
<tr class="separator:ab242ac36f0e26f5ef1f89e4a5fa4f02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aae4242a85aa5acfc03c97a018b621"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a12aae4242a85aa5acfc03c97a018b621">getParentToNodeTransform</a> () const</td></tr>
<tr class="separator:a12aae4242a85aa5acfc03c97a018b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce099e686a648c4ffd96bde8f65293"><td class="memItemLeft" align="right" valign="top"><a id="a48ce099e686a648c4ffd96bde8f65293"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParentToNodeAffineTransform</b> () const</td></tr>
<tr class="separator:a48ce099e686a648c4ffd96bde8f65293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af309d9c24935db52112193619f3cd790"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af309d9c24935db52112193619f3cd790">parentToNodeTransform</a> () const</td></tr>
<tr class="separator:af309d9c24935db52112193619f3cd790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46065101d0d5dba32262067d85bf23"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1e46065101d0d5dba32262067d85bf23">getNodeToWorldTransform</a> () const</td></tr>
<tr class="separator:a1e46065101d0d5dba32262067d85bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480466dcf72739dab9d56e0caf8d0f80"><td class="memItemLeft" align="right" valign="top"><a id="a480466dcf72739dab9d56e0caf8d0f80"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeToWorldAffineTransform</b> () const</td></tr>
<tr class="separator:a480466dcf72739dab9d56e0caf8d0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eeb65a02646d8bbe366c9885893a75"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a26eeb65a02646d8bbe366c9885893a75">nodeToWorldTransform</a> () const</td></tr>
<tr class="separator:a26eeb65a02646d8bbe366c9885893a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41da5111de6d98710d0497e35063989"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab41da5111de6d98710d0497e35063989">getWorldToNodeTransform</a> () const</td></tr>
<tr class="separator:ab41da5111de6d98710d0497e35063989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a7fd5d3162ec1b256bed6f9cba1f48"><td class="memItemLeft" align="right" valign="top"><a id="ac7a7fd5d3162ec1b256bed6f9cba1f48"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getWorldToNodeAffineTransform</b> () const</td></tr>
<tr class="separator:ac7a7fd5d3162ec1b256bed6f9cba1f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b4ad592891ca7ec7ec0bd09341dd1"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0b6b4ad592891ca7ec7ec0bd09341dd1">worldToNodeTransform</a> () const</td></tr>
<tr class="separator:a0b6b4ad592891ca7ec7ec0bd09341dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae570e9d69b67d8f182c076b002fe2d08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae570e9d69b67d8f182c076b002fe2d08">updateTransform</a> ()</td></tr>
<tr class="separator:ae570e9d69b67d8f182c076b002fe2d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58894159c8240ab57a3d62fd6a455c23"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a58894159c8240ab57a3d62fd6a455c23">getNodeToParentTransform</a> () const</td></tr>
<tr class="separator:a58894159c8240ab57a3d62fd6a455c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee35f7b32b5a9058686ce70d596ede66"><td class="memItemLeft" align="right" valign="top"><a id="aee35f7b32b5a9058686ce70d596ede66"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeToParentAffineTransform</b> () const</td></tr>
<tr class="separator:aee35f7b32b5a9058686ce70d596ede66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af403db8a8c516faa4462fd3a87f6eb9a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af403db8a8c516faa4462fd3a87f6eb9a">getNodeToParentTransform</a> (<a class="el" href="classNode.html">Node</a> *ancestor) const</td></tr>
<tr class="separator:af403db8a8c516faa4462fd3a87f6eb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960eb7e75a7c955eba0ba13e51f825ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a960eb7e75a7c955eba0ba13e51f825ea">getNodeToParentAffineTransform</a> (<a class="el" href="classNode.html">Node</a> *ancestor) const</td></tr>
<tr class="separator:a960eb7e75a7c955eba0ba13e51f825ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d96a56bda1b61c829918f771a02a8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a49d96a56bda1b61c829918f771a02a8e">setNodeToParentTransform</a> (const <a class="el" href="classMat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a49d96a56bda1b61c829918f771a02a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab242ac36f0e26f5ef1f89e4a5fa4f02c"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab242ac36f0e26f5ef1f89e4a5fa4f02c">nodeToParentTransform</a> () const</td></tr>
<tr class="separator:ab242ac36f0e26f5ef1f89e4a5fa4f02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079a813e52c5b8a2d4f0c4bd5fa90a91"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a079a813e52c5b8a2d4f0c4bd5fa90a91">getParentToNodeTransform</a> () const</td></tr>
<tr class="separator:a079a813e52c5b8a2d4f0c4bd5fa90a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7689ecef478afa3ddad8bc311ed345fd"><td class="memItemLeft" align="right" valign="top"><a id="a7689ecef478afa3ddad8bc311ed345fd"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParentToNodeAffineTransform</b> () const</td></tr>
<tr class="separator:a7689ecef478afa3ddad8bc311ed345fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af309d9c24935db52112193619f3cd790"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af309d9c24935db52112193619f3cd790">parentToNodeTransform</a> () const</td></tr>
<tr class="separator:af309d9c24935db52112193619f3cd790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cede05ce1912aea7903ce17dbebd86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae2cede05ce1912aea7903ce17dbebd86">getNodeToWorldTransform</a> () const</td></tr>
<tr class="separator:ae2cede05ce1912aea7903ce17dbebd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9208691f25a357a4dfe739cc54d8e5c"><td class="memItemLeft" align="right" valign="top"><a id="af9208691f25a357a4dfe739cc54d8e5c"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeToWorldAffineTransform</b> () const</td></tr>
<tr class="separator:af9208691f25a357a4dfe739cc54d8e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eeb65a02646d8bbe366c9885893a75"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a26eeb65a02646d8bbe366c9885893a75">nodeToWorldTransform</a> () const</td></tr>
<tr class="separator:a26eeb65a02646d8bbe366c9885893a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2128a1876b3f14c6270bbf0a9010a572"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2128a1876b3f14c6270bbf0a9010a572">getWorldToNodeTransform</a> () const</td></tr>
<tr class="separator:a2128a1876b3f14c6270bbf0a9010a572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531808b4dd0d7d1052935246585f8bb4"><td class="memItemLeft" align="right" valign="top"><a id="a531808b4dd0d7d1052935246585f8bb4"></a>
virtual <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getWorldToNodeAffineTransform</b> () const</td></tr>
<tr class="separator:a531808b4dd0d7d1052935246585f8bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b4ad592891ca7ec7ec0bd09341dd1"><td class="memItemLeft" align="right" valign="top">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0b6b4ad592891ca7ec7ec0bd09341dd1">worldToNodeTransform</a> () const</td></tr>
<tr class="separator:a0b6b4ad592891ca7ec7ec0bd09341dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Coordinate Converters</div></td></tr>
<tr class="memitem:ae7bffc192b6e9b24871108d472a0e85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae7bffc192b6e9b24871108d472a0e85a">convertToNodeSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="separator:ae7bffc192b6e9b24871108d472a0e85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da42e3d980d42aa9508a9de1b51040b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9da42e3d980d42aa9508a9de1b51040b">convertToWorldSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="separator:a9da42e3d980d42aa9508a9de1b51040b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e573a38882cc0727c5f8f65cd9187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9c7e573a38882cc0727c5f8f65cd9187">convertToNodeSpaceAR</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="separator:a9c7e573a38882cc0727c5f8f65cd9187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c532f970a06aec83dc881e70526b8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a84c532f970a06aec83dc881e70526b8e">convertToWorldSpaceAR</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="separator:a84c532f970a06aec83dc881e70526b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff92b98917dbaea150b90b578a84fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6ff92b98917dbaea150b90b578a84fca">convertTouchToNodeSpace</a> (<a class="el" href="classTouch.html">Touch</a> *touch) const</td></tr>
<tr class="separator:a6ff92b98917dbaea150b90b578a84fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a987bf0d6590367c254e78426773af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af9a987bf0d6590367c254e78426773af">convertTouchToNodeSpaceAR</a> (<a class="el" href="classTouch.html">Touch</a> *touch) const</td></tr>
<tr class="separator:af9a987bf0d6590367c254e78426773af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7375e0112b9bf3e5ace5afb32a5cd044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7375e0112b9bf3e5ace5afb32a5cd044">setAdditionalTransform</a> (const <a class="el" href="classMat4.html">Mat4</a> *additionalTransform)</td></tr>
<tr class="separator:a7375e0112b9bf3e5ace5afb32a5cd044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f377b57a7924d17caa0d012306feb09"><td class="memItemLeft" align="right" valign="top"><a id="a1f377b57a7924d17caa0d012306feb09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAdditionalTransform</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;additionalTransform)</td></tr>
<tr class="separator:a1f377b57a7924d17caa0d012306feb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7758edc645887a1f811ef9d680df64a"><td class="memItemLeft" align="right" valign="top"><a id="ab7758edc645887a1f811ef9d680df64a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAdditionalTransform</b> (const <a class="el" href="structAffineTransform.html">AffineTransform</a> &amp;additionalTransform)</td></tr>
<tr class="separator:ab7758edc645887a1f811ef9d680df64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bffc192b6e9b24871108d472a0e85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae7bffc192b6e9b24871108d472a0e85a">convertToNodeSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="separator:ae7bffc192b6e9b24871108d472a0e85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da42e3d980d42aa9508a9de1b51040b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9da42e3d980d42aa9508a9de1b51040b">convertToWorldSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="separator:a9da42e3d980d42aa9508a9de1b51040b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e573a38882cc0727c5f8f65cd9187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9c7e573a38882cc0727c5f8f65cd9187">convertToNodeSpaceAR</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="separator:a9c7e573a38882cc0727c5f8f65cd9187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c532f970a06aec83dc881e70526b8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a84c532f970a06aec83dc881e70526b8e">convertToWorldSpaceAR</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="separator:a84c532f970a06aec83dc881e70526b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff92b98917dbaea150b90b578a84fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6ff92b98917dbaea150b90b578a84fca">convertTouchToNodeSpace</a> (<a class="el" href="classTouch.html">Touch</a> *touch) const</td></tr>
<tr class="separator:a6ff92b98917dbaea150b90b578a84fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a987bf0d6590367c254e78426773af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af9a987bf0d6590367c254e78426773af">convertTouchToNodeSpaceAR</a> (<a class="el" href="classTouch.html">Touch</a> *touch) const</td></tr>
<tr class="separator:af9a987bf0d6590367c254e78426773af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7375e0112b9bf3e5ace5afb32a5cd044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7375e0112b9bf3e5ace5afb32a5cd044">setAdditionalTransform</a> (const <a class="el" href="classMat4.html">Mat4</a> *additionalTransform)</td></tr>
<tr class="separator:a7375e0112b9bf3e5ace5afb32a5cd044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f377b57a7924d17caa0d012306feb09"><td class="memItemLeft" align="right" valign="top"><a id="a1f377b57a7924d17caa0d012306feb09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAdditionalTransform</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;additionalTransform)</td></tr>
<tr class="separator:a1f377b57a7924d17caa0d012306feb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7758edc645887a1f811ef9d680df64a"><td class="memItemLeft" align="right" valign="top"><a id="ab7758edc645887a1f811ef9d680df64a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAdditionalTransform</b> (const <a class="el" href="structAffineTransform.html">AffineTransform</a> &amp;additionalTransform)</td></tr>
<tr class="separator:ab7758edc645887a1f811ef9d680df64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">component functions</div></td></tr>
<tr class="memitem:a149c99ff0cb7285f5e51d331672adbb9"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a149c99ff0cb7285f5e51d331672adbb9">getComponent</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a149c99ff0cb7285f5e51d331672adbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f2b77fdfde809abc13432ce526e706"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af5f2b77fdfde809abc13432ce526e706">addComponent</a> (Component *component)</td></tr>
<tr class="separator:af5f2b77fdfde809abc13432ce526e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5160468bfd35be6804b8cf7a88142"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acce5160468bfd35be6804b8cf7a88142">removeComponent</a> (const std::string &amp;name)</td></tr>
<tr class="separator:acce5160468bfd35be6804b8cf7a88142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857bce3dc69f84d4746fbbb8ab2ea720"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a857bce3dc69f84d4746fbbb8ab2ea720">removeComponent</a> (Component *component)</td></tr>
<tr class="separator:a857bce3dc69f84d4746fbbb8ab2ea720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5d3cf6a590df570cac7ddbfe85c9d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6c5d3cf6a590df570cac7ddbfe85c9d3">removeAllComponents</a> ()</td></tr>
<tr class="separator:a6c5d3cf6a590df570cac7ddbfe85c9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867ee7521172ead4346cb755e9dbaca"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2867ee7521172ead4346cb755e9dbaca">getComponent</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a2867ee7521172ead4346cb755e9dbaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19037b621c89b205fdb3ad620b1f8d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1c19037b621c89b205fdb3ad620b1f8d">addComponent</a> (Component *component)</td></tr>
<tr class="separator:a1c19037b621c89b205fdb3ad620b1f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79887a0cfaa3705f0478c14044f93eea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a79887a0cfaa3705f0478c14044f93eea">removeComponent</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a79887a0cfaa3705f0478c14044f93eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ccb90f2206b1d9b8ccf7b96a361f5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4b9ccb90f2206b1d9b8ccf7b96a361f5">removeComponent</a> (Component *component)</td></tr>
<tr class="separator:a4b9ccb90f2206b1d9b8ccf7b96a361f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b776f7b64fc5d0fd32280eabf5c3a71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4b776f7b64fc5d0fd32280eabf5c3a71">removeAllComponents</a> ()</td></tr>
<tr class="separator:a4b776f7b64fc5d0fd32280eabf5c3a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a065f6972ebb82de3e2143cbf10a7ac2d">autorelease</a> ()</td></tr>
<tr class="separator:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a1c3c3986014151251b39041e2556d2e3">~Ref</a> ()</td></tr>
<tr class="separator:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a544b29e4e4b0c7fb32ccb6bf92d28da9">autorelease</a> ()</td></tr>
<tr class="separator:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a97a445f43f3935f3ee6f34ebdec55d12">~Ref</a> ()</td></tr>
<tr class="separator:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aac63bb9c7ce8fe00a3317e7d29fb40de"><td class="memItemLeft" align="right" valign="top"><a id="aac63bb9c7ce8fe00a3317e7d29fb40de"></a>
<a class="el" href="_2cocos2d_2cocos_2base_2ccConfig_8h.html#a25ef1314f97c35a2ed3d029b0ead6da0">CC_CONSTRUCTOR_ACCESS</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__pad0__</b>: <a class="el" href="classNode.html">Node</a>()</td></tr>
<tr class="separator:aac63bb9c7ce8fe00a3317e7d29fb40de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa8e6bb26098082b3d5bd5b6ba89e48c8"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa8e6bb26098082b3d5bd5b6ba89e48c8">INVALID_TAG</a> = -1</td></tr>
<tr class="separator:aa8e6bb26098082b3d5bd5b6ba89e48c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="memItemLeft" align="right" valign="top"><a id="a6aeb29ea076a2a5cf6fc40ec7b4348ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6aeb29ea076a2a5cf6fc40ec7b4348ca">childrenAlloc</a> (void)</td></tr>
<tr class="memdesc:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazy allocs <br /></td></tr>
<tr class="separator:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb54cf6025e99d8ac7f86c4549781fff"><td class="memItemLeft" align="right" valign="top"><a id="aeb54cf6025e99d8ac7f86c4549781fff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aeb54cf6025e99d8ac7f86c4549781fff">insertChild</a> (<a class="el" href="classNode.html">Node</a> *child, int z)</td></tr>
<tr class="memdesc:aeb54cf6025e99d8ac7f86c4549781fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper that reorder a child <br /></td></tr>
<tr class="separator:aeb54cf6025e99d8ac7f86c4549781fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28508e2bfd951d040c84f26bc5ca8a15"><td class="memItemLeft" align="right" valign="top"><a id="a28508e2bfd951d040c84f26bc5ca8a15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a28508e2bfd951d040c84f26bc5ca8a15">detachChild</a> (<a class="el" href="classNode.html">Node</a> *child, ssize_t index, bool doCleanup)</td></tr>
<tr class="memdesc:a28508e2bfd951d040c84f26bc5ca8a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child, call child-&gt;<a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">onExit()</a>, do cleanup, remove it from children array. <br /></td></tr>
<tr class="separator:a28508e2bfd951d040c84f26bc5ca8a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="memItemLeft" align="right" valign="top"><a id="a5714faff2a8e1c11d0c1063bbebb7e8e"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5714faff2a8e1c11d0c1063bbebb7e8e">convertToWindowSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="memdesc:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cocos2d coordinates to UI windows coordinate. <br /></td></tr>
<tr class="separator:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c42b42f83093c1c2eec1c85db42da3"><td class="memItemLeft" align="right" valign="top"><a id="ac2c42b42f83093c1c2eec1c85db42da3"></a>
<a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transform</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform)</td></tr>
<tr class="separator:ac2c42b42f83093c1c2eec1c85db42da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafbbfd4c342d5b49900279af703fd6a"><td class="memItemLeft" align="right" valign="top"><a id="adafbbfd4c342d5b49900279af703fd6a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>processParentFlags</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform, uint32_t parentFlags)</td></tr>
<tr class="separator:adafbbfd4c342d5b49900279af703fd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605f03a838df163865754fd5563ef4e"><td class="memItemLeft" align="right" valign="top"><a id="a9605f03a838df163865754fd5563ef4e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCascadeOpacity</b> ()</td></tr>
<tr class="separator:a9605f03a838df163865754fd5563ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd230a088bf8617f176d8ba5d5d342"><td class="memItemLeft" align="right" valign="top"><a id="a0ebd230a088bf8617f176d8ba5d5d342"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableCascadeOpacity</b> ()</td></tr>
<tr class="separator:a0ebd230a088bf8617f176d8ba5d5d342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73c6c7509327024e982f1441b9c1be3"><td class="memItemLeft" align="right" valign="top"><a id="af73c6c7509327024e982f1441b9c1be3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCascadeColor</b> ()</td></tr>
<tr class="separator:af73c6c7509327024e982f1441b9c1be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e70cde53de8a61e9843e7ca9f245f1"><td class="memItemLeft" align="right" valign="top"><a id="a81e70cde53de8a61e9843e7ca9f245f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableCascadeColor</b> ()</td></tr>
<tr class="separator:a81e70cde53de8a61e9843e7ca9f245f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2704ff7c772030d210ffe5d7efce75a2"><td class="memItemLeft" align="right" valign="top"><a id="a2704ff7c772030d210ffe5d7efce75a2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateColor</b> ()</td></tr>
<tr class="separator:a2704ff7c772030d210ffe5d7efce75a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc25589657cd89b6790ee1df8db05e48"><td class="memItemLeft" align="right" valign="top"><a id="abc25589657cd89b6790ee1df8db05e48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doEnumerate</b> (std::string name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *)&gt; callback) const</td></tr>
<tr class="separator:abc25589657cd89b6790ee1df8db05e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02e31227d3de70ff6b1b58ebf25d39a"><td class="memItemLeft" align="right" valign="top"><a id="ab02e31227d3de70ff6b1b58ebf25d39a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doEnumerateRecursive</b> (const <a class="el" href="classNode.html">Node</a> *node, const std::string &amp;name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *)&gt; callback) const</td></tr>
<tr class="separator:ab02e31227d3de70ff6b1b58ebf25d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777c670caf6e0369cc07bd6ffd26292"><td class="memItemLeft" align="right" valign="top"><a id="ac777c670caf6e0369cc07bd6ffd26292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isVisitableByVisitingCamera</b> () const</td></tr>
<tr class="separator:ac777c670caf6e0369cc07bd6ffd26292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca86193f13f3d6c1772630b30e995681"><td class="memItemLeft" align="right" valign="top"><a id="aca86193f13f3d6c1772630b30e995681"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRotationQuat</b> ()</td></tr>
<tr class="separator:aca86193f13f3d6c1772630b30e995681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6837d39880dd37abab5ac55c1b0801f3"><td class="memItemLeft" align="right" valign="top"><a id="a6837d39880dd37abab5ac55c1b0801f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRotation3D</b> ()</td></tr>
<tr class="separator:a6837d39880dd37abab5ac55c1b0801f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="memItemLeft" align="right" valign="top"><a id="a6aeb29ea076a2a5cf6fc40ec7b4348ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6aeb29ea076a2a5cf6fc40ec7b4348ca">childrenAlloc</a> (void)</td></tr>
<tr class="memdesc:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">lazy allocs <br /></td></tr>
<tr class="separator:a6aeb29ea076a2a5cf6fc40ec7b4348ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb54cf6025e99d8ac7f86c4549781fff"><td class="memItemLeft" align="right" valign="top"><a id="aeb54cf6025e99d8ac7f86c4549781fff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aeb54cf6025e99d8ac7f86c4549781fff">insertChild</a> (<a class="el" href="classNode.html">Node</a> *child, int z)</td></tr>
<tr class="memdesc:aeb54cf6025e99d8ac7f86c4549781fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper that reorder a child <br /></td></tr>
<tr class="separator:aeb54cf6025e99d8ac7f86c4549781fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28508e2bfd951d040c84f26bc5ca8a15"><td class="memItemLeft" align="right" valign="top"><a id="a28508e2bfd951d040c84f26bc5ca8a15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a28508e2bfd951d040c84f26bc5ca8a15">detachChild</a> (<a class="el" href="classNode.html">Node</a> *child, ssize_t index, bool doCleanup)</td></tr>
<tr class="memdesc:a28508e2bfd951d040c84f26bc5ca8a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child, call child-&gt;<a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">onExit()</a>, do cleanup, remove it from children array. <br /></td></tr>
<tr class="separator:a28508e2bfd951d040c84f26bc5ca8a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="memItemLeft" align="right" valign="top"><a id="a5714faff2a8e1c11d0c1063bbebb7e8e"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5714faff2a8e1c11d0c1063bbebb7e8e">convertToWindowSpace</a> (const <a class="el" href="classVec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="memdesc:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cocos2d coordinates to UI windows coordinate. <br /></td></tr>
<tr class="separator:a5714faff2a8e1c11d0c1063bbebb7e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c42b42f83093c1c2eec1c85db42da3"><td class="memItemLeft" align="right" valign="top"><a id="ac2c42b42f83093c1c2eec1c85db42da3"></a>
<a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>transform</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform)</td></tr>
<tr class="separator:ac2c42b42f83093c1c2eec1c85db42da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafbbfd4c342d5b49900279af703fd6a"><td class="memItemLeft" align="right" valign="top"><a id="adafbbfd4c342d5b49900279af703fd6a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>processParentFlags</b> (const <a class="el" href="classMat4.html">Mat4</a> &amp;parentTransform, uint32_t parentFlags)</td></tr>
<tr class="separator:adafbbfd4c342d5b49900279af703fd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a76d0ee2dc2db818d7324d36f1c73a"><td class="memItemLeft" align="right" valign="top"><a id="a56a76d0ee2dc2db818d7324d36f1c73a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCascadeOpacity</b> ()</td></tr>
<tr class="separator:a56a76d0ee2dc2db818d7324d36f1c73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf30953d1ec835bdf97f3664e898b34e"><td class="memItemLeft" align="right" valign="top"><a id="aaf30953d1ec835bdf97f3664e898b34e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableCascadeOpacity</b> ()</td></tr>
<tr class="separator:aaf30953d1ec835bdf97f3664e898b34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25760a40efdb967a826441b8b2661c3c"><td class="memItemLeft" align="right" valign="top"><a id="a25760a40efdb967a826441b8b2661c3c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCascadeColor</b> ()</td></tr>
<tr class="separator:a25760a40efdb967a826441b8b2661c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8d91cf7ef028fd3766783f1eae3fd"><td class="memItemLeft" align="right" valign="top"><a id="ae0b8d91cf7ef028fd3766783f1eae3fd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableCascadeColor</b> ()</td></tr>
<tr class="separator:ae0b8d91cf7ef028fd3766783f1eae3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2704ff7c772030d210ffe5d7efce75a2"><td class="memItemLeft" align="right" valign="top"><a id="a2704ff7c772030d210ffe5d7efce75a2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateColor</b> ()</td></tr>
<tr class="separator:a2704ff7c772030d210ffe5d7efce75a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc25589657cd89b6790ee1df8db05e48"><td class="memItemLeft" align="right" valign="top"><a id="abc25589657cd89b6790ee1df8db05e48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doEnumerate</b> (std::string name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *)&gt; callback) const</td></tr>
<tr class="separator:abc25589657cd89b6790ee1df8db05e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02e31227d3de70ff6b1b58ebf25d39a"><td class="memItemLeft" align="right" valign="top"><a id="ab02e31227d3de70ff6b1b58ebf25d39a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doEnumerateRecursive</b> (const <a class="el" href="classNode.html">Node</a> *node, const std::string &amp;name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *)&gt; callback) const</td></tr>
<tr class="separator:ab02e31227d3de70ff6b1b58ebf25d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777c670caf6e0369cc07bd6ffd26292"><td class="memItemLeft" align="right" valign="top"><a id="ac777c670caf6e0369cc07bd6ffd26292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isVisitableByVisitingCamera</b> () const</td></tr>
<tr class="separator:ac777c670caf6e0369cc07bd6ffd26292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca86193f13f3d6c1772630b30e995681"><td class="memItemLeft" align="right" valign="top"><a id="aca86193f13f3d6c1772630b30e995681"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRotationQuat</b> ()</td></tr>
<tr class="separator:aca86193f13f3d6c1772630b30e995681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6837d39880dd37abab5ac55c1b0801f3"><td class="memItemLeft" align="right" valign="top"><a id="a6837d39880dd37abab5ac55c1b0801f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRotation3D</b> ()</td></tr>
<tr class="separator:a6837d39880dd37abab5ac55c1b0801f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab9cf238c39cc7fc6ffde82c8d94c465e">Ref</a> ()</td></tr>
<tr class="separator:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a63f1608b3c105a76e3d0ff1b77d2ae8e">Ref</a> ()</td></tr>
<tr class="separator:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adfee8eadd0d490ec504b93e7a20056fc"><td class="memItemLeft" align="right" valign="top"><a id="adfee8eadd0d490ec504b93e7a20056fc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adfee8eadd0d490ec504b93e7a20056fc">_rotationX</a></td></tr>
<tr class="memdesc:adfee8eadd0d490ec504b93e7a20056fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation on the X-axis <br /></td></tr>
<tr class="separator:adfee8eadd0d490ec504b93e7a20056fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ed90f49ad52ebc93a3c7aaa36d209"><td class="memItemLeft" align="right" valign="top"><a id="a196ed90f49ad52ebc93a3c7aaa36d209"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a196ed90f49ad52ebc93a3c7aaa36d209">_rotationY</a></td></tr>
<tr class="memdesc:a196ed90f49ad52ebc93a3c7aaa36d209"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation on the Y-axis <br /></td></tr>
<tr class="separator:a196ed90f49ad52ebc93a3c7aaa36d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32f8a9a49a41f2869cb9be336651dee"><td class="memItemLeft" align="right" valign="top"><a id="aa32f8a9a49a41f2869cb9be336651dee"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa32f8a9a49a41f2869cb9be336651dee">_rotationZ_X</a></td></tr>
<tr class="memdesc:aa32f8a9a49a41f2869cb9be336651dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation angle on Z-axis, component X <br /></td></tr>
<tr class="separator:aa32f8a9a49a41f2869cb9be336651dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f697d7ec4bb08eb2608a1441918c64"><td class="memItemLeft" align="right" valign="top"><a id="a56f697d7ec4bb08eb2608a1441918c64"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a56f697d7ec4bb08eb2608a1441918c64">_rotationZ_Y</a></td></tr>
<tr class="memdesc:a56f697d7ec4bb08eb2608a1441918c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation angle on Z-axis, component Y <br /></td></tr>
<tr class="separator:a56f697d7ec4bb08eb2608a1441918c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63558967572c6ac2fd197b15e7015c9b"><td class="memItemLeft" align="right" valign="top"><a id="a63558967572c6ac2fd197b15e7015c9b"></a>
<a class="el" href="classQuaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_rotationQuat</b></td></tr>
<tr class="separator:a63558967572c6ac2fd197b15e7015c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297aabd4789b5bdb3ddff6034691edb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad297aabd4789b5bdb3ddff6034691edb">_scaleX</a></td></tr>
<tr class="memdesc:ad297aabd4789b5bdb3ddff6034691edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotation using quaternion, if _rotationZ_X == _rotationZ_Y, _rotationQuat = RotationZ_X * RotationY * RotationX, else _rotationQuat = RotationY * RotationX  <a href="#ad297aabd4789b5bdb3ddff6034691edb">More...</a><br /></td></tr>
<tr class="separator:ad297aabd4789b5bdb3ddff6034691edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7996e5290ee0cf1e4ba4e427144c4832"><td class="memItemLeft" align="right" valign="top"><a id="a7996e5290ee0cf1e4ba4e427144c4832"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7996e5290ee0cf1e4ba4e427144c4832">_scaleY</a></td></tr>
<tr class="memdesc:a7996e5290ee0cf1e4ba4e427144c4832"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaling factor on y-axis <br /></td></tr>
<tr class="separator:a7996e5290ee0cf1e4ba4e427144c4832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8067ae8bab452356194c68c680af0"><td class="memItemLeft" align="right" valign="top"><a id="a52f8067ae8bab452356194c68c680af0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a52f8067ae8bab452356194c68c680af0">_scaleZ</a></td></tr>
<tr class="memdesc:a52f8067ae8bab452356194c68c680af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">scaling factor on z-axis <br /></td></tr>
<tr class="separator:a52f8067ae8bab452356194c68c680af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3dff369c98537eeeab4c0bcbf3a69f"><td class="memItemLeft" align="right" valign="top"><a id="a3b3dff369c98537eeeab4c0bcbf3a69f"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3b3dff369c98537eeeab4c0bcbf3a69f">_position</a></td></tr>
<tr class="memdesc:a3b3dff369c98537eeeab4c0bcbf3a69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of the node <br /></td></tr>
<tr class="separator:a3b3dff369c98537eeeab4c0bcbf3a69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362654a7f9a70f2ccaf68934d3000fa5"><td class="memItemLeft" align="right" valign="top"><a id="a362654a7f9a70f2ccaf68934d3000fa5"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a362654a7f9a70f2ccaf68934d3000fa5">_positionZ</a></td></tr>
<tr class="memdesc:a362654a7f9a70f2ccaf68934d3000fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL real Z position. <br /></td></tr>
<tr class="separator:a362654a7f9a70f2ccaf68934d3000fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb5a92303d79bc8a9147c46f363ef28"><td class="memItemLeft" align="right" valign="top"><a id="a0cb5a92303d79bc8a9147c46f363ef28"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_normalizedPosition</b></td></tr>
<tr class="separator:a0cb5a92303d79bc8a9147c46f363ef28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fde0edd4afa1ad63ab47ffd05b8f4f"><td class="memItemLeft" align="right" valign="top"><a id="ad9fde0edd4afa1ad63ab47ffd05b8f4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_usingNormalizedPosition</b></td></tr>
<tr class="separator:ad9fde0edd4afa1ad63ab47ffd05b8f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b14cb27650511f74aed00fde0de0e0"><td class="memItemLeft" align="right" valign="top"><a id="a01b14cb27650511f74aed00fde0de0e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_normalizedPositionDirty</b></td></tr>
<tr class="separator:a01b14cb27650511f74aed00fde0de0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4725c588669f1af7240553cb1d433bdf"><td class="memItemLeft" align="right" valign="top"><a id="a4725c588669f1af7240553cb1d433bdf"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4725c588669f1af7240553cb1d433bdf">_skewX</a></td></tr>
<tr class="memdesc:a4725c588669f1af7240553cb1d433bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">skew angle on x-axis <br /></td></tr>
<tr class="separator:a4725c588669f1af7240553cb1d433bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc29d1e7bbb1914c2ff15b176399466"><td class="memItemLeft" align="right" valign="top"><a id="afcc29d1e7bbb1914c2ff15b176399466"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afcc29d1e7bbb1914c2ff15b176399466">_skewY</a></td></tr>
<tr class="memdesc:afcc29d1e7bbb1914c2ff15b176399466"><td class="mdescLeft">&#160;</td><td class="mdescRight">skew angle on y-axis <br /></td></tr>
<tr class="separator:afcc29d1e7bbb1914c2ff15b176399466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285aa9f824bf09f78751354c220402c"><td class="memItemLeft" align="right" valign="top"><a id="a1285aa9f824bf09f78751354c220402c"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1285aa9f824bf09f78751354c220402c">_anchorPointInPoints</a></td></tr>
<tr class="memdesc:a1285aa9f824bf09f78751354c220402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">anchor point in points <br /></td></tr>
<tr class="separator:a1285aa9f824bf09f78751354c220402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366d7e4a0b945e889aef0f28b537c33b"><td class="memItemLeft" align="right" valign="top"><a id="a366d7e4a0b945e889aef0f28b537c33b"></a>
<a class="el" href="classVec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a366d7e4a0b945e889aef0f28b537c33b">_anchorPoint</a></td></tr>
<tr class="memdesc:a366d7e4a0b945e889aef0f28b537c33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">anchor point normalized (NOT in points) <br /></td></tr>
<tr class="separator:a366d7e4a0b945e889aef0f28b537c33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0e905f7ab31c19cc5667ceb1411932"><td class="memItemLeft" align="right" valign="top"><a id="add0e905f7ab31c19cc5667ceb1411932"></a>
<a class="el" href="classSize.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#add0e905f7ab31c19cc5667ceb1411932">_contentSize</a></td></tr>
<tr class="memdesc:add0e905f7ab31c19cc5667ceb1411932"><td class="mdescLeft">&#160;</td><td class="mdescRight">untransformed size of the node <br /></td></tr>
<tr class="separator:add0e905f7ab31c19cc5667ceb1411932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f08d72282e6d4c0fae24e0cab56042"><td class="memItemLeft" align="right" valign="top"><a id="a11f08d72282e6d4c0fae24e0cab56042"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a11f08d72282e6d4c0fae24e0cab56042">_contentSizeDirty</a></td></tr>
<tr class="memdesc:a11f08d72282e6d4c0fae24e0cab56042"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether or not the contentSize is dirty <br /></td></tr>
<tr class="separator:a11f08d72282e6d4c0fae24e0cab56042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9eff249dd6cb82abd433f5cc54da6c"><td class="memItemLeft" align="right" valign="top"><a id="a5a9eff249dd6cb82abd433f5cc54da6c"></a>
<a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5a9eff249dd6cb82abd433f5cc54da6c">_modelViewTransform</a></td></tr>
<tr class="memdesc:a5a9eff249dd6cb82abd433f5cc54da6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModelView transform of the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>. <br /></td></tr>
<tr class="separator:a5a9eff249dd6cb82abd433f5cc54da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6686337fb93c284391bce7441e46db"><td class="memItemLeft" align="right" valign="top"><a id="a5a6686337fb93c284391bce7441e46db"></a>
<a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5a6686337fb93c284391bce7441e46db">_transform</a></td></tr>
<tr class="memdesc:a5a6686337fb93c284391bce7441e46db"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform <br /></td></tr>
<tr class="separator:a5a6686337fb93c284391bce7441e46db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05b246884e68da5bade2d3914d0f89"><td class="memItemLeft" align="right" valign="top"><a id="afc05b246884e68da5bade2d3914d0f89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afc05b246884e68da5bade2d3914d0f89">_transformDirty</a></td></tr>
<tr class="memdesc:afc05b246884e68da5bade2d3914d0f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform dirty flag <br /></td></tr>
<tr class="separator:afc05b246884e68da5bade2d3914d0f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9481aec57ff12d607c8526c16d0b19b7"><td class="memItemLeft" align="right" valign="top"><a id="a9481aec57ff12d607c8526c16d0b19b7"></a>
<a class="el" href="classMat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9481aec57ff12d607c8526c16d0b19b7">_inverse</a></td></tr>
<tr class="memdesc:a9481aec57ff12d607c8526c16d0b19b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse transform <br /></td></tr>
<tr class="separator:a9481aec57ff12d607c8526c16d0b19b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a4a23138837fc8be24e1ba1044b6e7"><td class="memItemLeft" align="right" valign="top"><a id="a44a4a23138837fc8be24e1ba1044b6e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a44a4a23138837fc8be24e1ba1044b6e7">_inverseDirty</a></td></tr>
<tr class="memdesc:a44a4a23138837fc8be24e1ba1044b6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse transform dirty flag <br /></td></tr>
<tr class="separator:a44a4a23138837fc8be24e1ba1044b6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed06ce02d4241dc88abcef2d55d8b831"><td class="memItemLeft" align="right" valign="top"><a id="aed06ce02d4241dc88abcef2d55d8b831"></a>
<a class="el" href="classMat4.html">Mat4</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aed06ce02d4241dc88abcef2d55d8b831">_additionalTransform</a></td></tr>
<tr class="memdesc:aed06ce02d4241dc88abcef2d55d8b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">two transforms needed by additional transforms <br /></td></tr>
<tr class="separator:aed06ce02d4241dc88abcef2d55d8b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fac06291e49b4bec15a14032b9e6a5"><td class="memItemLeft" align="right" valign="top"><a id="a55fac06291e49b4bec15a14032b9e6a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a55fac06291e49b4bec15a14032b9e6a5">_additionalTransformDirty</a></td></tr>
<tr class="memdesc:a55fac06291e49b4bec15a14032b9e6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform dirty ? <br /></td></tr>
<tr class="separator:a55fac06291e49b4bec15a14032b9e6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af6bdab7557f0e7df90d74d7c217997"><td class="memItemLeft" align="right" valign="top"><a id="a0af6bdab7557f0e7df90d74d7c217997"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0af6bdab7557f0e7df90d74d7c217997">_transformUpdated</a></td></tr>
<tr class="memdesc:a0af6bdab7557f0e7df90d74d7c217997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the Transform object was updated since the last frame. <br /></td></tr>
<tr class="separator:a0af6bdab7557f0e7df90d74d7c217997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4140ffa6469a9940e8fdf5e8170ebba7"><td class="memItemLeft" align="right" valign="top"><a id="a4140ffa6469a9940e8fdf5e8170ebba7"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>_localZOrderAndArrival</b></td></tr>
<tr class="separator:a4140ffa6469a9940e8fdf5e8170ebba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2322ede4846f7dec8e8202587985a9"><td class="memItemLeft" align="right" valign="top"><a id="acd2322ede4846f7dec8e8202587985a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acd2322ede4846f7dec8e8202587985a9">_localZOrder</a></td></tr>
<tr class="memdesc:acd2322ede4846f7dec8e8202587985a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">cache, for 64bits compress optimize. <br /></td></tr>
<tr class="separator:acd2322ede4846f7dec8e8202587985a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c37d773103afb51bd5ca06bdb42b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada8c37d773103afb51bd5ca06bdb42b2">_globalZOrder</a></td></tr>
<tr class="memdesc:ada8c37d773103afb51bd5ca06bdb42b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Local order (relative to its siblings) used to sort the node  <a href="#ada8c37d773103afb51bd5ca06bdb42b2">More...</a><br /></td></tr>
<tr class="separator:ada8c37d773103afb51bd5ca06bdb42b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04befb78cbf7f5fd3a8d6d18425d21b3"><td class="memItemLeft" align="right" valign="top"><a id="a04befb78cbf7f5fd3a8d6d18425d21b3"></a>
<a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classNode.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a04befb78cbf7f5fd3a8d6d18425d21b3">_children</a></td></tr>
<tr class="memdesc:a04befb78cbf7f5fd3a8d6d18425d21b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of children nodes <br /></td></tr>
<tr class="separator:a04befb78cbf7f5fd3a8d6d18425d21b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296e261174980bbffee33e800a855e1"><td class="memItemLeft" align="right" valign="top"><a id="af296e261174980bbffee33e800a855e1"></a>
<a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af296e261174980bbffee33e800a855e1">_parent</a></td></tr>
<tr class="memdesc:af296e261174980bbffee33e800a855e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">weak reference to parent node <br /></td></tr>
<tr class="separator:af296e261174980bbffee33e800a855e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4095a3cc52148ba910b8efc3c1c8171a"><td class="memItemLeft" align="right" valign="top"><a id="a4095a3cc52148ba910b8efc3c1c8171a"></a>
<a class="el" href="classDirector.html">Director</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_director</b></td></tr>
<tr class="separator:a4095a3cc52148ba910b8efc3c1c8171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d50f1ccf5904957fb7134c81bcbe0a9"><td class="memItemLeft" align="right" valign="top"><a id="a7d50f1ccf5904957fb7134c81bcbe0a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7d50f1ccf5904957fb7134c81bcbe0a9">_tag</a></td></tr>
<tr class="memdesc:a7d50f1ccf5904957fb7134c81bcbe0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a tag. Can be any number you assigned just to identify this node <br /></td></tr>
<tr class="separator:a7d50f1ccf5904957fb7134c81bcbe0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb92ed8ca02f47ffa4dfe83500b7fd0"><td class="memItemLeft" align="right" valign="top"><a id="a7fb92ed8ca02f47ffa4dfe83500b7fd0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7fb92ed8ca02f47ffa4dfe83500b7fd0">_name</a></td></tr>
<tr class="memdesc:a7fb92ed8ca02f47ffa4dfe83500b7fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a string label, an user defined string to identify this node <br /></td></tr>
<tr class="separator:a7fb92ed8ca02f47ffa4dfe83500b7fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634113fb2c6c57021375ae27cff2984"><td class="memItemLeft" align="right" valign="top"><a id="a3634113fb2c6c57021375ae27cff2984"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3634113fb2c6c57021375ae27cff2984">_hashOfName</a></td></tr>
<tr class="memdesc:a3634113fb2c6c57021375ae27cff2984"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash value of _name, used for speed in getChildByName <br /></td></tr>
<tr class="separator:a3634113fb2c6c57021375ae27cff2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c10dd02609cdea8a3cc6861f10b381"><td class="memItemLeft" align="right" valign="top"><a id="ae9c10dd02609cdea8a3cc6861f10b381"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae9c10dd02609cdea8a3cc6861f10b381">_userData</a></td></tr>
<tr class="memdesc:ae9c10dd02609cdea8a3cc6861f10b381"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user assigned void pointer, Can be point to any cpp object. <br /></td></tr>
<tr class="separator:ae9c10dd02609cdea8a3cc6861f10b381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c483cd6aa6c7f516b332a27c8ddffbb"><td class="memItemLeft" align="right" valign="top"><a id="a0c483cd6aa6c7f516b332a27c8ddffbb"></a>
<a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0c483cd6aa6c7f516b332a27c8ddffbb">_userObject</a></td></tr>
<tr class="memdesc:a0c483cd6aa6c7f516b332a27c8ddffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user assigned Object. <br /></td></tr>
<tr class="separator:a0c483cd6aa6c7f516b332a27c8ddffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b58bb6b1a8d3eaafe27bc57c120a57"><td class="memItemLeft" align="right" valign="top"><a id="ab0b58bb6b1a8d3eaafe27bc57c120a57"></a>
<a class="el" href="classGLProgramState.html">GLProgramState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab0b58bb6b1a8d3eaafe27bc57c120a57">_glProgramState</a></td></tr>
<tr class="memdesc:ab0b58bb6b1a8d3eaafe27bc57c120a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL Program State. <br /></td></tr>
<tr class="separator:ab0b58bb6b1a8d3eaafe27bc57c120a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa43ad094d6b9bac26e9f0ab387f846"><td class="memItemLeft" align="right" valign="top"><a id="a8fa43ad094d6b9bac26e9f0ab387f846"></a>
<a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8fa43ad094d6b9bac26e9f0ab387f846">_scheduler</a></td></tr>
<tr class="memdesc:a8fa43ad094d6b9bac26e9f0ab387f846"><td class="mdescLeft">&#160;</td><td class="mdescRight">scheduler used to schedule timers and updates <br /></td></tr>
<tr class="separator:a8fa43ad094d6b9bac26e9f0ab387f846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98e86f00584d2c23a0e11dad4b0a1f"><td class="memItemLeft" align="right" valign="top"><a id="aee98e86f00584d2c23a0e11dad4b0a1f"></a>
<a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aee98e86f00584d2c23a0e11dad4b0a1f">_actionManager</a></td></tr>
<tr class="memdesc:aee98e86f00584d2c23a0e11dad4b0a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> singleton, which is used to handle all the actions <br /></td></tr>
<tr class="separator:aee98e86f00584d2c23a0e11dad4b0a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03fa4ef9f5bd148b264676865215fe"><td class="memItemLeft" align="right" valign="top"><a id="aff03fa4ef9f5bd148b264676865215fe"></a>
<a class="el" href="classEventDispatcher.html">EventDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aff03fa4ef9f5bd148b264676865215fe">_eventDispatcher</a></td></tr>
<tr class="memdesc:aff03fa4ef9f5bd148b264676865215fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">event dispatcher used to dispatch all kinds of events <br /></td></tr>
<tr class="separator:aff03fa4ef9f5bd148b264676865215fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26daeae52daea23a70c899c5361fff2"><td class="memItemLeft" align="right" valign="top"><a id="aa26daeae52daea23a70c899c5361fff2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa26daeae52daea23a70c899c5361fff2">_running</a></td></tr>
<tr class="memdesc:aa26daeae52daea23a70c899c5361fff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">is running <br /></td></tr>
<tr class="separator:aa26daeae52daea23a70c899c5361fff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fcead06157af8c4e6d4ca59596e52c"><td class="memItemLeft" align="right" valign="top"><a id="a39fcead06157af8c4e6d4ca59596e52c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a39fcead06157af8c4e6d4ca59596e52c">_visible</a></td></tr>
<tr class="memdesc:a39fcead06157af8c4e6d4ca59596e52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">is this node visible <br /></td></tr>
<tr class="separator:a39fcead06157af8c4e6d4ca59596e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef122b1552bec154a2a8923641b4e0f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aef122b1552bec154a2a8923641b4e0f2">_ignoreAnchorPointForPosition</a></td></tr>
<tr class="memdesc:aef122b1552bec154a2a8923641b4e0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>.  <a href="#aef122b1552bec154a2a8923641b4e0f2">More...</a><br /></td></tr>
<tr class="separator:aef122b1552bec154a2a8923641b4e0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1246c0fc5cf2f9afcc82a4af90a143ba"><td class="memItemLeft" align="right" valign="top"><a id="a1246c0fc5cf2f9afcc82a4af90a143ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1246c0fc5cf2f9afcc82a4af90a143ba">_reorderChildDirty</a></td></tr>
<tr class="memdesc:a1246c0fc5cf2f9afcc82a4af90a143ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">children order dirty flag <br /></td></tr>
<tr class="separator:a1246c0fc5cf2f9afcc82a4af90a143ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1c7e6bc6a34a3364c9c741428622ff"><td class="memItemLeft" align="right" valign="top"><a id="aec1c7e6bc6a34a3364c9c741428622ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aec1c7e6bc6a34a3364c9c741428622ff">_isTransitionFinished</a></td></tr>
<tr class="memdesc:aec1c7e6bc6a34a3364c9c741428622ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate whether the transition was finished <br /></td></tr>
<tr class="separator:aec1c7e6bc6a34a3364c9c741428622ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd5a831c6a09e65e09a00855fe4676d"><td class="memItemLeft" align="right" valign="top"><a id="aedd5a831c6a09e65e09a00855fe4676d"></a>
ComponentContainer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aedd5a831c6a09e65e09a00855fe4676d">_componentContainer</a></td></tr>
<tr class="memdesc:aedd5a831c6a09e65e09a00855fe4676d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary of components. <br /></td></tr>
<tr class="separator:aedd5a831c6a09e65e09a00855fe4676d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e03f00645d5bcb839db8deaa4d85a"><td class="memItemLeft" align="right" valign="top"><a id="a669e03f00645d5bcb839db8deaa4d85a"></a>
GLubyte&#160;</td><td class="memItemRight" valign="bottom"><b>_displayedOpacity</b></td></tr>
<tr class="separator:a669e03f00645d5bcb839db8deaa4d85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee88e0376dada82903f9d76b4416e37"><td class="memItemLeft" align="right" valign="top"><a id="a8ee88e0376dada82903f9d76b4416e37"></a>
GLubyte&#160;</td><td class="memItemRight" valign="bottom"><b>_realOpacity</b></td></tr>
<tr class="separator:a8ee88e0376dada82903f9d76b4416e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a6642e280ea92d89ea31154b5148e"><td class="memItemLeft" align="right" valign="top"><a id="ac70a6642e280ea92d89ea31154b5148e"></a>
<a class="el" href="structColor3B.html">Color3B</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_displayedColor</b></td></tr>
<tr class="separator:ac70a6642e280ea92d89ea31154b5148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac937ea0e801b0643b73da4c7149ec75d"><td class="memItemLeft" align="right" valign="top"><a id="ac937ea0e801b0643b73da4c7149ec75d"></a>
<a class="el" href="structColor3B.html">Color3B</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_realColor</b></td></tr>
<tr class="separator:ac937ea0e801b0643b73da4c7149ec75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e154f9f1e136347363e2fdd05a14664"><td class="memItemLeft" align="right" valign="top"><a id="a2e154f9f1e136347363e2fdd05a14664"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_cascadeColorEnabled</b></td></tr>
<tr class="separator:a2e154f9f1e136347363e2fdd05a14664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa793e94b08d5d5ad565ddd63057bf9e7"><td class="memItemLeft" align="right" valign="top"><a id="aa793e94b08d5d5ad565ddd63057bf9e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_cascadeOpacityEnabled</b></td></tr>
<tr class="separator:aa793e94b08d5d5ad565ddd63057bf9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad031cdf7519c89ff16e8f5891a79710c"><td class="memItemLeft" align="right" valign="top"><a id="ad031cdf7519c89ff16e8f5891a79710c"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>_cameraMask</b></td></tr>
<tr class="separator:ad031cdf7519c89ff16e8f5891a79710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f477a7efd99e164623e7b3161051ba"><td class="memItemLeft" align="right" valign="top"><a id="a83f477a7efd99e164623e7b3161051ba"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_onEnterCallback</b></td></tr>
<tr class="separator:a83f477a7efd99e164623e7b3161051ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccbce0c6022f6244c4ac0dfb2b1d1fd"><td class="memItemLeft" align="right" valign="top"><a id="a9ccbce0c6022f6244c4ac0dfb2b1d1fd"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_onExitCallback</b></td></tr>
<tr class="separator:a9ccbce0c6022f6244c4ac0dfb2b1d1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aff1ceba5b9a02bfdc73d60a19090e6"><td class="memItemLeft" align="right" valign="top"><a id="a5aff1ceba5b9a02bfdc73d60a19090e6"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_onEnterTransitionDidFinishCallback</b></td></tr>
<tr class="separator:a5aff1ceba5b9a02bfdc73d60a19090e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d331be7013cc0b9ecd7c11d712bdad3"><td class="memItemLeft" align="right" valign="top"><a id="a1d331be7013cc0b9ecd7c11d712bdad3"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_onExitTransitionDidStartCallback</b></td></tr>
<tr class="separator:a1d331be7013cc0b9ecd7c11d712bdad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96786af79481c33d1def62869d62eeee"><td class="memItemLeft" ><a id="a96786af79481c33d1def62869d62eeee"></a>
union {</td></tr>
<tr class="memitem:ae24af93084da1038b3e85d6231b597e3"><td class="memItemLeft" ><a id="ae24af93084da1038b3e85d6231b597e3"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:ad1d70648efa7edede36f838379bebf5a"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;std::int32_t&#160;&#160;&#160;<b>_localZOrder</b></td></tr>
<tr class="separator:ad1d70648efa7edede36f838379bebf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c297c889fc04e60f30e562a2606ed19"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;std::uint32_t&#160;&#160;&#160;<b>_orderOfArrival</b></td></tr>
<tr class="separator:a3c297c889fc04e60f30e562a2606ed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24af93084da1038b3e85d6231b597e3"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ae24af93084da1038b3e85d6231b597e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33531840e1441e06a9a0df1d15386a5a"><td class="memItemLeft" >
&#160;&#160;&#160;std::int64_t <a class="el" href="classNode.html#acd2322ede4846f7dec8e8202587985a9">_localZOrder</a>&#160;&#160;&#160;<b>$Arrival</b></td></tr>
<tr class="separator:a33531840e1441e06a9a0df1d15386a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96786af79481c33d1def62869d62eeee"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a96786af79481c33d1def62869d62eeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memItemLeft" align="right" valign="top"><a id="ab05a4c4ef09ecbaffc7c7c7f57d34bf6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab05a4c4ef09ecbaffc7c7c7f57d34bf6">_referenceCount</a></td></tr>
<tr class="memdesc:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">count of references <br /></td></tr>
<tr class="separator:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a54da5479d291fb34d32b1d798c8ae2f0"><td class="memItemLeft" align="right" valign="top"><a id="a54da5479d291fb34d32b1d798c8ae2f0"></a>
static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>s_globalOrderOfArrival</b> = 0</td></tr>
<tr class="separator:a54da5479d291fb34d32b1d798c8ae2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd1ce583f0948ca665e96e6bcf00f11"><td class="memItemLeft" align="right" valign="top"><a id="aafd1ce583f0948ca665e96e6bcf00f11"></a>
static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_globalOrderOfArrival</b></td></tr>
<tr class="separator:aafd1ce583f0948ca665e96e6bcf00f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572e900f3b0a5c388a293d35590fa339"><td class="memItemLeft" align="right" valign="top"><a id="a572e900f3b0a5c388a293d35590fa339"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>__attachedNodeCount</b> = 0</td></tr>
<tr class="separator:a572e900f3b0a5c388a293d35590fa339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructor, Destructor and Initializers</h2></td></tr>
<tr class="memitem:aa9a92a1756b585d707a42c3fd1b274d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa9a92a1756b585d707a42c3fd1b274d4">create</a> ()</td></tr>
<tr class="separator:aa9a92a1756b585d707a42c3fd1b274d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e23ac4cd34aafe7a332b09d8a9de368"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8e23ac4cd34aafe7a332b09d8a9de368">create</a> ()</td></tr>
<tr class="separator:a8e23ac4cd34aafe7a332b09d8a9de368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e964e787155dc3fcb2ff47ec7f75eb3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8e964e787155dc3fcb2ff47ec7f75eb3">getAttachedNodeCount</a> ()</td></tr>
<tr class="separator:a8e964e787155dc3fcb2ff47ec7f75eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41710375a0d92a4ee54c39fe123b5912"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a41710375a0d92a4ee54c39fe123b5912">getDescription</a> () const</td></tr>
<tr class="separator:a41710375a0d92a4ee54c39fe123b5912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54b2b6449d20d852bd3c9f775bb556"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8a54b2b6449d20d852bd3c9f775bb556">getDescription</a> () const</td></tr>
<tr class="separator:a8a54b2b6449d20d852bd3c9f775bb556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Children and Parent</h2></td></tr>
<tr class="memitem:a17a2149cbfe0819a11f3e109cc67645c"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:a17a2149cbfe0819a11f3e109cc67645c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#a17a2149cbfe0819a11f3e109cc67645c">sortNodes</a> (cocos2d::Vector&lt; _T *&gt; &amp;nodes)</td></tr>
<tr class="separator:a17a2149cbfe0819a11f3e109cc67645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a2149cbfe0819a11f3e109cc67645c"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:a17a2149cbfe0819a11f3e109cc67645c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#a17a2149cbfe0819a11f3e109cc67645c">sortNodes</a> (cocos2d::Vector&lt; _T *&gt; &amp;nodes)</td></tr>
<tr class="separator:a17a2149cbfe0819a11f3e109cc67645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132699398b350e83b548a5645e69beb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a132699398b350e83b548a5645e69beb0">addChild</a> (<a class="el" href="classNode.html">Node</a> *child)</td></tr>
<tr class="separator:a132699398b350e83b548a5645e69beb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0005bbb94623abd997ce7c3116e6212"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad0005bbb94623abd997ce7c3116e6212">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder)</td></tr>
<tr class="separator:ad0005bbb94623abd997ce7c3116e6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29dab4b296e96c5072545cf9bd94b90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac29dab4b296e96c5072545cf9bd94b90">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder, int tag)</td></tr>
<tr class="separator:ac29dab4b296e96c5072545cf9bd94b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed32867e81e7902c8155dca7d347a18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abed32867e81e7902c8155dca7d347a18">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder, const std::string &amp;name)</td></tr>
<tr class="separator:abed32867e81e7902c8155dca7d347a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eebd018aa7ebebb674d1649e1a79cac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8eebd018aa7ebebb674d1649e1a79cac">getChildByTag</a> (int tag) const</td></tr>
<tr class="separator:a8eebd018aa7ebebb674d1649e1a79cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e82df91d1c2df7d55e5b1b319012b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a093e82df91d1c2df7d55e5b1b319012b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#a093e82df91d1c2df7d55e5b1b319012b">getChildByTag</a> (int tag) const</td></tr>
<tr class="separator:a093e82df91d1c2df7d55e5b1b319012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f84f995c7d6581787abaa3b09c4518"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac2f84f995c7d6581787abaa3b09c4518">getChildByName</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ac2f84f995c7d6581787abaa3b09c4518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#abbd6d0f2c3d65db94ea75d16402f83a2">getChildByName</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f69bdf4cd0b241dc12935536f3dbe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a> (const std::string &amp;name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *node)&gt; callback) const</td></tr>
<tr class="separator:ada6f69bdf4cd0b241dc12935536f3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25943a94b19e37929b18f93647b58153"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classNode.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a25943a94b19e37929b18f93647b58153">getChildren</a> ()</td></tr>
<tr class="separator:a25943a94b19e37929b18f93647b58153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8104d257021771119ffeb4c171bb3"><td class="memItemLeft" align="right" valign="top"><a id="aedc8104d257021771119ffeb4c171bb3"></a>
virtual const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classNode.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getChildren</b> () const</td></tr>
<tr class="separator:aedc8104d257021771119ffeb4c171bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0559adacadcb3a367c8cf7ba65730e"><td class="memItemLeft" align="right" valign="top">virtual ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abe0559adacadcb3a367c8cf7ba65730e">getChildrenCount</a> () const</td></tr>
<tr class="separator:abe0559adacadcb3a367c8cf7ba65730e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f0786bcb59591c528efb0b776797fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab5f0786bcb59591c528efb0b776797fc">setParent</a> (<a class="el" href="classNode.html">Node</a> *parent)</td></tr>
<tr class="memdesc:ab5f0786bcb59591c528efb0b776797fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">parent setter  <a href="#ab5f0786bcb59591c528efb0b776797fc">More...</a><br /></td></tr>
<tr class="separator:ab5f0786bcb59591c528efb0b776797fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c8a4ae726c6dd984db05c89454652d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af4c8a4ae726c6dd984db05c89454652d">getParent</a> ()</td></tr>
<tr class="separator:af4c8a4ae726c6dd984db05c89454652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fd4c36007f3da331591de601dfa377"><td class="memItemLeft" align="right" valign="top"><a id="a76fd4c36007f3da331591de601dfa377"></a>
virtual const <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParent</b> () const</td></tr>
<tr class="separator:a76fd4c36007f3da331591de601dfa377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f717b3bf15017bae1a070a121b0289"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a26f717b3bf15017bae1a070a121b0289">removeFromParent</a> ()</td></tr>
<tr class="separator:a26f717b3bf15017bae1a070a121b0289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ee70d65cb9675b64dc447d821a91e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad0ee70d65cb9675b64dc447d821a91e5">removeFromParentAndCleanup</a> (bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>)</td></tr>
<tr class="separator:ad0ee70d65cb9675b64dc447d821a91e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d4a7d389b26b0c6ad7ed99c8b1b65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a872d4a7d389b26b0c6ad7ed99c8b1b65">removeChild</a> (<a class="el" href="classNode.html">Node</a> *child, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:a872d4a7d389b26b0c6ad7ed99c8b1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e53ef64e2252d07304429889278864"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae2e53ef64e2252d07304429889278864">removeChildByTag</a> (int tag, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:ae2e53ef64e2252d07304429889278864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91086b878367386bd070789f2ea7c8a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a91086b878367386bd070789f2ea7c8a8">removeChildByName</a> (const std::string &amp;name, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:a91086b878367386bd070789f2ea7c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ef5518d2e5dd5be405e98b37ace4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0f6ef5518d2e5dd5be405e98b37ace4a">removeAllChildren</a> ()</td></tr>
<tr class="separator:a0f6ef5518d2e5dd5be405e98b37ace4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66e2b385c3dbf1a6f55627c4a13192"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aca66e2b385c3dbf1a6f55627c4a13192">removeAllChildrenWithCleanup</a> (bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>)</td></tr>
<tr class="separator:aca66e2b385c3dbf1a6f55627c4a13192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9bc72e7f53c1e7f0ef6bc87c07a08f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5c9bc72e7f53c1e7f0ef6bc87c07a08f">reorderChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder)</td></tr>
<tr class="separator:a5c9bc72e7f53c1e7f0ef6bc87c07a08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaeea03013d3eae710c4d4d725bce0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adfaeea03013d3eae710c4d4d725bce0b">sortAllChildren</a> ()</td></tr>
<tr class="separator:adfaeea03013d3eae710c4d4d725bce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e5ddb38e23ee7763d623f2d943b004"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa3e5ddb38e23ee7763d623f2d943b004">addChild</a> (<a class="el" href="classNode.html">Node</a> *child)</td></tr>
<tr class="separator:aa3e5ddb38e23ee7763d623f2d943b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc01f017ee724751b48ec3c6fd60df3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4fc01f017ee724751b48ec3c6fd60df3">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder)</td></tr>
<tr class="separator:a4fc01f017ee724751b48ec3c6fd60df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d30a9e718c1c12adf739cb1554c2ff7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6d30a9e718c1c12adf739cb1554c2ff7">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder, int tag)</td></tr>
<tr class="separator:a6d30a9e718c1c12adf739cb1554c2ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96fa155c63a5dc57e3fc89d5488c036"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae96fa155c63a5dc57e3fc89d5488c036">addChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder, const std::string &amp;name)</td></tr>
<tr class="separator:ae96fa155c63a5dc57e3fc89d5488c036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fa47ea7ec6663e4cfe0580da7131f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac2fa47ea7ec6663e4cfe0580da7131f5">getChildByTag</a> (int tag) const</td></tr>
<tr class="separator:ac2fa47ea7ec6663e4cfe0580da7131f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e82df91d1c2df7d55e5b1b319012b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a093e82df91d1c2df7d55e5b1b319012b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#a093e82df91d1c2df7d55e5b1b319012b">getChildByTag</a> (int tag) const</td></tr>
<tr class="separator:a093e82df91d1c2df7d55e5b1b319012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00de78a02fd2112123857bbe053e163"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af00de78a02fd2112123857bbe053e163">getChildByName</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:af00de78a02fd2112123857bbe053e163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classNode.html#abbd6d0f2c3d65db94ea75d16402f83a2">getChildByName</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:abbd6d0f2c3d65db94ea75d16402f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f69bdf4cd0b241dc12935536f3dbe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a> (const std::string &amp;name, std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *node)&gt; callback) const</td></tr>
<tr class="separator:ada6f69bdf4cd0b241dc12935536f3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25943a94b19e37929b18f93647b58153"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classNode.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a25943a94b19e37929b18f93647b58153">getChildren</a> ()</td></tr>
<tr class="separator:a25943a94b19e37929b18f93647b58153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8104d257021771119ffeb4c171bb3"><td class="memItemLeft" align="right" valign="top"><a id="aedc8104d257021771119ffeb4c171bb3"></a>
virtual const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classNode.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getChildren</b> () const</td></tr>
<tr class="separator:aedc8104d257021771119ffeb4c171bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0db7fcb1347684d462a873944b534"><td class="memItemLeft" align="right" valign="top">virtual ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2ae0db7fcb1347684d462a873944b534">getChildrenCount</a> () const</td></tr>
<tr class="separator:a2ae0db7fcb1347684d462a873944b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d4495d7ca6de96a2ce4dbc63514022"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac4d4495d7ca6de96a2ce4dbc63514022">setParent</a> (<a class="el" href="classNode.html">Node</a> *parent)</td></tr>
<tr class="separator:ac4d4495d7ca6de96a2ce4dbc63514022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c8a4ae726c6dd984db05c89454652d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af4c8a4ae726c6dd984db05c89454652d">getParent</a> ()</td></tr>
<tr class="separator:af4c8a4ae726c6dd984db05c89454652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fd4c36007f3da331591de601dfa377"><td class="memItemLeft" align="right" valign="top"><a id="a76fd4c36007f3da331591de601dfa377"></a>
virtual const <a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParent</b> () const</td></tr>
<tr class="separator:a76fd4c36007f3da331591de601dfa377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2cf07d3723b1394d8943e24a785704"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9a2cf07d3723b1394d8943e24a785704">removeFromParent</a> ()</td></tr>
<tr class="separator:a9a2cf07d3723b1394d8943e24a785704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d0fe060ea35fba5eee6fe2fba5f42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab22d0fe060ea35fba5eee6fe2fba5f42">removeFromParentAndCleanup</a> (bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>)</td></tr>
<tr class="separator:ab22d0fe060ea35fba5eee6fe2fba5f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e85ab2de9e93e3998a40df1b4b61fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae2e85ab2de9e93e3998a40df1b4b61fc">removeChild</a> (<a class="el" href="classNode.html">Node</a> *child, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:ae2e85ab2de9e93e3998a40df1b4b61fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2e9aae23d04f4355eadd5d38bc6200"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7d2e9aae23d04f4355eadd5d38bc6200">removeChildByTag</a> (int tag, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:a7d2e9aae23d04f4355eadd5d38bc6200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e99fad1cb0a446e9d2bfeefd8b115f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a70e99fad1cb0a446e9d2bfeefd8b115f">removeChildByName</a> (const std::string &amp;name, bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>=true)</td></tr>
<tr class="separator:a70e99fad1cb0a446e9d2bfeefd8b115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4018ec946225eb3bc64a0bbd19cd4625"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4018ec946225eb3bc64a0bbd19cd4625">removeAllChildren</a> ()</td></tr>
<tr class="separator:a4018ec946225eb3bc64a0bbd19cd4625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e179356e2ffbff60f02149b35edacc1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0e179356e2ffbff60f02149b35edacc1">removeAllChildrenWithCleanup</a> (bool <a class="el" href="classNode.html#aa2de84c6cdeec9cd647d236c30ee0567">cleanup</a>)</td></tr>
<tr class="separator:a0e179356e2ffbff60f02149b35edacc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfa613acd0eba2e67ae8274e8114ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3bbfa613acd0eba2e67ae8274e8114ee">reorderChild</a> (<a class="el" href="classNode.html">Node</a> *child, int localZOrder)</td></tr>
<tr class="separator:a3bbfa613acd0eba2e67ae8274e8114ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5911e98e2230b164daf283f707e1748d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5911e98e2230b164daf283f707e1748d">sortAllChildren</a> ()</td></tr>
<tr class="separator:a5911e98e2230b164daf283f707e1748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> is the base element of the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph. Elements of the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph must be <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> objects or subclasses of it. The most common <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> objects are: <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>, <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a>, <a class="el" href="classSprite.html">Sprite</a>, <a class="el" href="classMenu.html" title="A Menu for touch handling. ">Menu</a>, <a class="el" href="classLabel.html" title="Label is a subclass of Node that knows how to render text labels. ">Label</a>. </p>
<p>The main features of a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> are:</p><ul>
<li>They can contain other <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> objects (<code>addChild</code>, <code>getChildByTag</code>, <code>removeChild</code>, etc)</li>
<li>They can schedule periodic callback (<code>schedule</code>, <code>unschedule</code>, etc)</li>
<li>They can execute actions (<code>runAction</code>, <code>stopAction</code>, etc)</li>
</ul>
<p>Subclassing a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> usually means (one/all) of:</p><ul>
<li>overriding init to initialize resources and schedule callbacks</li>
<li>create callbacks to handle the advancement of time</li>
<li>overriding <code>draw</code> to render the node</li>
</ul>
<p><a class="el" href="classProperties.html">Properties</a> of <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>:</p><ul>
<li>position (default: x=0, y=0)</li>
<li>scale (default: x=1, y=1)</li>
<li>rotation (in degrees, clockwise) (default: 0)</li>
<li>anchor point (default: x=0, y=0)</li>
<li>contentSize (default: width=0, height=0)</li>
<li>visible (default: true)</li>
</ul>
<p>Limitations:</p><ul>
<li>A <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> is a "void" object. If you want to draw something on the screen, you should use a <a class="el" href="classSprite.html">Sprite</a> instead. Or subclass <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> and override <code>draw</code>. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9228657d144a272e8ac471c5a9b9e0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9228657d144a272e8ac471c5a9b9e0dc">&#9670;&nbsp;</a></span>_setLocalZOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::_setLocalZOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>zOrder setter : private method used internally to alter the zOrder variable. DON'T call this method manually </p>

</div>
</div>
<a id="ae0ab4e6bbde6dad91266f8fde8e25b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab4e6bbde6dad91266f8fde8e25b77">&#9670;&nbsp;</a></span>_setLocalZOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::_setLocalZOrder </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>zOrder setter : private method used internally to alter the zOrder variable. DON'T call this method manually </p>

</div>
</div>
<a id="a132699398b350e83b548a5645e69beb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132699398b350e83b548a5645e69beb0">&#9670;&nbsp;</a></span>addChild() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z-order as 0.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a33a556579ca4e24b016a787af18cfcae">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#ae08449caf813144448cc3841b1a6dfee">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a5d22ede0db71db1d5b597207f1c2013e">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a6cdee934880e71245c6f5e6a2789c48a">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a7fb7f42f3f3ee9e9ca8ee3bb959e2c32">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#aeee2116f21f0e89de5a2e1b9cc93e012">ui::ListView</a>, <a class="el" href="classMenu.html#af957ef275f6fe75ee78876cbbea924e8">Menu</a>, and <a class="el" href="classMenu.html#af557403e8b14bdbda70d85b7d12fedfb">Menu</a>.</p>

</div>
</div>
<a id="ad0005bbb94623abd997ce7c3116e6212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0005bbb94623abd997ce7c3116e6212">&#9670;&nbsp;</a></span>addChild() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with a local z-order.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#acfd1b4932c3926cf777ef00235c3386b">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#aa9947ec25c709fa839fdec1795ae2a2c">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a0ba6f93abe0d74d31d08147339952e19">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a42849e8b7b80ca0bcee880f40de9eccd">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#afb7109d348b36c0d672066589ef1e00b">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a36ef7247ab78ee7019eca8c409a30356">ui::ListView</a>, <a class="el" href="classMenu.html#a196fa8d0852b67ab63f7d3937c9b7d1c">Menu</a>, and <a class="el" href="classMenu.html#a38455f79cd083475d9beacf0cc9caf81">Menu</a>.</p>

</div>
</div>
<a id="aa3e5ddb38e23ee7763d623f2d943b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e5ddb38e23ee7763d623f2d943b004">&#9670;&nbsp;</a></span>addChild() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z-order as 0.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a33a556579ca4e24b016a787af18cfcae">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#ae08449caf813144448cc3841b1a6dfee">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a5d22ede0db71db1d5b597207f1c2013e">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a6cdee934880e71245c6f5e6a2789c48a">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a7fb7f42f3f3ee9e9ca8ee3bb959e2c32">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#aeee2116f21f0e89de5a2e1b9cc93e012">ui::ListView</a>, <a class="el" href="classMenu.html#af957ef275f6fe75ee78876cbbea924e8">Menu</a>, and <a class="el" href="classMenu.html#af557403e8b14bdbda70d85b7d12fedfb">Menu</a>.</p>

</div>
</div>
<a id="a4fc01f017ee724751b48ec3c6fd60df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc01f017ee724751b48ec3c6fd60df3">&#9670;&nbsp;</a></span>addChild() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with a local z-order.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#acfd1b4932c3926cf777ef00235c3386b">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#aa9947ec25c709fa839fdec1795ae2a2c">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a0ba6f93abe0d74d31d08147339952e19">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a42849e8b7b80ca0bcee880f40de9eccd">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#afb7109d348b36c0d672066589ef1e00b">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a36ef7247ab78ee7019eca8c409a30356">ui::ListView</a>, <a class="el" href="classMenu.html#a196fa8d0852b67ab63f7d3937c9b7d1c">Menu</a>, and <a class="el" href="classMenu.html#a38455f79cd083475d9beacf0cc9caf81">Menu</a>.</p>

</div>
</div>
<a id="ac29dab4b296e96c5072545cf9bd94b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29dab4b296e96c5072545cf9bd94b90">&#9670;&nbsp;</a></span>addChild() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z order and tag.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. Please refer to <code><a class="el" href="classNode.html#a41ecfc5e9e398e70dfe2e158f926c16f" title="tag setter ">setTag(int)</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code><a class="el" href="classNode.html#abed32867e81e7902c8155dca7d347a18">addChild(Node* child, int localZOrder, const std::string &amp;name)</a></code> instead. </p>

<p>Reimplemented in <a class="el" href="classSprite.html#af91733127ca0e09dd0a36c78c62ff099">Sprite</a>, <a class="el" href="classSprite.html#aad4985d58ef1bcd5bb0a21ad0601ebce">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#ad0b88c4c9c3b6579167a115cd72d4d56">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#af456e16a833450c52982b487d97b7134">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a26b16c7813db3140be62bad81c20a1f1">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a1843e13af3409763de103e52eb28f3bd">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#aee4869d9b2ca6d88b5075f9078853644">ui::ListView</a>, <a class="el" href="classTMXLayer.html#a6967088f51d0ad613c639b2592692116">TMXLayer</a>, <a class="el" href="classTMXLayer.html#a8f537dd4690c31ee1a61413c9bfcaa94">TMXLayer</a>, <a class="el" href="classui_1_1ListView.html#a9963ad5969a99d1e67694cfb926f56cc">ui::ListView</a>, <a class="el" href="classScrollView.html#a251eb14f9abefa4c10ab4d0602b107c1">ScrollView</a>, <a class="el" href="classScrollView.html#a36cedf4f110c025a6fc1196f6db3cd44">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#a512bd0b1e1bd2741a99bff3997fcbbd6">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a4d84535b9cdc98d8cfbb8d978f84fc93">SpriteBatchNode</a>, <a class="el" href="classMenu.html#aa28d64c32649091ea83bf2da673f8bdf">Menu</a>, <a class="el" href="classMenu.html#a540593eb7fb7de286fe64d6da9c67618">Menu</a>, <a class="el" href="classParticleBatchNode.html#aeaefc79b9a891df138679763791b5ac1">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ae64b2ef0a26f90c90b7afd090ea12825">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a5af09336b4d7f4d25f12d7ddf42a5a9c">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#ad6094cbe40bd10724b586e136edfed4b">ParallaxNode</a>.</p>

</div>
</div>
<a id="abed32867e81e7902c8155dca7d347a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed32867e81e7902c8155dca7d347a18">&#9670;&nbsp;</a></span>addChild() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z order and tag</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node easily. Please refer to <code>setName(int)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#ad1e04b84b4ce5dcebf6c118cdea8565c">Sprite</a>, <a class="el" href="classSprite.html#a5ad9c89cdf0c494c0035c4e0f70465bf">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#a5a7c20a6964a19bfa19bb6522de97055">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#a59f9ed41b62760ee7edf948d633e3cd1">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a76de7bb6c904e26b59aa67cff99feed1">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a84baef5d2ad68df9c19a73da551a780d">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a48d15dfd548d451a87af9a1300343725">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#ac05cf0e2ff70c59b487662364d55eebc">ui::ListView</a>, <a class="el" href="classScrollView.html#af6d19fb104d88a3d884305c2a29842b0">ScrollView</a>, <a class="el" href="classScrollView.html#a29ff1f072b73708543aefc5f5983acba">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#abd6946884e475168e7e9530e1b1c793a">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a50ba6ec6aead30d1abc28e75c75ca4fc">SpriteBatchNode</a>, <a class="el" href="classMenu.html#ae69816c07019fce8984ae387a2c263d2">Menu</a>, <a class="el" href="classMenu.html#a9b9b2f71c16b7c420f6db12a68937ce5">Menu</a>, <a class="el" href="classParticleBatchNode.html#a3d8673da7a4d50a9b8a825a7be13ff88">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a916997259e6b13d141d18e5a1d488943">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a8b6c1d785d253ce586af475763a7afff">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#a2ebcf0d5cf1050020272bae8c76641ed">ParallaxNode</a>.</p>

</div>
</div>
<a id="a6d30a9e718c1c12adf739cb1554c2ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d30a9e718c1c12adf739cb1554c2ff7">&#9670;&nbsp;</a></span>addChild() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z order and tag.</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. Please refer to <code><a class="el" href="classNode.html#a41ecfc5e9e398e70dfe2e158f926c16f" title="tag setter ">setTag(int)</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code><a class="el" href="classNode.html#abed32867e81e7902c8155dca7d347a18">addChild(Node* child, int localZOrder, const std::string &amp;name)</a></code> instead. </p>

<p>Reimplemented in <a class="el" href="classSprite.html#af91733127ca0e09dd0a36c78c62ff099">Sprite</a>, <a class="el" href="classSprite.html#aad4985d58ef1bcd5bb0a21ad0601ebce">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#ad0b88c4c9c3b6579167a115cd72d4d56">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#af456e16a833450c52982b487d97b7134">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a26b16c7813db3140be62bad81c20a1f1">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a1843e13af3409763de103e52eb28f3bd">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#aee4869d9b2ca6d88b5075f9078853644">ui::ListView</a>, <a class="el" href="classTMXLayer.html#a6967088f51d0ad613c639b2592692116">TMXLayer</a>, <a class="el" href="classTMXLayer.html#a8f537dd4690c31ee1a61413c9bfcaa94">TMXLayer</a>, <a class="el" href="classui_1_1ListView.html#a9963ad5969a99d1e67694cfb926f56cc">ui::ListView</a>, <a class="el" href="classScrollView.html#a251eb14f9abefa4c10ab4d0602b107c1">ScrollView</a>, <a class="el" href="classScrollView.html#a36cedf4f110c025a6fc1196f6db3cd44">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#a512bd0b1e1bd2741a99bff3997fcbbd6">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a4d84535b9cdc98d8cfbb8d978f84fc93">SpriteBatchNode</a>, <a class="el" href="classMenu.html#aa28d64c32649091ea83bf2da673f8bdf">Menu</a>, <a class="el" href="classMenu.html#a540593eb7fb7de286fe64d6da9c67618">Menu</a>, <a class="el" href="classParticleBatchNode.html#aeaefc79b9a891df138679763791b5ac1">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ae64b2ef0a26f90c90b7afd090ea12825">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a5af09336b4d7f4d25f12d7ddf42a5a9c">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#ad6094cbe40bd10724b586e136edfed4b">ParallaxNode</a>.</p>

</div>
</div>
<a id="ae96fa155c63a5dc57e3fc89d5488c036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96fa155c63a5dc57e3fc89d5488c036">&#9670;&nbsp;</a></span>addChild() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to the container with z order and tag</p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node easily. Please refer to <code>setName(int)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#ad1e04b84b4ce5dcebf6c118cdea8565c">Sprite</a>, <a class="el" href="classSprite.html#a5ad9c89cdf0c494c0035c4e0f70465bf">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#a5a7c20a6964a19bfa19bb6522de97055">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#a59f9ed41b62760ee7edf948d633e3cd1">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a76de7bb6c904e26b59aa67cff99feed1">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a84baef5d2ad68df9c19a73da551a780d">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a48d15dfd548d451a87af9a1300343725">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#ac05cf0e2ff70c59b487662364d55eebc">ui::ListView</a>, <a class="el" href="classScrollView.html#af6d19fb104d88a3d884305c2a29842b0">ScrollView</a>, <a class="el" href="classScrollView.html#a29ff1f072b73708543aefc5f5983acba">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#abd6946884e475168e7e9530e1b1c793a">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a50ba6ec6aead30d1abc28e75c75ca4fc">SpriteBatchNode</a>, <a class="el" href="classMenu.html#ae69816c07019fce8984ae387a2c263d2">Menu</a>, <a class="el" href="classMenu.html#a9b9b2f71c16b7c420f6db12a68937ce5">Menu</a>, <a class="el" href="classParticleBatchNode.html#a3d8673da7a4d50a9b8a825a7be13ff88">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a916997259e6b13d141d18e5a1d488943">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a8b6c1d785d253ce586af475763a7afff">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#a2ebcf0d5cf1050020272bae8c76641ed">ParallaxNode</a>.</p>

</div>
</div>
<a id="af5f2b77fdfde809abc13432ce526e706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f2b77fdfde809abc13432ce526e706">&#9670;&nbsp;</a></span>addComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::addComponent </td>
          <td>(</td>
          <td class="paramtype">Component *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>A given component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if added success. </dd></dl>

</div>
</div>
<a id="a1c19037b621c89b205fdb3ad620b1f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c19037b621c89b205fdb3ad620b1f8d">&#9670;&nbsp;</a></span>addComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::addComponent </td>
          <td>(</td>
          <td class="paramtype">Component *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>A given component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if added success. </dd></dl>

</div>
</div>
<a id="a7744d16609dfc7609e889129b8672afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7744d16609dfc7609e889129b8672afb">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="classRect.html">Rect</a> Node::boundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Use getBoundingBox instead </dd></dl>

</div>
</div>
<a id="a7744d16609dfc7609e889129b8672afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7744d16609dfc7609e889129b8672afb">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="classRect.html">Rect</a> Node::boundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000261">Deprecated:</a></b></dt><dd>Use getBoundingBox instead </dd></dl>

</div>
</div>
<a id="aa2de84c6cdeec9cd647d236c30ee0567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2de84c6cdeec9cd647d236c30ee0567">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops all running actions and schedulers </p>

<p>Reimplemented in <a class="el" href="classMenuItemToggle.html#a4e70a16bd34c5e770e55e5bf1591aa62">MenuItemToggle</a>, <a class="el" href="classMenuItemToggle.html#a07c137c20a38647fe07e948fa14fbe42">MenuItemToggle</a>, <a class="el" href="classProtectedNode.html#a6eda3b644eb5be15fe5c717c48d25634">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a5462a6202b458193c1881bcdcc5be78d">ProtectedNode</a>, <a class="el" href="classTransitionScene.html#aac61fc66f0b5447ba999cbfda5d0a926">TransitionScene</a>, and <a class="el" href="classTransitionScene.html#a1295b348d0960d857f27a39ecfb52869">TransitionScene</a>.</p>

</div>
</div>
<a id="a4f07dff5b7089859092bece5f328aa5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f07dff5b7089859092bece5f328aa5d">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops all running actions and schedulers </p>

<p>Reimplemented in <a class="el" href="classMenuItemToggle.html#a4e70a16bd34c5e770e55e5bf1591aa62">MenuItemToggle</a>, <a class="el" href="classMenuItemToggle.html#a07c137c20a38647fe07e948fa14fbe42">MenuItemToggle</a>, <a class="el" href="classProtectedNode.html#a6eda3b644eb5be15fe5c717c48d25634">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a5462a6202b458193c1881bcdcc5be78d">ProtectedNode</a>, <a class="el" href="classTransitionScene.html#aac61fc66f0b5447ba999cbfda5d0a926">TransitionScene</a>, and <a class="el" href="classTransitionScene.html#a1295b348d0960d857f27a39ecfb52869">TransitionScene</a>.</p>

</div>
</div>
<a id="ae7bffc192b6e9b24871108d472a0e85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bffc192b6e9b24871108d472a0e85a">&#9670;&nbsp;</a></span>convertToNodeSpace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToNodeSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to node (local) space coordinates. The result is in Points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates. </dd></dl>

</div>
</div>
<a id="ae7bffc192b6e9b24871108d472a0e85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bffc192b6e9b24871108d472a0e85a">&#9670;&nbsp;</a></span>convertToNodeSpace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToNodeSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to node (local) space coordinates. The result is in Points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates. </dd></dl>

</div>
</div>
<a id="a9c7e573a38882cc0727c5f8f65cd9187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7e573a38882cc0727c5f8f65cd9187">&#9670;&nbsp;</a></span>convertToNodeSpaceAR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToNodeSpaceAR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to node (local) space coordinates. The result is in Points. treating the returned/received node point as anchor relative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="a9c7e573a38882cc0727c5f8f65cd9187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7e573a38882cc0727c5f8f65cd9187">&#9670;&nbsp;</a></span>convertToNodeSpaceAR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToNodeSpaceAR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to node (local) space coordinates. The result is in Points. treating the returned/received node point as anchor relative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="a6ff92b98917dbaea150b90b578a84fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff92b98917dbaea150b90b578a84fca">&#9670;&nbsp;</a></span>convertTouchToNodeSpace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertTouchToNodeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTouch.html">Touch</a> *&#160;</td>
          <td class="paramname"><em>touch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convenience methods which take a <a class="el" href="classTouch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> instead of <a class="el" href="classVec2.html">Vec2</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">touch</td><td>A given touch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates. </dd></dl>

</div>
</div>
<a id="a6ff92b98917dbaea150b90b578a84fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff92b98917dbaea150b90b578a84fca">&#9670;&nbsp;</a></span>convertTouchToNodeSpace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertTouchToNodeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTouch.html">Touch</a> *&#160;</td>
          <td class="paramname"><em>touch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convenience methods which take a <a class="el" href="classTouch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> instead of <a class="el" href="classVec2.html">Vec2</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">touch</td><td>A given touch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates. </dd></dl>

</div>
</div>
<a id="af9a987bf0d6590367c254e78426773af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a987bf0d6590367c254e78426773af">&#9670;&nbsp;</a></span>convertTouchToNodeSpaceAR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertTouchToNodeSpaceAR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTouch.html">Touch</a> *&#160;</td>
          <td class="paramname"><em>touch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>converts a <a class="el" href="classTouch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> (world coordinates) into a local coordinate. This method is AR (Anchor Relative).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">touch</td><td>A given touch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="af9a987bf0d6590367c254e78426773af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a987bf0d6590367c254e78426773af">&#9670;&nbsp;</a></span>convertTouchToNodeSpaceAR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertTouchToNodeSpaceAR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTouch.html">Touch</a> *&#160;</td>
          <td class="paramname"><em>touch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>converts a <a class="el" href="classTouch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> (world coordinates) into a local coordinate. This method is AR (Anchor Relative).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">touch</td><td>A given touch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="a9da42e3d980d42aa9508a9de1b51040b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da42e3d980d42aa9508a9de1b51040b">&#9670;&nbsp;</a></span>convertToWorldSpace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToWorldSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to world space coordinates. The result is in Points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates. </dd></dl>

</div>
</div>
<a id="a9da42e3d980d42aa9508a9de1b51040b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da42e3d980d42aa9508a9de1b51040b">&#9670;&nbsp;</a></span>convertToWorldSpace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToWorldSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classVec2.html">Vec2</a> to world space coordinates. The result is in Points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates. </dd></dl>

</div>
</div>
<a id="a84c532f970a06aec83dc881e70526b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c532f970a06aec83dc881e70526b8e">&#9670;&nbsp;</a></span>convertToWorldSpaceAR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToWorldSpaceAR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a local <a class="el" href="classVec2.html">Vec2</a> to world space coordinates.The result is in Points. treating the returned/received node point as anchor relative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="a84c532f970a06aec83dc881e70526b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c532f970a06aec83dc881e70526b8e">&#9670;&nbsp;</a></span>convertToWorldSpaceAR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec2.html">Vec2</a> Node::convertToWorldSpaceAR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a local <a class="el" href="classVec2.html">Vec2</a> to world space coordinates.The result is in Points. treating the returned/received node point as anchor relative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A given coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in world space coordinates, anchor relative. </dd></dl>

</div>
</div>
<a id="aa9a92a1756b585d707a42c3fd1b274d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a92a1756b585d707a42c3fd1b274d4">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> * Node::create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates and initializes a node. </p><dl class="section return"><dt>Returns</dt><dd>A initialized node which is marked as "autorelease". </dd></dl>

</div>
</div>
<a id="a8e23ac4cd34aafe7a332b09d8a9de368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e23ac4cd34aafe7a332b09d8a9de368">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNode.html">Node</a>* Node::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates and initializes a node. </p><dl class="section return"><dt>Returns</dt><dd>A initialized node which is marked as "autorelease". </dd></dl>

</div>
</div>
<a id="abcf85087a15901deb7c6c1231634c8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf85087a15901deb7c6c1231634c8ab">&#9670;&nbsp;</a></span>draw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRenderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override this method to draw your own node. The following GL states will be enabled by default:</p><ul>
<li><code>glEnableClientState(GL_VERTEX_ARRAY);</code></li>
<li><code>glEnableClientState(GL_COLOR_ARRAY);</code></li>
<li><code>glEnableClientState(GL_TEXTURE_COORD_ARRAY);</code></li>
<li><code>glEnable(GL_TEXTURE_2D);</code> AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE But if you enable any other GL state, you should disable it after drawing your node.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A given renderer. </td></tr>
    <tr><td class="paramname">transform</td><td>A transform matrix. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classRenderer.html">Renderer</a> flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a2bc9e0112e0242feb4279c2f951cb8e3">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#ae96994b31bd3e6c6bc93b630b5d5edd1">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#a9f037138c420fcf93178ce48688d4910">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#af9a2190cb947a62c0d04544cd7db6c5e">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#adadbe8ec95b4e789ffe4659a7d03fa43">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#a467ba195c2e7d161fd31436362734968">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#a5eeb7d0ad58586a1b0971d12275a5460">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a261b721fc33fb8eaa01efeeb3d88db56">TransitionCrossFade</a>, <a class="el" href="classui_1_1EditBox.html#ab853853be41d8e50e6b23ca1fcb5641f">ui::EditBox</a>, <a class="el" href="classLabel.html#a01fee2eb2db379b5811b05ee02ba685f">Label</a>, <a class="el" href="classui_1_1Scale9Sprite.html#ae16122e957d7bc7de809d06006b7d6f3">ui::Scale9Sprite</a>, <a class="el" href="classLayerRadialGradient.html#a1756578e18b302c8e2f806646ed8f593">LayerRadialGradient</a>, <a class="el" href="classLabel.html#ac1ceeebcd0a814f22e8b49d40671f140">Label</a>, <a class="el" href="classSprite.html#a6f6d6ad4411cf330f18663f04952fdf6">Sprite</a>, <a class="el" href="classSprite.html#a033c570c383dbab72ca2bc9ccdffb3b9">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#af89050d6cee47d03c205f34fec481db4">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a16ab99f5a4d63be4781d70d581ac1cda">LayerColor</a>, <a class="el" href="classLayerColor.html#ac36be7e85a4e14c1c043598c772f67e4">LayerColor</a>, <a class="el" href="classDrawNode.html#aa08f94d95bce895a248ae66251df846c">DrawNode</a>, <a class="el" href="classDrawNode.html#a425b5c32a324be510862d2fee31328f5">DrawNode</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a3cf6988a4f6c23c695b0c3b9bd1c2d5d">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#aa41866228db8e8b84321d0b6e3f8f112">experimental::TMXLayer</a>, <a class="el" href="classRenderTexture.html#a845d9983454acb72fb8666f92146b082">RenderTexture</a>, <a class="el" href="classRenderTexture.html#a354c10ae4393f186324000e0fda6a9eb">RenderTexture</a>, <a class="el" href="classPUParticleSystem3D.html#a46c2d79b09fcac96e81be307f9148fea">PUParticleSystem3D</a>, <a class="el" href="classPUParticleSystem3D.html#ac4ab268d41e408ba4c2636827717cf48">PUParticleSystem3D</a>, <a class="el" href="classSpriteBatchNode.html#ad47c7d508825041270ed552f647f86e3">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#afa716d3c463c59a6748d68f24045ba9f">SpriteBatchNode</a>, <a class="el" href="classSprite3D.html#a6f6acba3ad6ba8cef63e6cc727df88ab">Sprite3D</a>, <a class="el" href="classSprite3D.html#ac0d723dba5fb1bf83816f74a6dbe4bf8">Sprite3D</a>, <a class="el" href="classParticleSystem3D.html#af039c3af0d3805791c65c58d9abccc8a">ParticleSystem3D</a>, <a class="el" href="classParticleSystem3D.html#a78e6969723062a91ffbd46b08dd0fcb2">ParticleSystem3D</a>, <a class="el" href="classLabelLetter.html#a676b176ed411500ac50b45c7cb104ce0">LabelLetter</a>, <a class="el" href="classLabelLetter.html#a3e0850000ea292406f5d905a431b03dc">LabelLetter</a>, <a class="el" href="classProgressTimer.html#a93e4e885d40db09173bea0a7cf19addb">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#aeff75c55be12ed0c7cc8893140c78de6">ProgressTimer</a>, <a class="el" href="classParticleSystemQuad.html#ab2e534c8bfc790921b3519647ab91073">ParticleSystemQuad</a>, <a class="el" href="classParticleSystemQuad.html#a4bfacab6a326829bcc97be90ea9c6a01">ParticleSystemQuad</a>, <a class="el" href="classParticleBatchNode.html#a780eb41e700d1c44f07dcca694431567">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a05ece10bbbbb5566e28ba1365498eb91">ParticleBatchNode</a>, <a class="el" href="classMotionStreak.html#a5cde4c7320bde796324d67ac11125a1f">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aba3df66a00afb1a9c46178da191041df">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a3b13ccd501ac16227a117870695f34f1">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a108b68a6e6a37a5bc307761c1d14fdaa">MotionStreak3D</a>, <a class="el" href="classTransitionScene.html#ac66bc3e8b2853b3b7078eea2339c9245">TransitionScene</a>, <a class="el" href="classTransitionScene.html#ae3600e652909eeae3113bc39ce8ef8d1">TransitionScene</a>, <a class="el" href="classBillBoard.html#a61816c66a9b5dbfbe12cf1bd747f5229">BillBoard</a>, <a class="el" href="classBillBoard.html#ab8ccc9dc2cbbf46f1f2a56cd0283ce94">BillBoard</a>, <a class="el" href="classAtlasNode.html#af4fb010941d0fd8d26c14a5c524a6b55">AtlasNode</a>, <a class="el" href="classAtlasNode.html#aa396ca085059861b67e3ad9471de797c">AtlasNode</a>, <a class="el" href="classTransitionPageTurn.html#a2df5e0dc13a58e5ac7c8ce27703bd384">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a1e00260a163de7b41a5827ee9ed34d61">TransitionPageTurn</a>, <a class="el" href="classSkybox.html#a6276d85580a2b725dd5dac0c4837c640">Skybox</a>, <a class="el" href="classSkybox.html#a08385a028880991afa6550e25720c37e">Skybox</a>, <a class="el" href="classPhysicsDebugNode.html#a71bda24e446762fc1a1ae2d31927d19a">PhysicsDebugNode</a>, and <a class="el" href="classPhysicsDebugNode.html#a78fe785679cead2a155f0f767932a89f">PhysicsDebugNode</a>.</p>

</div>
</div>
<a id="a6f8fdadb6e26b198cb15920e4d998754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8fdadb6e26b198cb15920e4d998754">&#9670;&nbsp;</a></span>draw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRenderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override this method to draw your own node. The following GL states will be enabled by default:</p><ul>
<li><code>glEnableClientState(GL_VERTEX_ARRAY);</code></li>
<li><code>glEnableClientState(GL_COLOR_ARRAY);</code></li>
<li><code>glEnableClientState(GL_TEXTURE_COORD_ARRAY);</code></li>
<li><code>glEnable(GL_TEXTURE_2D);</code> AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE But if you enable any other GL state, you should disable it after drawing your node.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A given renderer. </td></tr>
    <tr><td class="paramname">transform</td><td>A transform matrix. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classRenderer.html">Renderer</a> flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a2bc9e0112e0242feb4279c2f951cb8e3">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#ae96994b31bd3e6c6bc93b630b5d5edd1">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#a9f037138c420fcf93178ce48688d4910">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#af9a2190cb947a62c0d04544cd7db6c5e">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#adadbe8ec95b4e789ffe4659a7d03fa43">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#a467ba195c2e7d161fd31436362734968">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#a5eeb7d0ad58586a1b0971d12275a5460">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a261b721fc33fb8eaa01efeeb3d88db56">TransitionCrossFade</a>, <a class="el" href="classui_1_1EditBox.html#ab853853be41d8e50e6b23ca1fcb5641f">ui::EditBox</a>, <a class="el" href="classLabel.html#a01fee2eb2db379b5811b05ee02ba685f">Label</a>, <a class="el" href="classui_1_1Scale9Sprite.html#ae16122e957d7bc7de809d06006b7d6f3">ui::Scale9Sprite</a>, <a class="el" href="classLayerRadialGradient.html#a1756578e18b302c8e2f806646ed8f593">LayerRadialGradient</a>, <a class="el" href="classLabel.html#ac1ceeebcd0a814f22e8b49d40671f140">Label</a>, <a class="el" href="classSprite.html#a6f6d6ad4411cf330f18663f04952fdf6">Sprite</a>, <a class="el" href="classSprite.html#a033c570c383dbab72ca2bc9ccdffb3b9">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#af89050d6cee47d03c205f34fec481db4">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a16ab99f5a4d63be4781d70d581ac1cda">LayerColor</a>, <a class="el" href="classLayerColor.html#ac36be7e85a4e14c1c043598c772f67e4">LayerColor</a>, <a class="el" href="classDrawNode.html#aa08f94d95bce895a248ae66251df846c">DrawNode</a>, <a class="el" href="classDrawNode.html#a425b5c32a324be510862d2fee31328f5">DrawNode</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a3cf6988a4f6c23c695b0c3b9bd1c2d5d">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#aa41866228db8e8b84321d0b6e3f8f112">experimental::TMXLayer</a>, <a class="el" href="classRenderTexture.html#a845d9983454acb72fb8666f92146b082">RenderTexture</a>, <a class="el" href="classRenderTexture.html#a354c10ae4393f186324000e0fda6a9eb">RenderTexture</a>, <a class="el" href="classPUParticleSystem3D.html#a46c2d79b09fcac96e81be307f9148fea">PUParticleSystem3D</a>, <a class="el" href="classPUParticleSystem3D.html#ac4ab268d41e408ba4c2636827717cf48">PUParticleSystem3D</a>, <a class="el" href="classSpriteBatchNode.html#ad47c7d508825041270ed552f647f86e3">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#afa716d3c463c59a6748d68f24045ba9f">SpriteBatchNode</a>, <a class="el" href="classSprite3D.html#a6f6acba3ad6ba8cef63e6cc727df88ab">Sprite3D</a>, <a class="el" href="classSprite3D.html#ac0d723dba5fb1bf83816f74a6dbe4bf8">Sprite3D</a>, <a class="el" href="classParticleSystem3D.html#af039c3af0d3805791c65c58d9abccc8a">ParticleSystem3D</a>, <a class="el" href="classParticleSystem3D.html#a78e6969723062a91ffbd46b08dd0fcb2">ParticleSystem3D</a>, <a class="el" href="classLabelLetter.html#a676b176ed411500ac50b45c7cb104ce0">LabelLetter</a>, <a class="el" href="classLabelLetter.html#a3e0850000ea292406f5d905a431b03dc">LabelLetter</a>, <a class="el" href="classProgressTimer.html#a93e4e885d40db09173bea0a7cf19addb">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#aeff75c55be12ed0c7cc8893140c78de6">ProgressTimer</a>, <a class="el" href="classParticleSystemQuad.html#ab2e534c8bfc790921b3519647ab91073">ParticleSystemQuad</a>, <a class="el" href="classParticleSystemQuad.html#a4bfacab6a326829bcc97be90ea9c6a01">ParticleSystemQuad</a>, <a class="el" href="classParticleBatchNode.html#a780eb41e700d1c44f07dcca694431567">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a05ece10bbbbb5566e28ba1365498eb91">ParticleBatchNode</a>, <a class="el" href="classMotionStreak.html#a5cde4c7320bde796324d67ac11125a1f">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aba3df66a00afb1a9c46178da191041df">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a3b13ccd501ac16227a117870695f34f1">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a108b68a6e6a37a5bc307761c1d14fdaa">MotionStreak3D</a>, <a class="el" href="classTransitionScene.html#ac66bc3e8b2853b3b7078eea2339c9245">TransitionScene</a>, <a class="el" href="classTransitionScene.html#ae3600e652909eeae3113bc39ce8ef8d1">TransitionScene</a>, <a class="el" href="classBillBoard.html#a61816c66a9b5dbfbe12cf1bd747f5229">BillBoard</a>, <a class="el" href="classBillBoard.html#ab8ccc9dc2cbbf46f1f2a56cd0283ce94">BillBoard</a>, <a class="el" href="classAtlasNode.html#af4fb010941d0fd8d26c14a5c524a6b55">AtlasNode</a>, <a class="el" href="classAtlasNode.html#aa396ca085059861b67e3ad9471de797c">AtlasNode</a>, <a class="el" href="classTransitionPageTurn.html#a2df5e0dc13a58e5ac7c8ce27703bd384">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a1e00260a163de7b41a5827ee9ed34d61">TransitionPageTurn</a>, <a class="el" href="classSkybox.html#a6276d85580a2b725dd5dac0c4837c640">Skybox</a>, <a class="el" href="classSkybox.html#a08385a028880991afa6550e25720c37e">Skybox</a>, <a class="el" href="classPhysicsDebugNode.html#a71bda24e446762fc1a1ae2d31927d19a">PhysicsDebugNode</a>, and <a class="el" href="classPhysicsDebugNode.html#a78fe785679cead2a155f0f767932a89f">PhysicsDebugNode</a>.</p>

</div>
</div>
<a id="ada6f69bdf4cd0b241dc12935536f3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6f69bdf4cd0b241dc12935536f3dbe">&#9670;&nbsp;</a></span>enumerateChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::enumerateChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *node)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search the children of the receiving node to perform processing for nodes which share a name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to search for, supports c++11 regular expression. Search syntax options: <code>//</code>: Can only be placed at the begin of the search string. This indicates that it will search recursively. <code>..</code>: The search should move up to the node's parent. Can only be placed at the end of string. <code>/</code> : When placed anywhere but the start of the search string, this indicates that the search should move to the node's children.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;//MyName&quot;</span>, ...): This searches the children recursively and matches any node with the name `MyName`.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;[[:alnum:]]+&quot;</span>, ...): This search string matches every node of its children.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;A[[:digit:]]&quot;</span>, ...): This searches the node<span class="stringliteral">&#39;s children and returns any child named `A0`, `A1`, ..., `A9`.</span></div><div class="line"><span class="stringliteral">enumerateChildren(&quot;Abby/Normal&quot;, ...): This searches the node&#39;</span>s grandchildren and returns any node whose name is `Normal`</div><div class="line">and whose parent is named `Abby`.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;//Abby/Normal&quot;</span>, ...): This searches recursively and returns any node whose name is `Normal` and whose</div><div class="line">parent is named `Abby`.</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Only support alpha or number for name, and not support unicode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A callback function to execute on nodes that match the <code>name</code> parameter. The function takes the following arguments: <code>node</code> A node that matches the name And returns a boolean result. Your callback can return <code>true</code> to terminate the enumeration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="ada6f69bdf4cd0b241dc12935536f3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6f69bdf4cd0b241dc12935536f3dbe">&#9670;&nbsp;</a></span>enumerateChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::enumerateChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classNode.html">Node</a> *node)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search the children of the receiving node to perform processing for nodes which share a name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to search for, supports c++11 regular expression. Search syntax options: <code>//</code>: Can only be placed at the begin of the search string. This indicates that it will search recursively. <code>..</code>: The search should move up to the node's parent. Can only be placed at the end of string. <code>/</code> : When placed anywhere but the start of the search string, this indicates that the search should move to the node's children.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;//MyName&quot;</span>, ...): This searches the children recursively and matches any node with the name `MyName`.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;[[:alnum:]]+&quot;</span>, ...): This search string matches every node of its children.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;A[[:digit:]]&quot;</span>, ...): This searches the node<span class="stringliteral">&#39;s children and returns any child named `A0`, `A1`, ..., `A9`.</span></div><div class="line"><span class="stringliteral">enumerateChildren(&quot;Abby/Normal&quot;, ...): This searches the node&#39;</span>s grandchildren and returns any node whose name is `Normal`</div><div class="line">and whose parent is named `Abby`.</div><div class="line"><a class="code" href="classNode.html#ada6f69bdf4cd0b241dc12935536f3dbe">enumerateChildren</a>(<span class="stringliteral">&quot;//Abby/Normal&quot;</span>, ...): This searches recursively and returns any node whose name is `Normal` and whose</div><div class="line">parent is named `Abby`.</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Only support alpha or number for name, and not support unicode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A callback function to execute on nodes that match the <code>name</code> parameter. The function takes the following arguments: <code>node</code> A node that matches the name And returns a boolean result. Your callback can return <code>true</code> to terminate the enumeration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="ad26f8b3ec382080393b96921e3a38ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26f8b3ec382080393b96921e3a38ad8">&#9670;&nbsp;</a></span>getActionByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAction.html">Action</a> * Node::getActionByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an action from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a41ecfc5e9e398e70dfe2e158f926c16f" title="tag setter ">setTag(int)</a></code>, <code><a class="el" href="classNode.html#a9f18b6db8146f2660e8761bb9557d1fe" title="tag getter ">getTag()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The action object with the given tag. </dd></dl>

</div>
</div>
<a id="aa4ada94036cba5f5e2bcc0437369fc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ada94036cba5f5e2bcc0437369fc4a">&#9670;&nbsp;</a></span>getActionByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAction.html">Action</a>* Node::getActionByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an action from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a41ecfc5e9e398e70dfe2e158f926c16f" title="tag setter ">setTag(int)</a></code>, <code><a class="el" href="classNode.html#a9f18b6db8146f2660e8761bb9557d1fe" title="tag getter ">getTag()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The action object with the given tag. </dd></dl>

</div>
</div>
<a id="a4e089841bc08a8753c65b7bb4f96aac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e089841bc08a8753c65b7bb4f96aac5">&#9670;&nbsp;</a></span>getActionManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classActionManager.html">ActionManager</a>* Node::getActionManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a2807ac202214bee721a75c098da54bc6">setActionManager(ActionManager*)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object. </dd></dl>

</div>
</div>
<a id="a4e089841bc08a8753c65b7bb4f96aac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e089841bc08a8753c65b7bb4f96aac5">&#9670;&nbsp;</a></span>getActionManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classActionManager.html">ActionManager</a>* Node::getActionManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a2807ac202214bee721a75c098da54bc6">setActionManager(ActionManager*)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object. </dd></dl>

</div>
</div>
<a id="a391027410f7f45889938090feb631cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391027410f7f45889938090feb631cba">&#9670;&nbsp;</a></span>getAnchorPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVec2.html">Vec2</a> &amp; Node::getAnchorPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>anchorPoint getter </p>
<p>Returns the anchor point in percent.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a4dd45cb48a51df7c257675f527e3f277">setAnchorPoint(const Vec2&amp;)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The anchor point of node. </dd></dl>

</div>
</div>
<a id="a38378d77548a5c7bab5370f05882bb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38378d77548a5c7bab5370f05882bb2f">&#9670;&nbsp;</a></span>getAnchorPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classVec2.html">Vec2</a>&amp; Node::getAnchorPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the anchor point in percent.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a4dd45cb48a51df7c257675f527e3f277">setAnchorPoint(const Vec2&amp;)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The anchor point of node. </dd></dl>

</div>
</div>
<a id="a288b900788ed2db5eddb9d84751a3602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288b900788ed2db5eddb9d84751a3602">&#9670;&nbsp;</a></span>getAnchorPointInPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVec2.html">Vec2</a> &amp; Node::getAnchorPointInPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the anchorPoint in absolute pixels.</p>
<dl class="section warning"><dt>Warning</dt><dd>You can only read it. If you wish to modify it, use anchorPoint instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a391027410f7f45889938090feb631cba" title="anchorPoint getter ">getAnchorPoint()</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The anchor point in absolute pixels. </dd></dl>

</div>
</div>
<a id="a3a34e8bc876a6c391a31e8263237f844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a34e8bc876a6c391a31e8263237f844">&#9670;&nbsp;</a></span>getAnchorPointInPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classVec2.html">Vec2</a>&amp; Node::getAnchorPointInPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the anchorPoint in absolute pixels.</p>
<dl class="section warning"><dt>Warning</dt><dd>You can only read it. If you wish to modify it, use anchorPoint instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a391027410f7f45889938090feb631cba" title="anchorPoint getter ">getAnchorPoint()</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The anchor point in absolute pixels. </dd></dl>

</div>
</div>
<a id="a8e964e787155dc3fcb2ff47ec7f75eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e964e787155dc3fcb2ff47ec7f75eb3">&#9670;&nbsp;</a></span>getAttachedNodeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Node::getAttachedNodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets count of nodes those are attached to scene graph. </p>

</div>
</div>
<a id="a7b3849315467fdb992b273fbd3b3fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3849315467fdb992b273fbd3b3fc66">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRect.html">Rect</a> Node::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an <a class="el" href="classAABB.html">AABB</a> (axis-aligned bounding-box) in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classAABB.html">AABB</a> (axis-aligned bounding-box) in its parent's coordinate system </dd></dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a0b586d58df89f97fca24231c794335ca">Label</a>, <a class="el" href="classLabel.html#a05bcec134c3319eb75dc3fdebc1ab62e">Label</a>, <a class="el" href="classSprite3D.html#a90cebd7aa44add4a6726710b5642daf4">Sprite3D</a>, and <a class="el" href="classSprite3D.html#a45348972b8ce7b37c061b9888b00613a">Sprite3D</a>.</p>

</div>
</div>
<a id="a18d421a217968b87898b7a7382ff7e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d421a217968b87898b7a7382ff7e1b">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRect.html">Rect</a> Node::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an <a class="el" href="classAABB.html">AABB</a> (axis-aligned bounding-box) in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classAABB.html">AABB</a> (axis-aligned bounding-box) in its parent's coordinate system </dd></dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a0b586d58df89f97fca24231c794335ca">Label</a>, <a class="el" href="classLabel.html#a05bcec134c3319eb75dc3fdebc1ab62e">Label</a>, <a class="el" href="classSprite3D.html#a90cebd7aa44add4a6726710b5642daf4">Sprite3D</a>, and <a class="el" href="classSprite3D.html#a45348972b8ce7b37c061b9888b00613a">Sprite3D</a>.</p>

</div>
</div>
<a id="a1c849d2d0bd878a4e3dd1a52ab90fee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c849d2d0bd878a4e3dd1a52ab90fee8">&#9670;&nbsp;</a></span>getCameraMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Node::getCameraMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get &amp; set camera mask, the node is visible by the camera whose camera flag &amp; node's camera mask is true </p>

</div>
</div>
<a id="a1c849d2d0bd878a4e3dd1a52ab90fee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c849d2d0bd878a4e3dd1a52ab90fee8">&#9670;&nbsp;</a></span>getCameraMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Node::getCameraMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get &amp; set camera mask, the node is visible by the camera whose camera flag &amp; node's camera mask is true </p>

</div>
</div>
<a id="ac2f84f995c7d6581787abaa3b09c4518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f84f995c7d6581787abaa3b09c4518">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> * Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> object whose name equals to the input parameter.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#ab61ab552b7ea1fb1ebff43f34441a876">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#a9750342974b85647eac63dc49db4292f">ui::ScrollView</a>.</p>

</div>
</div>
<a id="abbd6d0f2c3d65db94ea75d16402f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd6d0f2c3d65db94ea75d16402f83a2">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its name that can be cast to Type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> with the given name that can be cast to Type T. </dd></dl>

</div>
</div>
<a id="af00de78a02fd2112123857bbe053e163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00de78a02fd2112123857bbe053e163">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNode.html">Node</a>* Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> object whose name equals to the input parameter.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#ab61ab552b7ea1fb1ebff43f34441a876">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#a9750342974b85647eac63dc49db4292f">ui::ScrollView</a>.</p>

</div>
</div>
<a id="abbd6d0f2c3d65db94ea75d16402f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd6d0f2c3d65db94ea75d16402f83a2">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its name that can be cast to Type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> with the given name that can be cast to Type T. </dd></dl>

</div>
</div>
<a id="a8eebd018aa7ebebb674d1649e1a79cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eebd018aa7ebebb674d1649e1a79cac">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> * Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> object whose tag equals to the input parameter.</dd></dl>
<p>Please use <code><a class="el" href="classNode.html#ac2f84f995c7d6581787abaa3b09c4518">getChildByName()</a></code> instead. </p>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a0b4781b276e8040776a7ec93eb54792e">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#a0c523b2f58f7916aa9aaf7bcab4781a7">ui::ScrollView</a>.</p>

</div>
</div>
<a id="a093e82df91d1c2df7d55e5b1b319012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e82df91d1c2df7d55e5b1b319012b">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its tag that can be cast to Type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> with the given tag that can be cast to Type T. </dd></dl>

</div>
</div>
<a id="ac2fa47ea7ec6663e4cfe0580da7131f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fa47ea7ec6663e4cfe0580da7131f5">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNode.html">Node</a>* Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> object whose tag equals to the input parameter.</dd></dl>
<p>Please use <code><a class="el" href="classNode.html#ac2f84f995c7d6581787abaa3b09c4518">getChildByName()</a></code> instead. </p>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a0b4781b276e8040776a7ec93eb54792e">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#a0c523b2f58f7916aa9aaf7bcab4781a7">ui::ScrollView</a>.</p>

</div>
</div>
<a id="a093e82df91d1c2df7d55e5b1b319012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e82df91d1c2df7d55e5b1b319012b">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a child from the container with its tag that can be cast to Type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> with the given tag that can be cast to Type T. </dd></dl>

</div>
</div>
<a id="a25943a94b19e37929b18f93647b58153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25943a94b19e37929b18f93647b58153">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classNode.html">Node</a>*&gt;&amp; Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array of the node's children.</p>
<dl class="section return"><dt>Returns</dt><dd>the array the node's children. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#adf13c7fc4c49dc4030dd4482f7de62b7">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#abde6bf60f60db8d75ac5a63aa0f47dbc">ui::ScrollView</a>.</p>

</div>
</div>
<a id="a25943a94b19e37929b18f93647b58153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25943a94b19e37929b18f93647b58153">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classNode.html">Node</a>*&gt;&amp; Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array of the node's children.</p>
<dl class="section return"><dt>Returns</dt><dd>the array the node's children. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#adf13c7fc4c49dc4030dd4482f7de62b7">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#abde6bf60f60db8d75ac5a63aa0f47dbc">ui::ScrollView</a>.</p>

</div>
</div>
<a id="abe0559adacadcb3a367c8cf7ba65730e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0559adacadcb3a367c8cf7ba65730e">&#9670;&nbsp;</a></span>getChildrenCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Node::getChildrenCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the amount of children.</p>
<dl class="section return"><dt>Returns</dt><dd>The amount of children. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a129cd98a1960479ab18dd43486ed0856">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#ab3597728897d06856656a377ef26e73c">ui::ScrollView</a>.</p>

</div>
</div>
<a id="a2ae0db7fcb1347684d462a873944b534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae0db7fcb1347684d462a873944b534">&#9670;&nbsp;</a></span>getChildrenCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ssize_t Node::getChildrenCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the amount of children.</p>
<dl class="section return"><dt>Returns</dt><dd>The amount of children. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1ScrollView.html#a129cd98a1960479ab18dd43486ed0856">ui::ScrollView</a>, and <a class="el" href="classui_1_1ScrollView.html#ab3597728897d06856656a377ef26e73c">ui::ScrollView</a>.</p>

</div>
</div>
<a id="a06721d272f5a59e02e355d95be25bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06721d272f5a59e02e355d95be25bb99">&#9670;&nbsp;</a></span>getColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structColor3B.html">Color3B</a> &amp; Node::getColor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query node's color value. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structColor3B.html">Color3B</a> color value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a730149ff787a7a86d78a5c0d0aecddda">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a730149ff787a7a86d78a5c0d0aecddda">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab14530232cae13fbf4399e0a47daa315">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab14530232cae13fbf4399e0a47daa315">__LayerRGBA</a>, <a class="el" href="classProgressTimer.html#ad8ca5deb560d078fcd576c896981b5c2">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#acf6cb8de15ca3e8954c05a64adec8402">ProgressTimer</a>, <a class="el" href="classAtlasNode.html#a2921f746aab7922633bcd18790619e75">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a9d19a5b168ff065c4cb565a94f9f3d7f">AtlasNode</a>.</p>

</div>
</div>
<a id="af9507fbd163ea92784f52f4cd15c000d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9507fbd163ea92784f52f4cd15c000d">&#9670;&nbsp;</a></span>getColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structColor3B.html">Color3B</a>&amp; Node::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query node's color value. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structColor3B.html">Color3B</a> color value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a730149ff787a7a86d78a5c0d0aecddda">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a730149ff787a7a86d78a5c0d0aecddda">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab14530232cae13fbf4399e0a47daa315">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab14530232cae13fbf4399e0a47daa315">__LayerRGBA</a>, <a class="el" href="classProgressTimer.html#ad8ca5deb560d078fcd576c896981b5c2">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#acf6cb8de15ca3e8954c05a64adec8402">ProgressTimer</a>, <a class="el" href="classAtlasNode.html#a2921f746aab7922633bcd18790619e75">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a9d19a5b168ff065c4cb565a94f9f3d7f">AtlasNode</a>.</p>

</div>
</div>
<a id="a149c99ff0cb7285f5e51d331672adbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149c99ff0cb7285f5e51d331672adbb9">&#9670;&nbsp;</a></span>getComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component * Node::getComponent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a component by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A given name of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Component by name. </dd></dl>

</div>
</div>
<a id="a2867ee7521172ead4346cb755e9dbaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2867ee7521172ead4346cb755e9dbaca">&#9670;&nbsp;</a></span>getComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component* Node::getComponent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a component by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A given name of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Component by name. </dd></dl>

</div>
</div>
<a id="a3828836a62dbf0862ecaa99a72babc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3828836a62dbf0862ecaa99a72babc13">&#9670;&nbsp;</a></span>getContentSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSize.html">Size</a> &amp; Node::getContentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contentSize getter </p>
<p>Returns the untransformed size of the node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ade113d7fc9244f58ac98a4712da49818">setContentSize(const Size&amp;)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The untransformed size of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a6ff9d78705856ffaf4b5258682e1df00">Label</a>, <a class="el" href="classLabel.html#a3b571f804249bde9c8d8a5b4bb067d3f">Label</a>, <a class="el" href="classScrollView.html#a996456628c049a6cc2876a7b18d15648">ScrollView</a>, and <a class="el" href="classScrollView.html#a137f08e58505c253a4c3274c426200b2">ScrollView</a>.</p>

</div>
</div>
<a id="a7f2f3f01d27d07883359139fce9d628a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2f3f01d27d07883359139fce9d628a">&#9670;&nbsp;</a></span>getContentSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classSize.html">Size</a>&amp; Node::getContentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the untransformed size of the node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ade113d7fc9244f58ac98a4712da49818">setContentSize(const Size&amp;)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The untransformed size of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a6ff9d78705856ffaf4b5258682e1df00">Label</a>, <a class="el" href="classLabel.html#a3b571f804249bde9c8d8a5b4bb067d3f">Label</a>, <a class="el" href="classScrollView.html#a996456628c049a6cc2876a7b18d15648">ScrollView</a>, and <a class="el" href="classScrollView.html#a137f08e58505c253a4c3274c426200b2">ScrollView</a>.</p>

</div>
</div>
<a id="a41710375a0d92a4ee54c39fe123b5912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41710375a0d92a4ee54c39fe123b5912">&#9670;&nbsp;</a></span>getDescription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Node::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the description string. It makes debugging easier. </p><dl class="section return"><dt>Returns</dt><dd>A string  NA  NA </dd></dl>

<p>Reimplemented in <a class="el" href="classLayerMultiplex.html#ab87bcf38601d2ef54325b95e22565d31">LayerMultiplex</a>, <a class="el" href="classui_1_1Widget.html#a5955006f31a13706d69b4d261f2f98cd">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#ad85abdaa9133dc6b8efc32670ae9b93f">ui::Widget</a>, <a class="el" href="classLayerMultiplex.html#a60e44b51edd0e10a3601bf5e5094c30d">LayerMultiplex</a>, <a class="el" href="classui_1_1EditBox.html#a7b19d7662f3a8ab64601c5c8abd8aada">ui::EditBox</a>, <a class="el" href="classLabel.html#ae79fa577b14144f17662dd8432ecd237">Label</a>, <a class="el" href="classLabel.html#ab4b264b43169b883b12043b5a860e901">Label</a>, <a class="el" href="classui_1_1TextField.html#ad3dd2bd1a5d8d501e63d5922c95c1bc2">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#ac13041fae03618740ee778f8c3c6db7e">ui::ScrollView</a>, <a class="el" href="classui_1_1TextField.html#a4bad40260133981d610490c948bc0648">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#a3a808390a8d9162dbbf83d5211e87f2e">ui::ScrollView</a>, <a class="el" href="classLayerGradient.html#ace9ed0ed0422bdc89a7e440a9f8307d3">LayerGradient</a>, <a class="el" href="classLayerGradient.html#a95a281f25e6c4196664e9866e451fcc2">LayerGradient</a>, <a class="el" href="classSprite.html#af35014afbb571e3781023322613b695b">Sprite</a>, <a class="el" href="classui_1_1RichText.html#aeae6c6fd1f11e9342ada2ef87dbf8681">ui::RichText</a>, <a class="el" href="classui_1_1RichText.html#aeae6c6fd1f11e9342ada2ef87dbf8681">ui::RichText</a>, <a class="el" href="classui_1_1ListView.html#a921a755d9787f976af9424ceb16a1aa3">ui::ListView</a>, <a class="el" href="classSprite.html#acc5ff8de93a81ddd7f3d4af5c7ba0d39">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a00b9b37d30ef21b95997a016af53e05e">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a363da7455314bdf8a5fd4f809e70796e">LayerColor</a>, <a class="el" href="classLayerColor.html#aae6932d9d9e0ae21cc34e1e37d0b2d92">LayerColor</a>, <a class="el" href="classui_1_1ListView.html#a653bb454095ef227949f7c791b68180c">ui::ListView</a>, <a class="el" href="classui_1_1Layout.html#abab3763418d0b11bb800c68aed425afd">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a3fdf14a50462dff31ec875b28e223c7f">ui::Layout</a>, <a class="el" href="classTMXLayer.html#a1238ed7681395864c66ebda4b90c5d3b">TMXLayer</a>, <a class="el" href="classTMXLayer.html#ae03bc92e2f95a1c6cfce363a8abcfd77">TMXLayer</a>, <a class="el" href="classTMXTiledMap.html#a300398db77c8dcabafc6723eaaee67af">TMXTiledMap</a>, <a class="el" href="classTMXTiledMap.html#adf91a0a108c7e78b84716cd926d96113">TMXTiledMap</a>, <a class="el" href="classui_1_1RadioButtonGroup.html#aed6a80ca4ca4cb6a91efa19de06829ae">ui::RadioButtonGroup</a>, <a class="el" href="classui_1_1RadioButtonGroup.html#adfabb4162d7b0f22d376feab245869a6">ui::RadioButtonGroup</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a5d2c509af2c8beec8b9e52ca6fad0b91">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#ae03bc92e2f95a1c6cfce363a8abcfd77">experimental::TMXLayer</a>, <a class="el" href="classui_1_1Slider.html#a064d37cc091783546ed36b4a0b7e4ca5">ui::Slider</a>, <a class="el" href="classui_1_1PageView.html#aead0575c0e5d24da3731501afadf81e9">ui::PageView</a>, <a class="el" href="classui_1_1Slider.html#a8267160a9d513ad4761eb916a76223ec">ui::Slider</a>, <a class="el" href="classLayer.html#ac35b850bd512fae372643e3217083260">Layer</a>, <a class="el" href="classLayer.html#acadcdf383e0bf892c95213a4f7725672">Layer</a>, <a class="el" href="classui_1_1PageView.html#a3c9b2934fdbbb44e2c456feee27b53de">ui::PageView</a>, <a class="el" href="classSpriteBatchNode.html#a6040059cb5e2e7681cbddc0d55a2859e">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#abaf755bc79646464f59b68b5a4fdc68c">SpriteBatchNode</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html#ad9a07d8d562a0c138d903dca0f82e2f1">experimental::TMXTiledMap</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html#adf91a0a108c7e78b84716cd926d96113">experimental::TMXTiledMap</a>, <a class="el" href="classui_1_1Text.html#ac554a5ade84b530bb1a4e45a1744ceb6">ui::Text</a>, <a class="el" href="classui_1_1Text.html#a0e8df6544b351130890d9af3e7433582">ui::Text</a>, <a class="el" href="classui_1_1Button.html#a4b06a101bd62b33f40d2e400e42211fc">ui::Button</a>, <a class="el" href="classui_1_1Button.html#a83561b6b24c0895c5aab6f746a6ecf61">ui::Button</a>, <a class="el" href="classMenu.html#ac8ea6b6d3296f7c973e1d82051425afe">Menu</a>, <a class="el" href="classMenu.html#a2f8bee450bcae21f9d5f27941467ff59">Menu</a>, <a class="el" href="classui_1_1LoadingBar.html#abf92eb9c1275d45339da7fdee00d4fcd">ui::LoadingBar</a>, <a class="el" href="classui_1_1LoadingBar.html#afb956804ae7e7b17a5a5810974ca9d99">ui::LoadingBar</a>, <a class="el" href="classui_1_1CheckBox.html#a70adb285f026423e0b090ef5818b9988">ui::CheckBox</a>, <a class="el" href="classui_1_1CheckBox.html#ac2793859e832554dca4c965bfd8d54ba">ui::CheckBox</a>, <a class="el" href="classParticleSystemQuad.html#a35f7879ed4a7c15a151b83d49f7c2502">ParticleSystemQuad</a>, <a class="el" href="classParticleSystemQuad.html#a33c853c9e7bd5763c7775b1944ec9572">ParticleSystemQuad</a>, <a class="el" href="classui_1_1ImageView.html#a1153b5455bf7efddac3fe5beb8c46b57">ui::ImageView</a>, <a class="el" href="classui_1_1TextAtlas.html#a36a90d51e86387430b57c57fea9d5f4b">ui::TextAtlas</a>, <a class="el" href="classui_1_1TextAtlas.html#ab0cfaf71fb9b5e41c1d9cd8374a8a382">ui::TextAtlas</a>, <a class="el" href="classui_1_1RadioButton.html#a5c33c8095823e90579b796b3c9b99ff6">ui::RadioButton</a>, <a class="el" href="classui_1_1RadioButton.html#a6acf02eae3de05f0eb9034066ad3ee68">ui::RadioButton</a>, <a class="el" href="classui_1_1ImageView.html#add3f735a7cee8c3192e9ee992446af12">ui::ImageView</a>, <a class="el" href="classMenuItem.html#adfbe1ff271fb56adcffc38142c1e7a35">MenuItem</a>, <a class="el" href="classMenuItem.html#a47f8424575b4f223520d236dda34c3db">MenuItem</a>, <a class="el" href="classui_1_1TextBMFont.html#ab0472d58930e8b0f290e69ac13756353">ui::TextBMFont</a>, <a class="el" href="classui_1_1TextBMFont.html#ad0de7ec80e5ef916d147a77390e89aba">ui::TextBMFont</a>, <a class="el" href="classLabelAtlas.html#a31869bda92ecc664002ebd96b979d099">LabelAtlas</a>, <a class="el" href="classLabelAtlas.html#aad009427295f2927b45a81a0f1af440d">LabelAtlas</a>, <a class="el" href="classScene.html#a072cf51850bc3ec24da49d338c202fe1">Scene</a>, and <a class="el" href="classScene.html#a81381e50c3ae90f1f5f02ca2ef1c7158">Scene</a>.</p>

</div>
</div>
<a id="a8a54b2b6449d20d852bd3c9f775bb556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a54b2b6449d20d852bd3c9f775bb556">&#9670;&nbsp;</a></span>getDescription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Node::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the description string. It makes debugging easier. </p><dl class="section return"><dt>Returns</dt><dd>A string  NA  NA </dd></dl>

<p>Reimplemented in <a class="el" href="classLayerMultiplex.html#ab87bcf38601d2ef54325b95e22565d31">LayerMultiplex</a>, <a class="el" href="classui_1_1Widget.html#a5955006f31a13706d69b4d261f2f98cd">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#ad85abdaa9133dc6b8efc32670ae9b93f">ui::Widget</a>, <a class="el" href="classLayerMultiplex.html#a60e44b51edd0e10a3601bf5e5094c30d">LayerMultiplex</a>, <a class="el" href="classui_1_1EditBox.html#a7b19d7662f3a8ab64601c5c8abd8aada">ui::EditBox</a>, <a class="el" href="classLabel.html#ae79fa577b14144f17662dd8432ecd237">Label</a>, <a class="el" href="classLabel.html#ab4b264b43169b883b12043b5a860e901">Label</a>, <a class="el" href="classui_1_1TextField.html#ad3dd2bd1a5d8d501e63d5922c95c1bc2">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#ac13041fae03618740ee778f8c3c6db7e">ui::ScrollView</a>, <a class="el" href="classui_1_1TextField.html#a4bad40260133981d610490c948bc0648">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#a3a808390a8d9162dbbf83d5211e87f2e">ui::ScrollView</a>, <a class="el" href="classLayerGradient.html#ace9ed0ed0422bdc89a7e440a9f8307d3">LayerGradient</a>, <a class="el" href="classLayerGradient.html#a95a281f25e6c4196664e9866e451fcc2">LayerGradient</a>, <a class="el" href="classSprite.html#af35014afbb571e3781023322613b695b">Sprite</a>, <a class="el" href="classui_1_1RichText.html#aeae6c6fd1f11e9342ada2ef87dbf8681">ui::RichText</a>, <a class="el" href="classui_1_1RichText.html#aeae6c6fd1f11e9342ada2ef87dbf8681">ui::RichText</a>, <a class="el" href="classui_1_1ListView.html#a921a755d9787f976af9424ceb16a1aa3">ui::ListView</a>, <a class="el" href="classSprite.html#acc5ff8de93a81ddd7f3d4af5c7ba0d39">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a00b9b37d30ef21b95997a016af53e05e">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a363da7455314bdf8a5fd4f809e70796e">LayerColor</a>, <a class="el" href="classLayerColor.html#aae6932d9d9e0ae21cc34e1e37d0b2d92">LayerColor</a>, <a class="el" href="classui_1_1ListView.html#a653bb454095ef227949f7c791b68180c">ui::ListView</a>, <a class="el" href="classui_1_1Layout.html#abab3763418d0b11bb800c68aed425afd">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a3fdf14a50462dff31ec875b28e223c7f">ui::Layout</a>, <a class="el" href="classTMXLayer.html#a1238ed7681395864c66ebda4b90c5d3b">TMXLayer</a>, <a class="el" href="classTMXLayer.html#ae03bc92e2f95a1c6cfce363a8abcfd77">TMXLayer</a>, <a class="el" href="classTMXTiledMap.html#a300398db77c8dcabafc6723eaaee67af">TMXTiledMap</a>, <a class="el" href="classTMXTiledMap.html#adf91a0a108c7e78b84716cd926d96113">TMXTiledMap</a>, <a class="el" href="classui_1_1RadioButtonGroup.html#aed6a80ca4ca4cb6a91efa19de06829ae">ui::RadioButtonGroup</a>, <a class="el" href="classui_1_1RadioButtonGroup.html#adfabb4162d7b0f22d376feab245869a6">ui::RadioButtonGroup</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a5d2c509af2c8beec8b9e52ca6fad0b91">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#ae03bc92e2f95a1c6cfce363a8abcfd77">experimental::TMXLayer</a>, <a class="el" href="classui_1_1Slider.html#a064d37cc091783546ed36b4a0b7e4ca5">ui::Slider</a>, <a class="el" href="classui_1_1PageView.html#aead0575c0e5d24da3731501afadf81e9">ui::PageView</a>, <a class="el" href="classui_1_1Slider.html#a8267160a9d513ad4761eb916a76223ec">ui::Slider</a>, <a class="el" href="classLayer.html#ac35b850bd512fae372643e3217083260">Layer</a>, <a class="el" href="classLayer.html#acadcdf383e0bf892c95213a4f7725672">Layer</a>, <a class="el" href="classui_1_1PageView.html#a3c9b2934fdbbb44e2c456feee27b53de">ui::PageView</a>, <a class="el" href="classSpriteBatchNode.html#a6040059cb5e2e7681cbddc0d55a2859e">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#abaf755bc79646464f59b68b5a4fdc68c">SpriteBatchNode</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html#ad9a07d8d562a0c138d903dca0f82e2f1">experimental::TMXTiledMap</a>, <a class="el" href="classexperimental_1_1TMXTiledMap.html#adf91a0a108c7e78b84716cd926d96113">experimental::TMXTiledMap</a>, <a class="el" href="classui_1_1Text.html#ac554a5ade84b530bb1a4e45a1744ceb6">ui::Text</a>, <a class="el" href="classui_1_1Text.html#a0e8df6544b351130890d9af3e7433582">ui::Text</a>, <a class="el" href="classui_1_1Button.html#a4b06a101bd62b33f40d2e400e42211fc">ui::Button</a>, <a class="el" href="classui_1_1Button.html#a83561b6b24c0895c5aab6f746a6ecf61">ui::Button</a>, <a class="el" href="classMenu.html#ac8ea6b6d3296f7c973e1d82051425afe">Menu</a>, <a class="el" href="classMenu.html#a2f8bee450bcae21f9d5f27941467ff59">Menu</a>, <a class="el" href="classui_1_1LoadingBar.html#abf92eb9c1275d45339da7fdee00d4fcd">ui::LoadingBar</a>, <a class="el" href="classui_1_1LoadingBar.html#afb956804ae7e7b17a5a5810974ca9d99">ui::LoadingBar</a>, <a class="el" href="classui_1_1CheckBox.html#a70adb285f026423e0b090ef5818b9988">ui::CheckBox</a>, <a class="el" href="classui_1_1CheckBox.html#ac2793859e832554dca4c965bfd8d54ba">ui::CheckBox</a>, <a class="el" href="classParticleSystemQuad.html#a35f7879ed4a7c15a151b83d49f7c2502">ParticleSystemQuad</a>, <a class="el" href="classParticleSystemQuad.html#a33c853c9e7bd5763c7775b1944ec9572">ParticleSystemQuad</a>, <a class="el" href="classui_1_1ImageView.html#a1153b5455bf7efddac3fe5beb8c46b57">ui::ImageView</a>, <a class="el" href="classui_1_1TextAtlas.html#a36a90d51e86387430b57c57fea9d5f4b">ui::TextAtlas</a>, <a class="el" href="classui_1_1TextAtlas.html#ab0cfaf71fb9b5e41c1d9cd8374a8a382">ui::TextAtlas</a>, <a class="el" href="classui_1_1RadioButton.html#a5c33c8095823e90579b796b3c9b99ff6">ui::RadioButton</a>, <a class="el" href="classui_1_1RadioButton.html#a6acf02eae3de05f0eb9034066ad3ee68">ui::RadioButton</a>, <a class="el" href="classui_1_1ImageView.html#add3f735a7cee8c3192e9ee992446af12">ui::ImageView</a>, <a class="el" href="classMenuItem.html#adfbe1ff271fb56adcffc38142c1e7a35">MenuItem</a>, <a class="el" href="classMenuItem.html#a47f8424575b4f223520d236dda34c3db">MenuItem</a>, <a class="el" href="classui_1_1TextBMFont.html#ab0472d58930e8b0f290e69ac13756353">ui::TextBMFont</a>, <a class="el" href="classui_1_1TextBMFont.html#ad0de7ec80e5ef916d147a77390e89aba">ui::TextBMFont</a>, <a class="el" href="classLabelAtlas.html#a31869bda92ecc664002ebd96b979d099">LabelAtlas</a>, <a class="el" href="classLabelAtlas.html#aad009427295f2927b45a81a0f1af440d">LabelAtlas</a>, <a class="el" href="classScene.html#a072cf51850bc3ec24da49d338c202fe1">Scene</a>, and <a class="el" href="classScene.html#a81381e50c3ae90f1f5f02ca2ef1c7158">Scene</a>.</p>

</div>
</div>
<a id="a899760bbad414bfbe9fb51473e99c3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899760bbad414bfbe9fb51473e99c3eb">&#9670;&nbsp;</a></span>getDisplayedColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structColor3B.html">Color3B</a> &amp; Node::getDisplayedColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query node's displayed color. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structColor3B.html">Color3B</a> color value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#ae17a9077b86673cb75f799cb4f6c8a1d">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#ae17a9077b86673cb75f799cb4f6c8a1d">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a621d9a8fe47abd33ec00bd3754bf6ec2">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a621d9a8fe47abd33ec00bd3754bf6ec2">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a1285caec57206ce980b727b86e1976f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285caec57206ce980b727b86e1976f7">&#9670;&nbsp;</a></span>getDisplayedColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structColor3B.html">Color3B</a>&amp; Node::getDisplayedColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query node's displayed color. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structColor3B.html">Color3B</a> color value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#ae17a9077b86673cb75f799cb4f6c8a1d">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#ae17a9077b86673cb75f799cb4f6c8a1d">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a621d9a8fe47abd33ec00bd3754bf6ec2">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a621d9a8fe47abd33ec00bd3754bf6ec2">__LayerRGBA</a>.</p>

</div>
</div>
<a id="ac4f9c61560c8862ebdaecbf79bf8a1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f9c61560c8862ebdaecbf79bf8a1b6">&#9670;&nbsp;</a></span>getDisplayedOpacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLubyte Node::getDisplayedOpacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the node's display opacity. The difference between opacity and displayedOpacity is: The displayedOpacity is what's the final rendering opacity of node. </p><dl class="section return"><dt>Returns</dt><dd>A GLubyte value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#adbf1aa17734836db2096f2901d81d304">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#adbf1aa17734836db2096f2901d81d304">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a3c94f57397e6c53127d1176d14ab25fe">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a3c94f57397e6c53127d1176d14ab25fe">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a81bba31d0e8774ac3fe5c517bfe86e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bba31d0e8774ac3fe5c517bfe86e97">&#9670;&nbsp;</a></span>getDisplayedOpacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GLubyte Node::getDisplayedOpacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the node's display opacity. The difference between opacity and displayedOpacity is: The displayedOpacity is what's the final rendering opacity of node. </p><dl class="section return"><dt>Returns</dt><dd>A GLubyte value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#adbf1aa17734836db2096f2901d81d304">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#adbf1aa17734836db2096f2901d81d304">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a3c94f57397e6c53127d1176d14ab25fe">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a3c94f57397e6c53127d1176d14ab25fe">__LayerRGBA</a>.</p>

</div>
</div>
<a id="ae6ba7b287241f031b271d7d680f070f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ba7b287241f031b271d7d680f070f3">&#9670;&nbsp;</a></span>getEventDispatcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classEventDispatcher.html">EventDispatcher</a>* Node::getEventDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the event dispatcher of scene.</p>
<dl class="section return"><dt>Returns</dt><dd>The event dispatcher of scene. </dd></dl>

</div>
</div>
<a id="ae6ba7b287241f031b271d7d680f070f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ba7b287241f031b271d7d680f070f3">&#9670;&nbsp;</a></span>getEventDispatcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classEventDispatcher.html">EventDispatcher</a>* Node::getEventDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the event dispatcher of scene.</p>
<dl class="section return"><dt>Returns</dt><dd>The event dispatcher of scene. </dd></dl>

</div>
</div>
<a id="afa5a7920169dbe5f21a59029bb04c166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5a7920169dbe5f21a59029bb04c166">&#9670;&nbsp;</a></span>getGlobalZOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getGlobalZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s Global Z Order.</p>
<dl class="section see"><dt>See also</dt><dd><code>setGlobalZOrder(int)</code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The node's global Z order </dd></dl>

</div>
</div>
<a id="afa5a7920169dbe5f21a59029bb04c166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5a7920169dbe5f21a59029bb04c166">&#9670;&nbsp;</a></span>getGlobalZOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getGlobalZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s Global Z Order.</p>
<dl class="section see"><dt>See also</dt><dd><code>setGlobalZOrder(int)</code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The node's global Z order </dd></dl>

</div>
</div>
<a id="aae25dd359a8ddb28d552b14269b69ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae25dd359a8ddb28d552b14269b69ab5">&#9670;&nbsp;</a></span>getGLProgram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGLProgram.html">GLProgram</a> * Node::getGLProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classGLProgram.html">GLProgram</a> (shader) currently used for this node.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGLProgram.html">GLProgram</a> (shader) currently used for this node. </dd></dl>

</div>
</div>
<a id="ac5a091621fe09d1ddc54d2f7789a71d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a091621fe09d1ddc54d2f7789a71d8">&#9670;&nbsp;</a></span>getGLProgram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGLProgram.html">GLProgram</a>* Node::getGLProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classGLProgram.html">GLProgram</a> (shader) currently used for this node.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGLProgram.html">GLProgram</a> (shader) currently used for this node. </dd></dl>

</div>
</div>
<a id="a769007fbb26e8b6ef46096100b57bd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769007fbb26e8b6ef46096100b57bd20">&#9670;&nbsp;</a></span>getGLProgramState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGLProgramState.html">GLProgramState</a> * Node::getGLProgramState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classGLProgramState.html">GLProgramState</a> currently used for this node.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGLProgramState.html">GLProgramState</a> currently used for this node. </dd></dl>

</div>
</div>
<a id="a664a40747cd6cb1410a4521b2dca3bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664a40747cd6cb1410a4521b2dca3bdc">&#9670;&nbsp;</a></span>getGLProgramState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGLProgramState.html">GLProgramState</a>* Node::getGLProgramState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classGLProgramState.html">GLProgramState</a> currently used for this node.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classGLProgramState.html">GLProgramState</a> currently used for this node. </dd></dl>

</div>
</div>
<a id="a4817ce95fa64827e8a58645e5b5854ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4817ce95fa64827e8a58645e5b5854ae">&#9670;&nbsp;</a></span>getGLServerState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE int Node::getGLServerState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>No longer needed  NA </dd></dl>

</div>
</div>
<a id="a4817ce95fa64827e8a58645e5b5854ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4817ce95fa64827e8a58645e5b5854ae">&#9670;&nbsp;</a></span>getGLServerState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE int Node::getGLServerState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000260">Deprecated:</a></b></dt><dd>No longer needed  NA </dd></dl>

</div>
</div>
<a id="a9a9c743ae124b0c1a2d6f0a28a1f06dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9c743ae124b0c1a2d6f0a28a1f06dd">&#9670;&nbsp;</a></span>getLocalZOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Node::getLocalZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the local Z order of this node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The local (relative to its siblings) Z order. </dd></dl>

</div>
</div>
<a id="a03f41047bd53b12c645a429246e31ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f41047bd53b12c645a429246e31ea4">&#9670;&nbsp;</a></span>getLocalZOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t Node::getLocalZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the local Z order of this node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The local (relative to its siblings) Z order. </dd></dl>

</div>
</div>
<a id="a2ddaa1e6fdada0bec680128d9e732162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddaa1e6fdada0bec680128d9e732162">&#9670;&nbsp;</a></span>getName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Node::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the node. </p><dl class="section return"><dt>Returns</dt><dd>A string that identifies the node.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="a484b1fc5cd08d0b422fc4051b125ea44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484b1fc5cd08d0b422fc4051b125ea44">&#9670;&nbsp;</a></span>getName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; Node::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the node. </p><dl class="section return"><dt>Returns</dt><dd>A string that identifies the node.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="a72a4d15c717622a50adb468ccc7fad2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4d15c717622a50adb468ccc7fad2f">&#9670;&nbsp;</a></span>getNodeToParentAffineTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAffineTransform.html">AffineTransform</a> Node::getNodeToParentAffineTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the affine transform matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels.</p>
<p>Note: If ancestor is not a valid ancestor of the node, the API would return the same value as </p><dl class="section see"><dt>See also</dt><dd>getNodeToWorldAffineTransform</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>The parent's node pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.7 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The affine transformation matrix. </dd></dl>

</div>
</div>
<a id="a960eb7e75a7c955eba0ba13e51f825ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960eb7e75a7c955eba0ba13e51f825ea">&#9670;&nbsp;</a></span>getNodeToParentAffineTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::getNodeToParentAffineTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the affine transform matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels.</p>
<p>Note: If ancestor is not a valid ancestor of the node, the API would return the same value as </p><dl class="section see"><dt>See also</dt><dd>getNodeToWorldAffineTransform</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>The parent's node pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.7 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The affine transformation matrix. </dd></dl>

</div>
</div>
<a id="a7235b4a4d449fb7e01459c5c3b24d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7235b4a4d449fb7e01459c5c3b24d1eb">&#9670;&nbsp;</a></span>getNodeToParentTransform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMat4.html">Mat4</a> &amp; Node::getNodeToParentTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a0b751dd5e5c67cada4ab1e27f67f8a71">AttachNode</a>, and <a class="el" href="classAttachNode.html#acff1e6467b97ca416e45af09c28028d6">AttachNode</a>.</p>

</div>
</div>
<a id="a0cc9a3bec00628f37f4742378bdcfcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc9a3bec00628f37f4742378bdcfcca">&#9670;&nbsp;</a></span>getNodeToParentTransform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMat4.html">Mat4</a> Node::getNodeToParentTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels. Note: If ancestor is not a valid ancestor of the node, the API would return the same value as </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a1e46065101d0d5dba32262067d85bf23">getNodeToWorldTransform</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>The parent's node pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.7 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a58894159c8240ab57a3d62fd6a455c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58894159c8240ab57a3d62fd6a455c23">&#9670;&nbsp;</a></span>getNodeToParentTransform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classMat4.html">Mat4</a>&amp; Node::getNodeToParentTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a0b751dd5e5c67cada4ab1e27f67f8a71">AttachNode</a>, and <a class="el" href="classAttachNode.html#acff1e6467b97ca416e45af09c28028d6">AttachNode</a>.</p>

</div>
</div>
<a id="af403db8a8c516faa4462fd3a87f6eb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af403db8a8c516faa4462fd3a87f6eb9a">&#9670;&nbsp;</a></span>getNodeToParentTransform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMat4.html">Mat4</a> Node::getNodeToParentTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates. The matrix is in Pixels. Note: If ancestor is not a valid ancestor of the node, the API would return the same value as </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a1e46065101d0d5dba32262067d85bf23">getNodeToWorldTransform</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>The parent's node pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.7 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a1e46065101d0d5dba32262067d85bf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e46065101d0d5dba32262067d85bf23">&#9670;&nbsp;</a></span>getNodeToWorldTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMat4.html">Mat4</a> Node::getNodeToWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the world affine transform matrix. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix, in pixels. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a53970668bcd205b385e4dd0ae2af8039">AttachNode</a>, and <a class="el" href="classAttachNode.html#acb93bdd6d5c0e981b081513d3e307b49">AttachNode</a>.</p>

</div>
</div>
<a id="ae2cede05ce1912aea7903ce17dbebd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cede05ce1912aea7903ce17dbebd86">&#9670;&nbsp;</a></span>getNodeToWorldTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMat4.html">Mat4</a> Node::getNodeToWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the world affine transform matrix. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix, in pixels. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a53970668bcd205b385e4dd0ae2af8039">AttachNode</a>, and <a class="el" href="classAttachNode.html#acb93bdd6d5c0e981b081513d3e307b49">AttachNode</a>.</p>

</div>
</div>
<a id="a9887ca06e6ecc7e19806927036bf8b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9887ca06e6ecc7e19806927036bf8b57">&#9670;&nbsp;</a></span>getNormalizedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVec2.html">Vec2</a> &amp; Node::getNormalizedPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position getter </p>
<p>Returns the normalized position.</p>
<dl class="section return"><dt>Returns</dt><dd>The normalized position. </dd></dl>

</div>
</div>
<a id="a576446fef9c35a1a06535eb8949df2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576446fef9c35a1a06535eb8949df2f3">&#9670;&nbsp;</a></span>getNumberOfRunningActions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Node::getNumberOfRunningActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).</p>
<p>Composable actions are counted as 1 action. Example: If you are running 1 <a class="el" href="classSequence.html" title="Runs actions sequentially, one after another. ">Sequence</a> of 7 actions, it will return 1. If you are running 7 Sequences of 2 actions, it will return 7.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions that are running plus the ones that are schedule to run. </dd></dl>

</div>
</div>
<a id="a576446fef9c35a1a06535eb8949df2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576446fef9c35a1a06535eb8949df2f3">&#9670;&nbsp;</a></span>getNumberOfRunningActions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Node::getNumberOfRunningActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).</p>
<p>Composable actions are counted as 1 action. Example: If you are running 1 <a class="el" href="classSequence.html" title="Runs actions sequentially, one after another. ">Sequence</a> of 7 actions, it will return 1. If you are running 7 Sequences of 2 actions, it will return 7.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of actions that are running plus the ones that are schedule to run. </dd></dl>

</div>
</div>
<a id="a79f360d4398f3748527a281513364d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f360d4398f3748527a281513364d94">&#9670;&nbsp;</a></span>getNumberOfRunningActionsByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Node::getNumberOfRunningActionsByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays) with a specific tag.</p>
<p>Composable actions are counted as 1 action. Example: If you are running 1 <a class="el" href="classSequence.html" title="Runs actions sequentially, one after another. ">Sequence</a> of 7 actions, it will return 1. If you are running 7 Sequences of 2 actions, it will return 7.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag that will be searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of actions that are running plus the ones that are schedule to run with specific tag. </dd></dl>

</div>
</div>
<a id="ad7b097bc5f33406aa84f0b31cabc8c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b097bc5f33406aa84f0b31cabc8c91">&#9670;&nbsp;</a></span>getOnEnterCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getOnEnterCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event onEnter. </p><dl class="section return"><dt>Returns</dt><dd>A std:function&lt;void()&gt; callback. </dd></dl>

</div>
</div>
<a id="ad7b097bc5f33406aa84f0b31cabc8c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b097bc5f33406aa84f0b31cabc8c91">&#9670;&nbsp;</a></span>getOnEnterCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getOnEnterCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event onEnter. </p><dl class="section return"><dt>Returns</dt><dd>A std:function&lt;void()&gt; callback. </dd></dl>

</div>
</div>
<a id="af905ed9ea4b7884fdb9be2b8b2fbcf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af905ed9ea4b7884fdb9be2b8b2fbcf53">&#9670;&nbsp;</a></span>getonEnterTransitionDidFinishCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getonEnterTransitionDidFinishCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event EnterTransitionDidFinish. </p><dl class="section return"><dt>Returns</dt><dd>std::function&lt;void()&gt; </dd></dl>

</div>
</div>
<a id="af905ed9ea4b7884fdb9be2b8b2fbcf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af905ed9ea4b7884fdb9be2b8b2fbcf53">&#9670;&nbsp;</a></span>getonEnterTransitionDidFinishCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getonEnterTransitionDidFinishCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event EnterTransitionDidFinish. </p><dl class="section return"><dt>Returns</dt><dd>std::function&lt;void()&gt; </dd></dl>

</div>
</div>
<a id="ab0b4c33e5b8ef5770d0f4d8ed410e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b4c33e5b8ef5770d0f4d8ed410e596">&#9670;&nbsp;</a></span>getOnExitCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getOnExitCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event onExit. </p><dl class="section return"><dt>Returns</dt><dd>A std::function&lt;void()&gt;. </dd></dl>

</div>
</div>
<a id="ab0b4c33e5b8ef5770d0f4d8ed410e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b4c33e5b8ef5770d0f4d8ed410e596">&#9670;&nbsp;</a></span>getOnExitCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getOnExitCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event onExit. </p><dl class="section return"><dt>Returns</dt><dd>A std::function&lt;void()&gt;. </dd></dl>

</div>
</div>
<a id="a306d572d520d31dd83ed3eedd2b78d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d572d520d31dd83ed3eedd2b78d4e">&#9670;&nbsp;</a></span>getonExitTransitionDidStartCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getonExitTransitionDidStartCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event ExitTransitionDidStart. </p><dl class="section return"><dt>Returns</dt><dd>std::function&lt;void()&gt; </dd></dl>

</div>
</div>
<a id="a306d572d520d31dd83ed3eedd2b78d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d572d520d31dd83ed3eedd2b78d4e">&#9670;&nbsp;</a></span>getonExitTransitionDidStartCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void()&gt;&amp; Node::getonExitTransitionDidStartCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the callback of event ExitTransitionDidStart. </p><dl class="section return"><dt>Returns</dt><dd>std::function&lt;void()&gt; </dd></dl>

</div>
</div>
<a id="ab999cce3763ea09e74014245c770ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab999cce3763ea09e74014245c770ea97">&#9670;&nbsp;</a></span>getOpacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLubyte Node::getOpacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the node's opacity. </p><dl class="section return"><dt>Returns</dt><dd>A GLubyte value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a48a5a78aea7c307ccfbe8c10e053b7c8">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a48a5a78aea7c307ccfbe8c10e053b7c8">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a61d071eeff8bc1c46520611261f5dd1a">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a61d071eeff8bc1c46520611261f5dd1a">__LayerRGBA</a>, <a class="el" href="classProgressTimer.html#ab65270de82c7f02e733ce017830c2409">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#ae9f8f93b5849d34fce2fa84ffec463c1">ProgressTimer</a>, <a class="el" href="classMotionStreak.html#a7e7bfd8eb37092a0477b2c1012e179c2">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a433b068de6c2246676c0654480cb9ea2">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aae52587b7c2cb5833f133b40add6a860">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#ad801e665463b5ed5b60a2d01468ddb89">MotionStreak3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a6c36fff342601b1ab29afaed5e4e201d">ui::ScrollViewBar</a>, and <a class="el" href="classui_1_1ScrollViewBar.html#a6c36fff342601b1ab29afaed5e4e201d">ui::ScrollViewBar</a>.</p>

</div>
</div>
<a id="a46206e9eb52b57c070446613659fe310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46206e9eb52b57c070446613659fe310">&#9670;&nbsp;</a></span>getOpacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GLubyte Node::getOpacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the node's opacity. </p><dl class="section return"><dt>Returns</dt><dd>A GLubyte value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a48a5a78aea7c307ccfbe8c10e053b7c8">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a48a5a78aea7c307ccfbe8c10e053b7c8">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a61d071eeff8bc1c46520611261f5dd1a">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a61d071eeff8bc1c46520611261f5dd1a">__LayerRGBA</a>, <a class="el" href="classProgressTimer.html#ab65270de82c7f02e733ce017830c2409">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#ae9f8f93b5849d34fce2fa84ffec463c1">ProgressTimer</a>, <a class="el" href="classMotionStreak.html#a7e7bfd8eb37092a0477b2c1012e179c2">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a433b068de6c2246676c0654480cb9ea2">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aae52587b7c2cb5833f133b40add6a860">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#ad801e665463b5ed5b60a2d01468ddb89">MotionStreak3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a6c36fff342601b1ab29afaed5e4e201d">ui::ScrollViewBar</a>, and <a class="el" href="classui_1_1ScrollViewBar.html#a6c36fff342601b1ab29afaed5e4e201d">ui::ScrollViewBar</a>.</p>

</div>
</div>
<a id="af4c8a4ae726c6dd984db05c89454652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c8a4ae726c6dd984db05c89454652d">&#9670;&nbsp;</a></span>getParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNode.html">Node</a>* Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the parent node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ab5f0786bcb59591c528efb0b776797fc" title="parent setter ">setParent(Node*)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent node. </dd></dl>

</div>
</div>
<a id="af4c8a4ae726c6dd984db05c89454652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c8a4ae726c6dd984db05c89454652d">&#9670;&nbsp;</a></span>getParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNode.html">Node</a>* Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the parent node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ab5f0786bcb59591c528efb0b776797fc" title="parent setter ">setParent(Node*)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent node. </dd></dl>

</div>
</div>
<a id="a12aae4242a85aa5acfc03c97a018b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aae4242a85aa5acfc03c97a018b621">&#9670;&nbsp;</a></span>getParentToNodeTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMat4.html">Mat4</a> &amp; Node::getParentToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a079a813e52c5b8a2d4f0c4bd5fa90a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079a813e52c5b8a2d4f0c4bd5fa90a91">&#9670;&nbsp;</a></span>getParentToNodeTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classMat4.html">Mat4</a>&amp; Node::getParentToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a1c78c6feace91b27b6cbb12ee16e8eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c78c6feace91b27b6cbb12ee16e8eb0">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVec2.html">Vec2</a> &amp; Node::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position getter </p>
<p>Gets the position (x,y) of the node in its parent's coordinate system.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a8ffbf25763ef5f15eeae7227779505bc" title="position setter ">setPosition(const Vec2&amp;)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The position (x,y) of the node in OpenGL coordinates. <div class="fragment"><div class="line">In js and lua <span class="keywordflow">return</span> value is table which contains x,y.</div></div><!-- fragment --> </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a73f3dcb75380855a39c6ff9eee475d80">MotionStreak</a>, <a class="el" href="classMotionStreak.html#ae5dbfd01e4931044ac764dd43c6fbf30">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a17b236b952ac5670676b2b50a0fab421">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a5c9d70a707ecdaf49d8793ae6e4bce7e">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a47e9123d87921aefc06960a5089c995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e9123d87921aefc06960a5089c995d">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classVec2.html">Vec2</a>&amp; Node::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the position (x,y) of the node in its parent's coordinate system.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a8ffbf25763ef5f15eeae7227779505bc" title="position setter ">setPosition(const Vec2&amp;)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The position (x,y) of the node in OpenGL coordinates. <div class="fragment"><div class="line">In js and lua <span class="keywordflow">return</span> value is table which contains x,y.</div></div><!-- fragment --> </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a73f3dcb75380855a39c6ff9eee475d80">MotionStreak</a>, <a class="el" href="classMotionStreak.html#ae5dbfd01e4931044ac764dd43c6fbf30">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a17b236b952ac5670676b2b50a0fab421">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a5c9d70a707ecdaf49d8793ae6e4bce7e">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a216f30e9a2dda896b2ffff1885b33a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216f30e9a2dda896b2ffff1885b33a98">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets position in a more efficient way, returns two number instead of a <a class="el" href="classVec2.html">Vec2</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aaa8545c103ef1b35e5076dbedab93af5">setPosition(float, float)</a></code> In js,out value not return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>To receive x coordinate for position. </td></tr>
    <tr><td class="paramname">y</td><td>To receive y coordinate for position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a376d2fd83190f87fa86f1aa91ac8f158">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a979de1d0159b7ebca8c4270aa8d1eece">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aca30ce7817540e8cf038cf11adc58154">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a16c2911514702c9d808d1afad8d0ece3">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ad48898f3e8629cf9f7da78b0ae0c68ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48898f3e8629cf9f7da78b0ae0c68ae">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets position in a more efficient way, returns two number instead of a <a class="el" href="classVec2.html">Vec2</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aaa8545c103ef1b35e5076dbedab93af5">setPosition(float, float)</a></code> In js,out value not return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>To receive x coordinate for position. </td></tr>
    <tr><td class="paramname">y</td><td>To receive y coordinate for position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a376d2fd83190f87fa86f1aa91ac8f158">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a979de1d0159b7ebca8c4270aa8d1eece">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aca30ce7817540e8cf038cf11adc58154">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a16c2911514702c9d808d1afad8d0ece3">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a8617dd2eb9af75a66ebaff0d3c99285e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8617dd2eb9af75a66ebaff0d3c99285e">&#9670;&nbsp;</a></span>getPosition3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec3.html">Vec3</a> Node::getPosition3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the position (X,Y,Z) in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The position (X, Y, and Z) in its parent's coordinate system.  NA </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#ab07adb87a9770b5bbafa2fff999515f6">MotionStreak</a>, <a class="el" href="classMotionStreak.html#afa9dc064ec1140bf1e14e526221d5b72">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#ab2c89d13a16dc7ee2e8f2408a1f5afbb">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a60ec5113c30e2b81c15b43595a98ce63">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a7c3cc76f19c34ce2d4edd48bece7731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3cc76f19c34ce2d4edd48bece7731b">&#9670;&nbsp;</a></span>getPosition3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVec3.html">Vec3</a> Node::getPosition3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the position (X,Y,Z) in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The position (X, Y, and Z) in its parent's coordinate system.  NA </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#ab07adb87a9770b5bbafa2fff999515f6">MotionStreak</a>, <a class="el" href="classMotionStreak.html#afa9dc064ec1140bf1e14e526221d5b72">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#ab2c89d13a16dc7ee2e8f2408a1f5afbb">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a60ec5113c30e2b81c15b43595a98ce63">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ae9d2fb3ed00ccc33d22c1f903622950f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d2fb3ed00ccc33d22c1f903622950f">&#9670;&nbsp;</a></span>getPositionNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVec2.html">Vec2</a> &amp; Node::getPositionNormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position getter </p>
<p>Returns the normalized position.</p>
<dl class="section return"><dt>Returns</dt><dd>The normalized position. </dd></dl>

</div>
</div>
<a id="ad4b27cd8bc98960789fbd2b574666a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b27cd8bc98960789fbd2b574666a25">&#9670;&nbsp;</a></span>getPositionX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getPositionX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the x coordinate of the node in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The x coordinate of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a21adf0bcf7c0713e1e0b0b00c5256a37">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a0a7f37b3a4e479cfed0dea79222ad1e6">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a1cbae92f092d3fb20371a676de053d07">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a2dcc5baf8956d2fef986b564bc21ff5c">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a39284a5629f41cc50054e538ab28f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39284a5629f41cc50054e538ab28f5ab">&#9670;&nbsp;</a></span>getPositionX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getPositionX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the x coordinate of the node in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The x coordinate of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a21adf0bcf7c0713e1e0b0b00c5256a37">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a0a7f37b3a4e479cfed0dea79222ad1e6">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a1cbae92f092d3fb20371a676de053d07">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a2dcc5baf8956d2fef986b564bc21ff5c">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ae2ab411fb5477789b7b96477b18c0f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ab411fb5477789b7b96477b18c0f83">&#9670;&nbsp;</a></span>getPositionY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getPositionY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the y coordinate of the node in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The y coordinate of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a05d60b5b380417f870046d8aa5f6626b">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a4138d128c57dad6a41f8d51bbf13a0f8">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a9880e5a12cec812ba36804232e73bd7b">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#aad2e9762fabf564601865096174a9b54">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ac6335e604f0c11512e45f607f38e72ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6335e604f0c11512e45f607f38e72ec">&#9670;&nbsp;</a></span>getPositionY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getPositionY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the y coordinate of the node in its parent's coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd>The y coordinate of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a05d60b5b380417f870046d8aa5f6626b">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a4138d128c57dad6a41f8d51bbf13a0f8">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a9880e5a12cec812ba36804232e73bd7b">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#aad2e9762fabf564601865096174a9b54">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a0c6023aabdeeff9cf981ad81e6aaed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6023aabdeeff9cf981ad81e6aaed9c">&#9670;&nbsp;</a></span>getPositionZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getPositionZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets position Z coordinate of this node.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#aaea9bcbb6e5972122c590b930b5a90b9">setPositionZ(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The position Z coordinate of this node.  getVertexZ </dd></dl>

</div>
</div>
<a id="a05e59f1a76dd9a1307730da7018b551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e59f1a76dd9a1307730da7018b551b">&#9670;&nbsp;</a></span>getPositionZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getPositionZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets position Z coordinate of this node.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#aaea9bcbb6e5972122c590b930b5a90b9">setPositionZ(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The position Z coordinate of this node.  getVertexZ </dd></dl>

</div>
</div>
<a id="aca7139bc3ea6705d41bb65a4fb7ddb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7139bc3ea6705d41bb65a4fb7ddb6c">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotation getter </p>
<p>Returns the rotation of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a62dda439f77712f0d9b405ce887df676" title="rotation setter ">setRotation(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation of the node in degrees. </dd></dl>

</div>
</div>
<a id="a2bd3900c64525f5b76b0ba7cd489f440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd3900c64525f5b76b0ba7cd489f440">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotation of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a62dda439f77712f0d9b405ce887df676" title="rotation setter ">setRotation(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation of the node in degrees. </dd></dl>

</div>
</div>
<a id="aeabcf9427f303b0adf32bb7513706e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabcf9427f303b0adf32bb7513706e2c">&#9670;&nbsp;</a></span>getRotation3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec3.html">Vec3</a> Node::getRotation3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotation (X,Y,Z) in degrees.</p>
<dl class="section return"><dt>Returns</dt><dd>The rotation of the node in 3d.  NA </dd></dl>

</div>
</div>
<a id="a9aab6e44008bf374051cc87c76d9079f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aab6e44008bf374051cc87c76d9079f">&#9670;&nbsp;</a></span>getRotation3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVec3.html">Vec3</a> Node::getRotation3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotation (X,Y,Z) in degrees.</p>
<dl class="section return"><dt>Returns</dt><dd>The rotation of the node in 3d.  NA </dd></dl>

</div>
</div>
<a id="ad5beb5903cd9dc3258b513e742d1a0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5beb5903cd9dc3258b513e742d1a0d0">&#9670;&nbsp;</a></span>getRotationQuat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQuaternion.html">Quaternion</a> Node::getRotationQuat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the rotation by quaternion, Note that when _rotationZ_X == _rotationZ_Y, the returned quaternion equals to RotationZ_X * RotationY * RotationX, it equals to RotationY * RotationX otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>The rotation in quaternion.  NA </dd></dl>

</div>
</div>
<a id="a6200a7e63f7ccccabc82a7a4554e7d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6200a7e63f7ccccabc82a7a4554e7d36">&#9670;&nbsp;</a></span>getRotationQuat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classQuaternion.html">Quaternion</a> Node::getRotationQuat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the rotation by quaternion, Note that when _rotationZ_X == _rotationZ_Y, the returned quaternion equals to RotationZ_X * RotationY * RotationX, it equals to RotationY * RotationX otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>The rotation in quaternion.  NA </dd></dl>

</div>
</div>
<a id="a2e23faa37bc1d55b7c4b6cba94a62fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23faa37bc1d55b7c4b6cba94a62fce">&#9670;&nbsp;</a></span>getRotationSkewX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getRotationSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a66a533225994dbfe125c3421df4cbb38">setRotationSkewX(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The X rotation in degrees.  getRotationX </dd></dl>

</div>
</div>
<a id="a1102a3896c8af0bd11d1cf9a8b89f4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102a3896c8af0bd11d1cf9a8b89f4fa">&#9670;&nbsp;</a></span>getRotationSkewX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getRotationSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a66a533225994dbfe125c3421df4cbb38">setRotationSkewX(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The X rotation in degrees.  getRotationX </dd></dl>

</div>
</div>
<a id="a6cad8b8118f9530baa3f26659cc1f406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cad8b8118f9530baa3f26659cc1f406">&#9670;&nbsp;</a></span>getRotationSkewY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getRotationSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a901c5fbd2327fbd6fd14771fd45d71af">setRotationSkewY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Y rotation in degrees.  getRotationY </dd></dl>

</div>
</div>
<a id="acd3ba7aeb143dbf516bfbdff965ee53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3ba7aeb143dbf516bfbdff965ee53a">&#9670;&nbsp;</a></span>getRotationSkewY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getRotationSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a901c5fbd2327fbd6fd14771fd45d71af">setRotationSkewY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Y rotation in degrees.  getRotationY </dd></dl>

</div>
</div>
<a id="ac9926440d4edab1020d348a2b950307c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9926440d4edab1020d348a2b950307c">&#9670;&nbsp;</a></span>getScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getScale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scale getter </p>
<p>Gets the scale factor of the node, when X and Y have the same scale factor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Assert when <code>_scaleX != _scaleY</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#acf0955a52f51a9d6c8b0c9267b1e8668" title="scale setter ">setScale(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a83a48c3e969e9ae2d0d4bca560159bff">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#a3decfabeeedb5fac08d9717f7c5421a3">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#ac4806c4d8ba815b1bb2a8f100527ab7b">ui::Widget</a>.</p>

</div>
</div>
<a id="af8a6e8e0d7cc140bf3aa55b5898d8f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a6e8e0d7cc140bf3aa55b5898d8f5d">&#9670;&nbsp;</a></span>getScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the scale factor of the node, when X and Y have the same scale factor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Assert when <code>_scaleX != _scaleY</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#acf0955a52f51a9d6c8b0c9267b1e8668" title="scale setter ">setScale(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a83a48c3e969e9ae2d0d4bca560159bff">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#a3decfabeeedb5fac08d9717f7c5421a3">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#ac4806c4d8ba815b1bb2a8f100527ab7b">ui::Widget</a>.</p>

</div>
</div>
<a id="a27040ef8ab59ccf42b87d6ddc8d794e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27040ef8ab59ccf42b87d6ddc8d794e6">&#9670;&nbsp;</a></span>getScaleX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getScaleX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleX getter </p>
<p>Returns the scale factor on X axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#acf7f04074f7f49972e152788c090b877" title="scaleX setter ">setScaleX(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on X axis. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a3aaed8de223156f4567a4b59e208e66d">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#ad8e055be7f68c56594d97c71dff4f1ae">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#aca37ca371fdab9dc91dc554740b37e11">ui::Widget</a>.</p>

</div>
</div>
<a id="a3ef411875aa6c675e72de13f91235694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef411875aa6c675e72de13f91235694">&#9670;&nbsp;</a></span>getScaleX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getScaleX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the scale factor on X axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#acf7f04074f7f49972e152788c090b877" title="scaleX setter ">setScaleX(float)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on X axis. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a3aaed8de223156f4567a4b59e208e66d">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#ad8e055be7f68c56594d97c71dff4f1ae">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#aca37ca371fdab9dc91dc554740b37e11">ui::Widget</a>.</p>

</div>
</div>
<a id="ab87661ab8940512baf2e7639ea55ff87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87661ab8940512baf2e7639ea55ff87">&#9670;&nbsp;</a></span>getScaleY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getScaleY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleY getter </p>
<p>Returns the scale factor on Y axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aec805a1fa9e8e1038556e468138bb804" title="scaleY setter ">setScaleY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on Y axis. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7bab472ed47f8eb5d061120915f9c2d7">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#af9953371b66c5e1a608c5f7f009093fd">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a932098cecbcccacf326a500f9c8177a7">ui::Widget</a>.</p>

</div>
</div>
<a id="a634136734ab9cce2a3797a621b788c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634136734ab9cce2a3797a621b788c68">&#9670;&nbsp;</a></span>getScaleY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getScaleY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the scale factor on Y axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aec805a1fa9e8e1038556e468138bb804" title="scaleY setter ">setScaleY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on Y axis. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7bab472ed47f8eb5d061120915f9c2d7">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1Widget.html#af9953371b66c5e1a608c5f7f009093fd">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a932098cecbcccacf326a500f9c8177a7">ui::Widget</a>.</p>

</div>
</div>
<a id="a0b55ddbe04d126953e1db8606d9a9ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b55ddbe04d126953e1db8606d9a9ecd">&#9670;&nbsp;</a></span>getScaleZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getScaleZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleY getter </p>
<p>Returns the scale factor on Z axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a79518b90226335e0997552687eb7b33f" title="scaleY setter ">setScaleZ(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on Z axis. </dd></dl>

</div>
</div>
<a id="aac40998528bbad71f1aca2cfab032aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac40998528bbad71f1aca2cfab032aca">&#9670;&nbsp;</a></span>getScaleZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getScaleZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the scale factor on Z axis of this node</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a79518b90226335e0997552687eb7b33f" title="scaleY setter ">setScaleZ(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The scale factor on Z axis. </dd></dl>

</div>
</div>
<a id="a5a61a356773de436f80e55228ea01b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a61a356773de436f80e55228ea01b66">&#9670;&nbsp;</a></span>getScene() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScene.html">Scene</a> * Node::getScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> that contains the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>. It returns <code>nullptr</code> if the node doesn't belong to any <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. This function recursively calls parent-&gt;<a class="el" href="classNode.html#a5a61a356773de436f80e55228ea01b66">getScene()</a> until parent is a <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> object. The results are not cached. It is that the user caches the results in case this functions is being used inside a loop.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> that contains the node. </dd></dl>

</div>
</div>
<a id="adab0150253ebac47b36dfcdf8f8f8696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab0150253ebac47b36dfcdf8f8f8696">&#9670;&nbsp;</a></span>getScene() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classScene.html">Scene</a>* Node::getScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> that contains the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>. It returns <code>nullptr</code> if the node doesn't belong to any <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. This function recursively calls parent-&gt;<a class="el" href="classNode.html#a5a61a356773de436f80e55228ea01b66">getScene()</a> until parent is a <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> object. The results are not cached. It is that the user caches the results in case this functions is being used inside a loop.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> that contains the node. </dd></dl>

</div>
</div>
<a id="a5d438ab0f04dfa3af9a72ae608478264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d438ab0f04dfa3af9a72ae608478264">&#9670;&nbsp;</a></span>getScheduler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classScheduler.html">Scheduler</a>* Node::getScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a9f0c84dfabdce76b5251725944ae7706">setScheduler(Scheduler*)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object. </dd></dl>

</div>
</div>
<a id="a5d438ab0f04dfa3af9a72ae608478264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d438ab0f04dfa3af9a72ae608478264">&#9670;&nbsp;</a></span>getScheduler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classScheduler.html">Scheduler</a>* Node::getScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a9f0c84dfabdce76b5251725944ae7706">setScheduler(Scheduler*)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object. </dd></dl>

</div>
</div>
<a id="adb23628a9cef9c16cfcfd955a51ac8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb23628a9cef9c16cfcfd955a51ac8bd">&#9670;&nbsp;</a></span>getSkewX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the X skew angle of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a48cf4d7b304b57a3f593d9eecde3ac7f">setSkewX(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The X skew angle of the node in degrees. </dd></dl>

</div>
</div>
<a id="adb7b2e936143dfd1622c568b2d56792b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b2e936143dfd1622c568b2d56792b">&#9670;&nbsp;</a></span>getSkewX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the X skew angle of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a48cf4d7b304b57a3f593d9eecde3ac7f">setSkewX(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The X skew angle of the node in degrees. </dd></dl>

</div>
</div>
<a id="a260877f2b51c284555fc272c7ba28f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260877f2b51c284555fc272c7ba28f46">&#9670;&nbsp;</a></span>getSkewY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::getSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the Y skew angle of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ac1f4c4be8099a0d4bca1464c51f81f94">setSkewY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Y skew angle of the node in degrees. </dd></dl>

</div>
</div>
<a id="a005a75fa3bd0937f475c0846692d232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005a75fa3bd0937f475c0846692d232f">&#9670;&nbsp;</a></span>getSkewY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float Node::getSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the Y skew angle of the node in degrees.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ac1f4c4be8099a0d4bca1464c51f81f94">setSkewY(float)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Y skew angle of the node in degrees. </dd></dl>

</div>
</div>
<a id="a9f18b6db8146f2660e8761bb9557d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f18b6db8146f2660e8761bb9557d1fe">&#9670;&nbsp;</a></span>getTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Node::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tag getter </p>
<p>Returns a tag that is used to identify the node easily.</p>
<dl class="section return"><dt>Returns</dt><dd>An integer that identifies the node.</dd></dl>
<p>Please use <code><a class="el" href="classNode.html#a9f18b6db8146f2660e8761bb9557d1fe" title="tag getter ">getTag()</a></code> instead. </p>

</div>
</div>
<a id="ac148c44055cf3d6344326b5bbb3ccd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148c44055cf3d6344326b5bbb3ccd26">&#9670;&nbsp;</a></span>getTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Node::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a tag that is used to identify the node easily.</p>
<dl class="section return"><dt>Returns</dt><dd>An integer that identifies the node.</dd></dl>
<p>Please use <code><a class="el" href="classNode.html#a9f18b6db8146f2660e8761bb9557d1fe" title="tag getter ">getTag()</a></code> instead. </p>

</div>
</div>
<a id="afeacb9cc8c8730d3ee8359ef42d5318d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeacb9cc8c8730d3ee8359ef42d5318d">&#9670;&nbsp;</a></span>getUserData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* Node::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a custom user data pointer.</p>
<p>You can set everything in UserData pointer, a data block, a structure or an object.</p>
<dl class="section return"><dt>Returns</dt><dd>A custom user data pointer.  NA </dd></dl>

</div>
</div>
<a id="a8f7eb64c4811677bc4ea83562981caf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7eb64c4811677bc4ea83562981caf6">&#9670;&nbsp;</a></span>getUserData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* Node::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA </p>

</div>
</div>
<a id="afeacb9cc8c8730d3ee8359ef42d5318d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeacb9cc8c8730d3ee8359ef42d5318d">&#9670;&nbsp;</a></span>getUserData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* Node::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a custom user data pointer.</p>
<p>You can set everything in UserData pointer, a data block, a structure or an object.</p>
<dl class="section return"><dt>Returns</dt><dd>A custom user data pointer.  NA </dd></dl>

</div>
</div>
<a id="a8f7eb64c4811677bc4ea83562981caf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7eb64c4811677bc4ea83562981caf6">&#9670;&nbsp;</a></span>getUserData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* Node::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA </p>

</div>
</div>
<a id="a246218e1f2be9fc931be00c9c42a7817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246218e1f2be9fc931be00c9c42a7817">&#9670;&nbsp;</a></span>getUserObject() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRef.html">Ref</a>* Node::getUserObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a user assigned Object.</p>
<p>Similar to userData, but instead of holding a void* it holds an object.</p>
<dl class="section return"><dt>Returns</dt><dd>A user assigned Object.  NA </dd></dl>

</div>
</div>
<a id="a6bc05a48edd6e805bbe970fd62a4a48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc05a48edd6e805bbe970fd62a4a48d">&#9670;&nbsp;</a></span>getUserObject() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRef.html">Ref</a>* Node::getUserObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA </p>

</div>
</div>
<a id="a246218e1f2be9fc931be00c9c42a7817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246218e1f2be9fc931be00c9c42a7817">&#9670;&nbsp;</a></span>getUserObject() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRef.html">Ref</a>* Node::getUserObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a user assigned Object.</p>
<p>Similar to userData, but instead of holding a void* it holds an object.</p>
<dl class="section return"><dt>Returns</dt><dd>A user assigned Object.  NA </dd></dl>

</div>
</div>
<a id="a6bc05a48edd6e805bbe970fd62a4a48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc05a48edd6e805bbe970fd62a4a48d">&#9670;&nbsp;</a></span>getUserObject() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRef.html">Ref</a>* Node::getUserObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA </p>

</div>
</div>
<a id="ab41da5111de6d98710d0497e35063989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41da5111de6d98710d0497e35063989">&#9670;&nbsp;</a></span>getWorldToNodeTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMat4.html">Mat4</a> Node::getWorldToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the inverse world affine transform matrix. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a566ef52d5a8c5f036322a4fb5f63c668">AttachNode</a>, and <a class="el" href="classAttachNode.html#a983b98880a9e8b42dcf78720f4fae50e">AttachNode</a>.</p>

</div>
</div>
<a id="a2128a1876b3f14c6270bbf0a9010a572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2128a1876b3f14c6270bbf0a9010a572">&#9670;&nbsp;</a></span>getWorldToNodeTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMat4.html">Mat4</a> Node::getWorldToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the inverse world affine transform matrix. The matrix is in Pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

<p>Reimplemented in <a class="el" href="classAttachNode.html#a566ef52d5a8c5f036322a4fb5f63c668">AttachNode</a>, and <a class="el" href="classAttachNode.html#a983b98880a9e8b42dcf78720f4fae50e">AttachNode</a>.</p>

</div>
</div>
<a id="abf874f1b388e773ca80732b1134508be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf874f1b388e773ca80732b1134508be">&#9670;&nbsp;</a></span>isCascadeColorEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isCascadeColorEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether cascadeColor is enabled or not. </p><dl class="section return"><dt>Returns</dt><dd>Whether cascadeColor is enabled or not. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a24f2ae00f1994d6601ce8e1f089dafe1">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a24f2ae00f1994d6601ce8e1f089dafe1">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#abc02efad9eb89df47e6a0365dc9c784e">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#abc02efad9eb89df47e6a0365dc9c784e">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a4ade1991e3cff2c032d50fc7f7392764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ade1991e3cff2c032d50fc7f7392764">&#9670;&nbsp;</a></span>isCascadeColorEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isCascadeColorEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether cascadeColor is enabled or not. </p><dl class="section return"><dt>Returns</dt><dd>Whether cascadeColor is enabled or not. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a24f2ae00f1994d6601ce8e1f089dafe1">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a24f2ae00f1994d6601ce8e1f089dafe1">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#abc02efad9eb89df47e6a0365dc9c784e">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#abc02efad9eb89df47e6a0365dc9c784e">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a79f5da3b20b08356467db7ce95cf9f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f5da3b20b08356467db7ce95cf9f54">&#9670;&nbsp;</a></span>isCascadeOpacityEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isCascadeOpacityEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether cascadeOpacity is enabled or not. </p><dl class="section return"><dt>Returns</dt><dd>A boolean value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a421ef9c26c9860deb23184727d573415">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a421ef9c26c9860deb23184727d573415">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a3dd348cf39ca267d7c0ebb5000dce45e">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a3dd348cf39ca267d7c0ebb5000dce45e">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a9d78071b3146583829431d79ffc6ae08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d78071b3146583829431d79ffc6ae08">&#9670;&nbsp;</a></span>isCascadeOpacityEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isCascadeOpacityEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether cascadeOpacity is enabled or not. </p><dl class="section return"><dt>Returns</dt><dd>A boolean value. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a421ef9c26c9860deb23184727d573415">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a421ef9c26c9860deb23184727d573415">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a3dd348cf39ca267d7c0ebb5000dce45e">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a3dd348cf39ca267d7c0ebb5000dce45e">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a1997a39d72ed74207a8ff7b5fe921be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1997a39d72ed74207a8ff7b5fe921be9">&#9670;&nbsp;</a></span>isIgnoreAnchorPointForPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isIgnoreAnchorPointForPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isRelativeAnchorPoint getter </p>
<p>Gets whether the anchor point will be (0,0) when you position this node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a75e8f6a6a46358d6faf8683e720d47b5" title="isRelativeAnchorPoint setter ">setIgnoreAnchorPointForPosition(bool)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the anchor point will be (0,0) when you position this node. </dd></dl>

</div>
</div>
<a id="a083fb03ef1904b0b0d4bc12c40a23f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083fb03ef1904b0b0d4bc12c40a23f5c">&#9670;&nbsp;</a></span>isIgnoreAnchorPointForPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isIgnoreAnchorPointForPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets whether the anchor point will be (0,0) when you position this node.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a75e8f6a6a46358d6faf8683e720d47b5" title="isRelativeAnchorPoint setter ">setIgnoreAnchorPointForPosition(bool)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the anchor point will be (0,0) when you position this node. </dd></dl>

</div>
</div>
<a id="ae6ce32d2088e2bb3426608334f1091c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ce32d2088e2bb3426608334f1091c5">&#9670;&nbsp;</a></span>isOpacityModifyRGB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If node opacity will modify the RGB color value, then you should override this method and return true. </p><dl class="section return"><dt>Returns</dt><dd>A boolean value, true indicates that opacity will modify color; false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a60d28606b0a253ad511df43a868fa08c">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a60d28606b0a253ad511df43a868fa08c">__NodeRGBA</a>, <a class="el" href="classParticleSystem.html#a36df0682b59803de36c914ce2bffe47d">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a36df0682b59803de36c914ce2bffe47d">ParticleSystem</a>, <a class="el" href="classLabel.html#ade8bf273e99add4d4861697d469f6d89">Label</a>, <a class="el" href="classLabel.html#ade8bf273e99add4d4861697d469f6d89">Label</a>, <a class="el" href="classSprite.html#af25cfe5f1f6178f5a13db86a258848d0">Sprite</a>, <a class="el" href="classSprite.html#a00d162b3e55fc5acd56e5c3e48bc0a97">Sprite</a>, <a class="el" href="class____LayerRGBA.html#a014dba2472f2708ad4493e97ca5999b0">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a014dba2472f2708ad4493e97ca5999b0">__LayerRGBA</a>, <a class="el" href="classMenu.html#a94211ecf8dd3edeed2e5d54f63ae90b9">Menu</a>, <a class="el" href="classControl.html#ac49bc0859aade4ad1ab6311941b4207a">Control</a>, <a class="el" href="classMenu.html#ae173fda432df51ec761c8ef5d96ea59a">Menu</a>, <a class="el" href="classControl.html#af7a191cace0c56d1dae182716c0e8150">Control</a>, <a class="el" href="classMotionStreak.html#a74c2b98555067ccd7d069273f9569aba">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a9cadee9d318c3bbc1e299563e0ce8d97">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a5de4e2e686f06acfecf86fc7b7caed6e">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a6b513fcdb7b462e2a28bb67e3dd35836">MotionStreak3D</a>, <a class="el" href="classAtlasNode.html#ad7d0c0a791719739d15e4f07c75f6704">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a3aa161e8abaff7422b7f9ef895f9439d">AtlasNode</a>.</p>

</div>
</div>
<a id="af7bb22bd30b2ab6f1534518db6895b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bb22bd30b2ab6f1534518db6895b87">&#9670;&nbsp;</a></span>isOpacityModifyRGB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If node opacity will modify the RGB color value, then you should override this method and return true. </p><dl class="section return"><dt>Returns</dt><dd>A boolean value, true indicates that opacity will modify color; false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a60d28606b0a253ad511df43a868fa08c">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a60d28606b0a253ad511df43a868fa08c">__NodeRGBA</a>, <a class="el" href="classParticleSystem.html#a36df0682b59803de36c914ce2bffe47d">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a36df0682b59803de36c914ce2bffe47d">ParticleSystem</a>, <a class="el" href="classLabel.html#ade8bf273e99add4d4861697d469f6d89">Label</a>, <a class="el" href="classLabel.html#ade8bf273e99add4d4861697d469f6d89">Label</a>, <a class="el" href="classSprite.html#af25cfe5f1f6178f5a13db86a258848d0">Sprite</a>, <a class="el" href="classSprite.html#a00d162b3e55fc5acd56e5c3e48bc0a97">Sprite</a>, <a class="el" href="class____LayerRGBA.html#a014dba2472f2708ad4493e97ca5999b0">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a014dba2472f2708ad4493e97ca5999b0">__LayerRGBA</a>, <a class="el" href="classMenu.html#a94211ecf8dd3edeed2e5d54f63ae90b9">Menu</a>, <a class="el" href="classControl.html#ac49bc0859aade4ad1ab6311941b4207a">Control</a>, <a class="el" href="classMenu.html#ae173fda432df51ec761c8ef5d96ea59a">Menu</a>, <a class="el" href="classControl.html#af7a191cace0c56d1dae182716c0e8150">Control</a>, <a class="el" href="classMotionStreak.html#a74c2b98555067ccd7d069273f9569aba">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a9cadee9d318c3bbc1e299563e0ce8d97">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a5de4e2e686f06acfecf86fc7b7caed6e">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a6b513fcdb7b462e2a28bb67e3dd35836">MotionStreak3D</a>, <a class="el" href="classAtlasNode.html#ad7d0c0a791719739d15e4f07c75f6704">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a3aa161e8abaff7422b7f9ef895f9439d">AtlasNode</a>.</p>

</div>
</div>
<a id="aebd879ffa85ad31896051073e1d7a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd879ffa85ad31896051073e1d7a6d8">&#9670;&nbsp;</a></span>isRunning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the node is "running".</p>
<p>If the node is running it will accept event callbacks like <a class="el" href="classNode.html#a7f51764c4afd5018a052b9ef71c03374">onEnter()</a>, <a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">onExit()</a>, <a class="el" href="classNode.html#a32878481ba54b3856ab53c10af13848e">update()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the node is running. </dd></dl>

</div>
</div>
<a id="af5dc885c0dbeceaa3857b52dff68ed4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc885c0dbeceaa3857b52dff68ed4b">&#9670;&nbsp;</a></span>isRunning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the node is "running".</p>
<p>If the node is running it will accept event callbacks like <a class="el" href="classNode.html#a7f51764c4afd5018a052b9ef71c03374">onEnter()</a>, <a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">onExit()</a>, <a class="el" href="classNode.html#a32878481ba54b3856ab53c10af13848e">update()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the node is running. </dd></dl>

</div>
</div>
<a id="ab9a193072ebab587d1932d8af52050e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a193072ebab587d1932d8af52050e0">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isScheduled </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a selector is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the function selector is scheduled.  NA  NA </dd></dl>

</div>
</div>
<a id="a335b7157808d2c0a38b4de04382749f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335b7157808d2c0a38b4de04382749f5">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a lambda function is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the lambda function selector is scheduled.  NA  NA </dd></dl>

</div>
</div>
<a id="a9b7c1b3796a8de31f3a9a962261f7c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c1b3796a8de31f3a9a962261f7c7e">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isScheduled </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a selector is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the function selector is scheduled.  NA  NA </dd></dl>

</div>
</div>
<a id="a4c3c2f91272c93216d2122848078e574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3c2f91272c93216d2122848078e574">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a lambda function is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the lambda function selector is scheduled.  NA  NA </dd></dl>

</div>
</div>
<a id="accff189524c62c6cb446cc19e3a79ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accff189524c62c6cb446cc19e3a79ab4">&#9670;&nbsp;</a></span>isVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isVisible getter </p>
<p>Determines if the node is visible.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ad8d9f6f838941a2a8ae18420757af158" title="isVisible setter ">setVisible(bool)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is visible, false if the node is hidden. </dd></dl>

<p>Reimplemented in <a class="el" href="classLabelLetter.html#a9f7187e6902a7b2a80ac3d2c5fc10523">LabelLetter</a>.</p>

</div>
</div>
<a id="a2595262a2b597f9d254ba6cfdae713c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2595262a2b597f9d254ba6cfdae713c0">&#9670;&nbsp;</a></span>isVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the node is visible.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ad8d9f6f838941a2a8ae18420757af158" title="isVisible setter ">setVisible(bool)</a></code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is visible, false if the node is hidden. </dd></dl>

<p>Reimplemented in <a class="el" href="classLabelLetter.html#a9f7187e6902a7b2a80ac3d2c5fc10523">LabelLetter</a>.</p>

</div>
</div>
<a id="ab242ac36f0e26f5ef1f89e4a5fa4f02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab242ac36f0e26f5ef1f89e4a5fa4f02c">&#9670;&nbsp;</a></span>nodeToParentTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::nodeToParentTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>use <a class="el" href="classNode.html#a7235b4a4d449fb7e01459c5c3b24d1eb">getNodeToParentTransform()</a> instead </dd></dl>

</div>
</div>
<a id="ab242ac36f0e26f5ef1f89e4a5fa4f02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab242ac36f0e26f5ef1f89e4a5fa4f02c">&#9670;&nbsp;</a></span>nodeToParentTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::nodeToParentTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000263">Deprecated:</a></b></dt><dd>use <a class="el" href="classNode.html#a7235b4a4d449fb7e01459c5c3b24d1eb">getNodeToParentTransform()</a> instead </dd></dl>

</div>
</div>
<a id="a26eeb65a02646d8bbe366c9885893a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eeb65a02646d8bbe366c9885893a75">&#9670;&nbsp;</a></span>nodeToWorldTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::nodeToWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a1e46065101d0d5dba32262067d85bf23">getNodeToWorldTransform()</a> instead </dd></dl>

</div>
</div>
<a id="a26eeb65a02646d8bbe366c9885893a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eeb65a02646d8bbe366c9885893a75">&#9670;&nbsp;</a></span>nodeToWorldTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::nodeToWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000265">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a1e46065101d0d5dba32262067d85bf23">getNodeToWorldTransform()</a> instead </dd></dl>

</div>
</div>
<a id="a7724086be31eda53304e6c9715f6fd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7724086be31eda53304e6c9715f6fd21">&#9670;&nbsp;</a></span>numberOfRunningActions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE ssize_t Node::numberOfRunningActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a576446fef9c35a1a06535eb8949df2f3">getNumberOfRunningActions()</a> instead </dd></dl>

</div>
</div>
<a id="a7724086be31eda53304e6c9715f6fd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7724086be31eda53304e6c9715f6fd21">&#9670;&nbsp;</a></span>numberOfRunningActions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE ssize_t Node::numberOfRunningActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000262">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a576446fef9c35a1a06535eb8949df2f3">getNumberOfRunningActions()</a> instead </dd></dl>

</div>
</div>
<a id="a7f51764c4afd5018a052b9ef71c03374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f51764c4afd5018a052b9ef71c03374">&#9670;&nbsp;</a></span>onEnter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::onEnter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked every time when <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage' with a transition, this event is called when the transition starts. During onEnter you can't access a "sister/brother" node. If you override onEnter, you shall call its parent's one, e.g., <a class="el" href="classNode.html#a7f51764c4afd5018a052b9ef71c03374">Node::onEnter()</a>.  NA </p>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a0233b4bea549912854460a1a969f8bb4">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#aff4ebcd832386860100daad82ad48bc2">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#abcf9feef35de88cbc529d3a134f7f098">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#ad172cf3e4da16ebf82ca1efbaaaacdc1">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#aa32c923595c2e6c212c16f07958cc72b">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#ae0dc8ca8038400db02d3ed87a594481a">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#acd2958371059f6a1accb7ad12645090a">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a453757b830ce0be18bc27ded6634d949">TransitionCrossFade</a>, <a class="el" href="classTransitionFade.html#a2fadd05a4c0d74b34b1530c7d7f07255">TransitionFade</a>, <a class="el" href="classTransitionFade.html#aaeb601022c4d71c24e333fe1807f88d4">TransitionFade</a>, <a class="el" href="classParticleSystem.html#a8bd3174194f57eb26d0e1348c1067e75">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a0bf785c1b1b386e0175fd01405072ab3">ParticleSystem</a>, <a class="el" href="classTransitionZoomFlipAngular.html#aacb744aa3be41964b84c4413472cb456">TransitionZoomFlipAngular</a>, <a class="el" href="classTransitionZoomFlipAngular.html#aabb32c716e6bcc7d75b1ac65e2b4d577">TransitionZoomFlipAngular</a>, <a class="el" href="classTransitionZoomFlipY.html#a0a91781c926ef8dd5942897c599dc961">TransitionZoomFlipY</a>, <a class="el" href="classTransitionZoomFlipY.html#a6909fa709a95fbd9b3556399ee00c215">TransitionZoomFlipY</a>, <a class="el" href="classui_1_1Widget.html#a1df4415ad57003db87a5e9b069b56956">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#a9cda9b9ffbf77a8ed695e6b97b9a46cc">ui::Widget</a>, <a class="el" href="classTransitionZoomFlipX.html#a7f853a4b72233504d0947458408ac75c">TransitionZoomFlipX</a>, <a class="el" href="classTransitionZoomFlipX.html#a4a321886abfa6785e4a8b9e955791562">TransitionZoomFlipX</a>, <a class="el" href="classui_1_1EditBox.html#a0506cfa2b498d2bcd24c4b85deff123d">ui::EditBox</a>, <a class="el" href="classTransitionFlipAngular.html#a146fb601d0d9dfabbe0a833f6d08c58b">TransitionFlipAngular</a>, <a class="el" href="classTransitionFlipAngular.html#af9318ac2862656fa0853c2457994066f">TransitionFlipAngular</a>, <a class="el" href="classui_1_1TextField.html#a8798bcf6c7f3540b7c078338386c04a3">ui::TextField</a>, <a class="el" href="classui_1_1TextField.html#ad7a8241c7d1a80bc8821e67044ffa20c">ui::TextField</a>, <a class="el" href="classTransitionFlipY.html#a55d7608988c869dc431bf2cff7601aaa">TransitionFlipY</a>, <a class="el" href="classui_1_1ScrollView.html#afeb85b1cf1e420b57a66c97c08763138">ui::ScrollView</a>, <a class="el" href="classTransitionFlipY.html#a51bbed9d1827d77df16747731fe17e00">TransitionFlipY</a>, <a class="el" href="classui_1_1ScrollView.html#a1fb1c9ad9108d8c0102af82bfb7ef66d">ui::ScrollView</a>, <a class="el" href="classTransitionFlipX.html#abe704195ebf90a0adb19bd54446f977b">TransitionFlipX</a>, <a class="el" href="classTransitionFlipX.html#a736da7551a598a7f71167870f63a06d4">TransitionFlipX</a>, <a class="el" href="classTransitionShrinkGrow.html#af22969e16b81f0880e5ef6c768c88961">TransitionShrinkGrow</a>, <a class="el" href="classTransitionShrinkGrow.html#a7ae52d07e1889121b706fbc6b1e7b6ff">TransitionShrinkGrow</a>, <a class="el" href="classTerrain.html#a1d3c0deb9503e340a9818c8cf8c61923">Terrain</a>, <a class="el" href="classTerrain.html#a464acea156d7aca981b7b459708f7d16">Terrain</a>, <a class="el" href="classui_1_1EditBox.html#a04667a919ce4f36fefb7605215267b28">ui::EditBox</a>, <a class="el" href="classui_1_1Layout.html#ad3edf411791596999e99059861c0097a">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a13b57bb4cec0d694e8053c393499d8b2">ui::Layout</a>, <a class="el" href="classTransitionSlideInL.html#a73601109845268099d90b12808de6b40">TransitionSlideInL</a>, <a class="el" href="classTransitionSlideInL.html#a6dcdddd697019eb9907e6df4a205da98">TransitionSlideInL</a>, <a class="el" href="classTransitionMoveInL.html#a4cf29668bcdd420cebb6135f80dd81f8">TransitionMoveInL</a>, <a class="el" href="classTransitionMoveInL.html#a790048ed6247fef9cefd40f39b53d3d5">TransitionMoveInL</a>, <a class="el" href="classCamera.html#af22f3064a50c98832f448d7167a1f3cd">Camera</a>, <a class="el" href="classCamera.html#a6d316bcfec816212b0f3cfdf1b41b820">Camera</a>, <a class="el" href="classTransitionJumpZoom.html#a06952f1bbf702804d28bda0923d9ca31">TransitionJumpZoom</a>, <a class="el" href="classTransitionJumpZoom.html#aa57e87e6adf5e62f533d5478fdd6155e">TransitionJumpZoom</a>, <a class="el" href="classTransitionRotoZoom.html#ac996aa76e096939509fda8a3468fc113">TransitionRotoZoom</a>, <a class="el" href="classTransitionRotoZoom.html#a087ead50631d8e2fdf62f7fd6c265caa">TransitionRotoZoom</a>, <a class="el" href="classMenu.html#ac0b9006b091056c9e8c139eb653cc773">Menu</a>, <a class="el" href="classMenu.html#ab8c3b9d5d26f512be8f26e5e2f5bda1e">Menu</a>, <a class="el" href="classProtectedNode.html#a3f321c087261805fe0ca95fe71109b41">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ade991090bee4173b4e1f47382adc99b9">ProtectedNode</a>, <a class="el" href="classScene.html#a0f685cac49f90456c69f1b03aa5c8674">Scene</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a7f0ab392ce00fa9dbb9db54dfbe01e4a">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a6cf525ed1ead2a5b8e45de981bf2d0c1">ui::ScrollViewBar</a>, <a class="el" href="classClippingNode.html#a7b66e61be66f46e9ae206ecd1a3ba074">ClippingNode</a>, <a class="el" href="classClippingNode.html#abf21272a53da13366c78ec704f0e0cd3">ClippingNode</a>, <a class="el" href="classTransitionScene.html#a9093cbd324910ea7c9e3955317f7b661">TransitionScene</a>, <a class="el" href="classTransitionScene.html#aace390a1bd8f3c73bb650a1e256a0f83">TransitionScene</a>, <a class="el" href="classTransitionPageTurn.html#adb15cf19b760250156d6fa3f2e1dbf31">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a451cf478d1f344678dde975e0db39b46">TransitionPageTurn</a>, <a class="el" href="classBaseLight.html#ae53451e8579dce26537726a634fc81f5">BaseLight</a>, <a class="el" href="classBaseLight.html#a76470def8a65956abdb17b3d71c1a7a0">BaseLight</a>, <a class="el" href="classui_1_1UICCTextField.html#ab4689762548b34a3309d8679b3add550">ui::UICCTextField</a>, <a class="el" href="classTransitionProgress.html#aa3ccb7515691f10b5410b75d912e2b68">TransitionProgress</a>, <a class="el" href="classTransitionProgress.html#a4bb6172fb74abe0a0a0de2a3742a9cf6">TransitionProgress</a>, and <a class="el" href="classui_1_1UICCTextField.html#ad74c8dfb537f983d2540af7c5b9cb307">ui::UICCTextField</a>.</p>

</div>
</div>
<a id="adde49eb69aebd860d7b95bf484cd96f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde49eb69aebd860d7b95bf484cd96f3">&#9670;&nbsp;</a></span>onEnter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::onEnter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked every time when <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage' with a transition, this event is called when the transition starts. During onEnter you can't access a "sister/brother" node. If you override onEnter, you shall call its parent's one, e.g., <a class="el" href="classNode.html#a7f51764c4afd5018a052b9ef71c03374">Node::onEnter()</a>.  NA </p>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a0233b4bea549912854460a1a969f8bb4">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#aff4ebcd832386860100daad82ad48bc2">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#abcf9feef35de88cbc529d3a134f7f098">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#ad172cf3e4da16ebf82ca1efbaaaacdc1">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#aa32c923595c2e6c212c16f07958cc72b">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#ae0dc8ca8038400db02d3ed87a594481a">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#acd2958371059f6a1accb7ad12645090a">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a453757b830ce0be18bc27ded6634d949">TransitionCrossFade</a>, <a class="el" href="classTransitionFade.html#a2fadd05a4c0d74b34b1530c7d7f07255">TransitionFade</a>, <a class="el" href="classTransitionFade.html#aaeb601022c4d71c24e333fe1807f88d4">TransitionFade</a>, <a class="el" href="classParticleSystem.html#a8bd3174194f57eb26d0e1348c1067e75">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a0bf785c1b1b386e0175fd01405072ab3">ParticleSystem</a>, <a class="el" href="classTransitionZoomFlipAngular.html#aacb744aa3be41964b84c4413472cb456">TransitionZoomFlipAngular</a>, <a class="el" href="classTransitionZoomFlipAngular.html#aabb32c716e6bcc7d75b1ac65e2b4d577">TransitionZoomFlipAngular</a>, <a class="el" href="classTransitionZoomFlipY.html#a0a91781c926ef8dd5942897c599dc961">TransitionZoomFlipY</a>, <a class="el" href="classTransitionZoomFlipY.html#a6909fa709a95fbd9b3556399ee00c215">TransitionZoomFlipY</a>, <a class="el" href="classui_1_1Widget.html#a1df4415ad57003db87a5e9b069b56956">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#a9cda9b9ffbf77a8ed695e6b97b9a46cc">ui::Widget</a>, <a class="el" href="classTransitionZoomFlipX.html#a7f853a4b72233504d0947458408ac75c">TransitionZoomFlipX</a>, <a class="el" href="classTransitionZoomFlipX.html#a4a321886abfa6785e4a8b9e955791562">TransitionZoomFlipX</a>, <a class="el" href="classui_1_1EditBox.html#a0506cfa2b498d2bcd24c4b85deff123d">ui::EditBox</a>, <a class="el" href="classTransitionFlipAngular.html#a146fb601d0d9dfabbe0a833f6d08c58b">TransitionFlipAngular</a>, <a class="el" href="classTransitionFlipAngular.html#af9318ac2862656fa0853c2457994066f">TransitionFlipAngular</a>, <a class="el" href="classui_1_1TextField.html#a8798bcf6c7f3540b7c078338386c04a3">ui::TextField</a>, <a class="el" href="classui_1_1TextField.html#ad7a8241c7d1a80bc8821e67044ffa20c">ui::TextField</a>, <a class="el" href="classTransitionFlipY.html#a55d7608988c869dc431bf2cff7601aaa">TransitionFlipY</a>, <a class="el" href="classui_1_1ScrollView.html#afeb85b1cf1e420b57a66c97c08763138">ui::ScrollView</a>, <a class="el" href="classTransitionFlipY.html#a51bbed9d1827d77df16747731fe17e00">TransitionFlipY</a>, <a class="el" href="classui_1_1ScrollView.html#a1fb1c9ad9108d8c0102af82bfb7ef66d">ui::ScrollView</a>, <a class="el" href="classTransitionFlipX.html#abe704195ebf90a0adb19bd54446f977b">TransitionFlipX</a>, <a class="el" href="classTransitionFlipX.html#a736da7551a598a7f71167870f63a06d4">TransitionFlipX</a>, <a class="el" href="classTransitionShrinkGrow.html#af22969e16b81f0880e5ef6c768c88961">TransitionShrinkGrow</a>, <a class="el" href="classTransitionShrinkGrow.html#a7ae52d07e1889121b706fbc6b1e7b6ff">TransitionShrinkGrow</a>, <a class="el" href="classTerrain.html#a1d3c0deb9503e340a9818c8cf8c61923">Terrain</a>, <a class="el" href="classTerrain.html#a464acea156d7aca981b7b459708f7d16">Terrain</a>, <a class="el" href="classui_1_1EditBox.html#a04667a919ce4f36fefb7605215267b28">ui::EditBox</a>, <a class="el" href="classui_1_1Layout.html#ad3edf411791596999e99059861c0097a">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a13b57bb4cec0d694e8053c393499d8b2">ui::Layout</a>, <a class="el" href="classTransitionSlideInL.html#a73601109845268099d90b12808de6b40">TransitionSlideInL</a>, <a class="el" href="classTransitionSlideInL.html#a6dcdddd697019eb9907e6df4a205da98">TransitionSlideInL</a>, <a class="el" href="classTransitionMoveInL.html#a4cf29668bcdd420cebb6135f80dd81f8">TransitionMoveInL</a>, <a class="el" href="classTransitionMoveInL.html#a790048ed6247fef9cefd40f39b53d3d5">TransitionMoveInL</a>, <a class="el" href="classCamera.html#af22f3064a50c98832f448d7167a1f3cd">Camera</a>, <a class="el" href="classCamera.html#a6d316bcfec816212b0f3cfdf1b41b820">Camera</a>, <a class="el" href="classTransitionJumpZoom.html#a06952f1bbf702804d28bda0923d9ca31">TransitionJumpZoom</a>, <a class="el" href="classTransitionJumpZoom.html#aa57e87e6adf5e62f533d5478fdd6155e">TransitionJumpZoom</a>, <a class="el" href="classTransitionRotoZoom.html#ac996aa76e096939509fda8a3468fc113">TransitionRotoZoom</a>, <a class="el" href="classTransitionRotoZoom.html#a087ead50631d8e2fdf62f7fd6c265caa">TransitionRotoZoom</a>, <a class="el" href="classMenu.html#ac0b9006b091056c9e8c139eb653cc773">Menu</a>, <a class="el" href="classMenu.html#ab8c3b9d5d26f512be8f26e5e2f5bda1e">Menu</a>, <a class="el" href="classProtectedNode.html#a3f321c087261805fe0ca95fe71109b41">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ade991090bee4173b4e1f47382adc99b9">ProtectedNode</a>, <a class="el" href="classScene.html#a0f685cac49f90456c69f1b03aa5c8674">Scene</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a7f0ab392ce00fa9dbb9db54dfbe01e4a">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a6cf525ed1ead2a5b8e45de981bf2d0c1">ui::ScrollViewBar</a>, <a class="el" href="classClippingNode.html#a7b66e61be66f46e9ae206ecd1a3ba074">ClippingNode</a>, <a class="el" href="classClippingNode.html#abf21272a53da13366c78ec704f0e0cd3">ClippingNode</a>, <a class="el" href="classTransitionScene.html#a9093cbd324910ea7c9e3955317f7b661">TransitionScene</a>, <a class="el" href="classTransitionScene.html#aace390a1bd8f3c73bb650a1e256a0f83">TransitionScene</a>, <a class="el" href="classTransitionPageTurn.html#adb15cf19b760250156d6fa3f2e1dbf31">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a451cf478d1f344678dde975e0db39b46">TransitionPageTurn</a>, <a class="el" href="classBaseLight.html#ae53451e8579dce26537726a634fc81f5">BaseLight</a>, <a class="el" href="classBaseLight.html#a76470def8a65956abdb17b3d71c1a7a0">BaseLight</a>, <a class="el" href="classui_1_1UICCTextField.html#ab4689762548b34a3309d8679b3add550">ui::UICCTextField</a>, <a class="el" href="classTransitionProgress.html#aa3ccb7515691f10b5410b75d912e2b68">TransitionProgress</a>, <a class="el" href="classTransitionProgress.html#a4bb6172fb74abe0a0a0de2a3742a9cf6">TransitionProgress</a>, and <a class="el" href="classui_1_1UICCTextField.html#ad74c8dfb537f983d2540af7c5b9cb307">ui::UICCTextField</a>.</p>

</div>
</div>
<a id="afef4b2a863042a9ea456e952cf26991d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef4b2a863042a9ea456e952cf26991d">&#9670;&nbsp;</a></span>onEnterTransitionDidFinish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::onEnterTransitionDidFinish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked when the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters in the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage' with a transition, this event is called when the transition finishes. If you override onEnterTransitionDidFinish, you shall call its parent's one, e.g. <a class="el" href="classNode.html#afef4b2a863042a9ea456e952cf26991d">Node::onEnterTransitionDidFinish()</a>  NA </p>

<p>Reimplemented in <a class="el" href="classProtectedNode.html#aac8fcdaf79295aa56c9b792d2e4135d6">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ab424c044446f8c5cf2018e450c4df78c">ProtectedNode</a>, <a class="el" href="classClippingNode.html#ae083ddde34231495277586c7a8384262">ClippingNode</a>, and <a class="el" href="classClippingNode.html#a927d837090ada4bcdc8cedd40ef859f1">ClippingNode</a>.</p>

</div>
</div>
<a id="aa3a941a5ea551c52408a8f3df4a64e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a941a5ea551c52408a8f3df4a64e6f">&#9670;&nbsp;</a></span>onEnterTransitionDidFinish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::onEnterTransitionDidFinish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked when the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters in the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> enters the 'stage' with a transition, this event is called when the transition finishes. If you override onEnterTransitionDidFinish, you shall call its parent's one, e.g. <a class="el" href="classNode.html#afef4b2a863042a9ea456e952cf26991d">Node::onEnterTransitionDidFinish()</a>  NA </p>

<p>Reimplemented in <a class="el" href="classProtectedNode.html#aac8fcdaf79295aa56c9b792d2e4135d6">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ab424c044446f8c5cf2018e450c4df78c">ProtectedNode</a>, <a class="el" href="classClippingNode.html#ae083ddde34231495277586c7a8384262">ClippingNode</a>, and <a class="el" href="classClippingNode.html#a927d837090ada4bcdc8cedd40ef859f1">ClippingNode</a>.</p>

</div>
</div>
<a id="ac83de835ea315e3179d4293acd8903ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83de835ea315e3179d4293acd8903ac">&#9670;&nbsp;</a></span>onExit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::onExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked every time the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage' with a transition, this event is called when the transition finishes. During onExit you can't access a sibling node. If you override onExit, you shall call its parent's one, e.g., <a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">Node::onExit()</a>.  NA </p>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a9460b2272ddd276f68727429474b6862">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#a62a984bd87eb2090da0e542e5ce91cce">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#aaf1b4e4345002bda3404ae89e10d5fe1">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#af083146c10d56bb5342ae286c2967e67">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#a690a28870ab7e338aa4645134869f520">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#ad178c23408dd18b341e043ae5d645499">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#a18832603241957b4c6700b84b7b587e0">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a87aa5397c6cdba91bd477a9df1534730">TransitionCrossFade</a>, <a class="el" href="classTransitionFade.html#a84179a9a978c9ff2e302e913f7d90cc4">TransitionFade</a>, <a class="el" href="classTransitionFade.html#aa476da6459ad94c3fb3254a261fe3161">TransitionFade</a>, <a class="el" href="classParticleSystem.html#a98582a329312cfc77d39cc872d5c344c">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#ad4eb9130a81ad207669531f165ed6de8">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a541dd9c8492eeb30a2e50b97cc94bd6e">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#a91cbac90873d76b6edb0e41eed5477eb">ui::Widget</a>, <a class="el" href="classui_1_1EditBox.html#a4c5c9db7c8b7711a719aec6a0842696b">ui::EditBox</a>, <a class="el" href="classui_1_1ScrollView.html#a9c9bf9f6d171a618d57c369e53d91a25">ui::ScrollView</a>, <a class="el" href="classui_1_1EditBox.html#a4151e7abfe84c879cc89f683c4975285">ui::EditBox</a>, <a class="el" href="classui_1_1Layout.html#ad6be3b3eb4ca53dcbd3eb1ca966299ff">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a6444f3e3f124723e75f80b3d36408e34">ui::Layout</a>, <a class="el" href="classCamera.html#aff2efb18d2837f4c443666ae94993185">Camera</a>, <a class="el" href="classCamera.html#a21080d4de388ac7b9a02ccf77aaacf92">Camera</a>, <a class="el" href="classMenu.html#ac8aef4d0860df0ef9cb49382430bc72e">Menu</a>, <a class="el" href="classMenu.html#a247a5912b1bc6aacedcdb41324de391c">Menu</a>, <a class="el" href="classProtectedNode.html#a9f3d5d68659c662187089b18cc2dbda3">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ad3eed150eb7243f2de8b2e527752a3a6">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a7766b27739f9f11792908d6ca790bd92">ClippingNode</a>, <a class="el" href="classClippingNode.html#abbe7e15178005613c97b8c88dea6ce6c">ClippingNode</a>, <a class="el" href="classTransitionScene.html#a05f91bf82d41da86e4a12af07f8242e2">TransitionScene</a>, <a class="el" href="classTransitionScene.html#a45e39b658189c79428a05c3bc3173bbb">TransitionScene</a>, <a class="el" href="classTransitionPageTurn.html#adf4182d3e59e362c1ca5beec367d7bf9">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a5c53ecc8cf81db631e7af1c5fa12d942">TransitionPageTurn</a>, <a class="el" href="classBaseLight.html#ab2287f5f40ce71824cfb5577a0874b07">BaseLight</a>, <a class="el" href="classBaseLight.html#a4a38c4061703339cee94ebf523b453a0">BaseLight</a>, <a class="el" href="classTransitionProgress.html#a8682fe8c7c42a31c6796bff2e4e1fef5">TransitionProgress</a>, and <a class="el" href="classTransitionProgress.html#a19b22f6e9a1d4e48d1d4b61e17fec363">TransitionProgress</a>.</p>

</div>
</div>
<a id="ae97adc8e1de122017736546f33b01455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97adc8e1de122017736546f33b01455">&#9670;&nbsp;</a></span>onExit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::onExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is invoked every time the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage' with a transition, this event is called when the transition finishes. During onExit you can't access a sibling node. If you override onExit, you shall call its parent's one, e.g., <a class="el" href="classNode.html#ac83de835ea315e3179d4293acd8903ac">Node::onExit()</a>.  NA </p>

<p>Reimplemented in <a class="el" href="classTransitionFadeTR.html#a9460b2272ddd276f68727429474b6862">TransitionFadeTR</a>, <a class="el" href="classTransitionFadeTR.html#a62a984bd87eb2090da0e542e5ce91cce">TransitionFadeTR</a>, <a class="el" href="classTransitionSplitCols.html#aaf1b4e4345002bda3404ae89e10d5fe1">TransitionSplitCols</a>, <a class="el" href="classTransitionSplitCols.html#af083146c10d56bb5342ae286c2967e67">TransitionSplitCols</a>, <a class="el" href="classTransitionTurnOffTiles.html#a690a28870ab7e338aa4645134869f520">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionTurnOffTiles.html#ad178c23408dd18b341e043ae5d645499">TransitionTurnOffTiles</a>, <a class="el" href="classTransitionCrossFade.html#a18832603241957b4c6700b84b7b587e0">TransitionCrossFade</a>, <a class="el" href="classTransitionCrossFade.html#a87aa5397c6cdba91bd477a9df1534730">TransitionCrossFade</a>, <a class="el" href="classTransitionFade.html#a84179a9a978c9ff2e302e913f7d90cc4">TransitionFade</a>, <a class="el" href="classTransitionFade.html#aa476da6459ad94c3fb3254a261fe3161">TransitionFade</a>, <a class="el" href="classParticleSystem.html#a98582a329312cfc77d39cc872d5c344c">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#ad4eb9130a81ad207669531f165ed6de8">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a541dd9c8492eeb30a2e50b97cc94bd6e">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#a91cbac90873d76b6edb0e41eed5477eb">ui::Widget</a>, <a class="el" href="classui_1_1EditBox.html#a4c5c9db7c8b7711a719aec6a0842696b">ui::EditBox</a>, <a class="el" href="classui_1_1ScrollView.html#a9c9bf9f6d171a618d57c369e53d91a25">ui::ScrollView</a>, <a class="el" href="classui_1_1EditBox.html#a4151e7abfe84c879cc89f683c4975285">ui::EditBox</a>, <a class="el" href="classui_1_1Layout.html#ad6be3b3eb4ca53dcbd3eb1ca966299ff">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a6444f3e3f124723e75f80b3d36408e34">ui::Layout</a>, <a class="el" href="classCamera.html#aff2efb18d2837f4c443666ae94993185">Camera</a>, <a class="el" href="classCamera.html#a21080d4de388ac7b9a02ccf77aaacf92">Camera</a>, <a class="el" href="classMenu.html#ac8aef4d0860df0ef9cb49382430bc72e">Menu</a>, <a class="el" href="classMenu.html#a247a5912b1bc6aacedcdb41324de391c">Menu</a>, <a class="el" href="classProtectedNode.html#a9f3d5d68659c662187089b18cc2dbda3">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#ad3eed150eb7243f2de8b2e527752a3a6">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a7766b27739f9f11792908d6ca790bd92">ClippingNode</a>, <a class="el" href="classClippingNode.html#abbe7e15178005613c97b8c88dea6ce6c">ClippingNode</a>, <a class="el" href="classTransitionScene.html#a05f91bf82d41da86e4a12af07f8242e2">TransitionScene</a>, <a class="el" href="classTransitionScene.html#a45e39b658189c79428a05c3bc3173bbb">TransitionScene</a>, <a class="el" href="classTransitionPageTurn.html#adf4182d3e59e362c1ca5beec367d7bf9">TransitionPageTurn</a>, <a class="el" href="classTransitionPageTurn.html#a5c53ecc8cf81db631e7af1c5fa12d942">TransitionPageTurn</a>, <a class="el" href="classBaseLight.html#ab2287f5f40ce71824cfb5577a0874b07">BaseLight</a>, <a class="el" href="classBaseLight.html#a4a38c4061703339cee94ebf523b453a0">BaseLight</a>, <a class="el" href="classTransitionProgress.html#a8682fe8c7c42a31c6796bff2e4e1fef5">TransitionProgress</a>, and <a class="el" href="classTransitionProgress.html#a19b22f6e9a1d4e48d1d4b61e17fec363">TransitionProgress</a>.</p>

</div>
</div>
<a id="a11686054c0d2edd292a53aa9702aaece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11686054c0d2edd292a53aa9702aaece">&#9670;&nbsp;</a></span>onExitTransitionDidStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::onExitTransitionDidStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is called every time the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage' with a transition, this callback is called when the transition starts.  NA </p>

<p>Reimplemented in <a class="el" href="classProtectedNode.html#a3efa91524a31d8f0919be2db8af1ddc9">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a3f4bf0c9b9ec81b486f479d30fc1ed67">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a4637553a7b0ae136a1e9cb1684b3db57">ClippingNode</a>, and <a class="el" href="classClippingNode.html#ab45e60bbd0afe536e806f05a963dd512">ClippingNode</a>.</p>

</div>
</div>
<a id="a14c2a4fe52123f1e928041a961eb679d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2a4fe52123f1e928041a961eb679d">&#9670;&nbsp;</a></span>onExitTransitionDidStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::onExitTransitionDidStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classEvent.html" title="Base class of all kinds of events. ">Event</a> callback that is called every time the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage'. If the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a> leaves the 'stage' with a transition, this callback is called when the transition starts.  NA </p>

<p>Reimplemented in <a class="el" href="classProtectedNode.html#a3efa91524a31d8f0919be2db8af1ddc9">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a3f4bf0c9b9ec81b486f479d30fc1ed67">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a4637553a7b0ae136a1e9cb1684b3db57">ClippingNode</a>, and <a class="el" href="classClippingNode.html#ab45e60bbd0afe536e806f05a963dd512">ClippingNode</a>.</p>

</div>
</div>
<a id="af309d9c24935db52112193619f3cd790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af309d9c24935db52112193619f3cd790">&#9670;&nbsp;</a></span>parentToNodeTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::parentToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a12aae4242a85aa5acfc03c97a018b621">getParentToNodeTransform()</a> instead </dd></dl>

</div>
</div>
<a id="af309d9c24935db52112193619f3cd790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af309d9c24935db52112193619f3cd790">&#9670;&nbsp;</a></span>parentToNodeTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::parentToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000264">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#a12aae4242a85aa5acfc03c97a018b621">getParentToNodeTransform()</a> instead </dd></dl>

</div>
</div>
<a id="a1076a4b9c753597c2c719c27d629d855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1076a4b9c753597c2c719c27d629d855">&#9670;&nbsp;</a></span>pause() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::pause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pauses all scheduled selectors, actions and event listeners. This method is called internally by onExit. </p>

</div>
</div>
<a id="a2f262913d8d4f3f4ce386752b522208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f262913d8d4f3f4ce386752b522208f">&#9670;&nbsp;</a></span>pause() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::pause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pauses all scheduled selectors, actions and event listeners. This method is called internally by onExit. </p>

</div>
</div>
<a id="abda89d75f7614e3b7c3d17788a61813b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda89d75f7614e3b7c3d17788a61813b">&#9670;&nbsp;</a></span>pauseSchedulerAndActions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::pauseSchedulerAndActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses all scheduled selectors, actions and event listeners. This method is called internally by onExit. </p>

</div>
</div>
<a id="a7ff40b01310820986b26dd335ec19670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff40b01310820986b26dd335ec19670">&#9670;&nbsp;</a></span>pauseSchedulerAndActions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Node::pauseSchedulerAndActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses all scheduled selectors, actions and event listeners. This method is called internally by onExit. </p>

</div>
</div>
<a id="a0f6ef5518d2e5dd5be405e98b37ace4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ef5518d2e5dd5be405e98b37ace4a">&#9670;&nbsp;</a></span>removeAllChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from the container with a cleanup.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aca66e2b385c3dbf1a6f55627c4a13192">removeAllChildrenWithCleanup(bool)</a></code> </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Layout.html#ace8bad280eb1b1df51211cca73131530">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a6b40fa4ad7a14a1eece297e466e2c86e">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#aa036ed1712c78c6ee701eb94eea55091">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#aaef2d3ce7b1b7d485af4a3657bea17e5">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#acfa88e95692c1e9713697fbd2754379b">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a7e534825fe60406ed544a254b0975489">ui::ListView</a>, <a class="el" href="classScrollView.html#a6a3b9ea8f88bca7ad741b511de369f24">ScrollView</a>, <a class="el" href="classScrollView.html#aaef2d3ce7b1b7d485af4a3657bea17e5">ScrollView</a>, <a class="el" href="classScene.html#af55bdd0731d6ccfdd1c95c4011451adb">Scene</a>, and <a class="el" href="classScene.html#a7e54f25b14b057ab896b0ef3262cef86">Scene</a>.</p>

</div>
</div>
<a id="a4018ec946225eb3bc64a0bbd19cd4625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4018ec946225eb3bc64a0bbd19cd4625">&#9670;&nbsp;</a></span>removeAllChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from the container with a cleanup.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aca66e2b385c3dbf1a6f55627c4a13192">removeAllChildrenWithCleanup(bool)</a></code> </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Layout.html#ace8bad280eb1b1df51211cca73131530">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a6b40fa4ad7a14a1eece297e466e2c86e">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#aa036ed1712c78c6ee701eb94eea55091">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#aaef2d3ce7b1b7d485af4a3657bea17e5">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#acfa88e95692c1e9713697fbd2754379b">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a7e534825fe60406ed544a254b0975489">ui::ListView</a>, <a class="el" href="classScrollView.html#a6a3b9ea8f88bca7ad741b511de369f24">ScrollView</a>, <a class="el" href="classScrollView.html#aaef2d3ce7b1b7d485af4a3657bea17e5">ScrollView</a>, <a class="el" href="classScene.html#af55bdd0731d6ccfdd1c95c4011451adb">Scene</a>, and <a class="el" href="classScene.html#a7e54f25b14b057ab896b0ef3262cef86">Scene</a>.</p>

</div>
</div>
<a id="aca66e2b385c3dbf1a6f55627c4a13192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66e2b385c3dbf1a6f55627c4a13192">&#9670;&nbsp;</a></span>removeAllChildrenWithCleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeAllChildrenWithCleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>True if all running actions on all children nodes should be cleanup, false otherwise.  removeAllChildren  removeAllChildren </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a5ea31447a69e1a0974aee74ad9a072e2">Label</a>, <a class="el" href="classLabel.html#a085855ab76a711d7314ae6ae6ce44c47">Label</a>, <a class="el" href="classSprite.html#aaaf5e178d5fd88574b9803fe3fab94fa">Sprite</a>, <a class="el" href="classSprite.html#a10eb2d2ae7c326487850cd1fec42382c">Sprite</a>, <a class="el" href="classui_1_1Layout.html#a7dcfdbe18bfc9e55169e957597aa19ca">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a7c317fa2fc294158776962b9218304b9">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#ab72a5f9a41f99b6b8c41596bacdd116f">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#ac71d0fe89be6291abbccf6a6f8f011b4">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a04bcc9bd8c55dea8f034a8380b3ab3a8">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a01691c095058bc86f372e6439b15b151">ui::ListView</a>, <a class="el" href="classScrollView.html#a8b2cfd556bae69ffbd5ae3d5813d53e5">ScrollView</a>, <a class="el" href="classScrollView.html#ac71d0fe89be6291abbccf6a6f8f011b4">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#aef759fbb4337b71813e05bf91a0daae8">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a1b49c2764f43641c912c66c2d58b85a0">SpriteBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ac4875ff56dadd5f836d9b99a36201bb1">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ac4875ff56dadd5f836d9b99a36201bb1">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#acff596a0ad508105213baddf02cb05e8">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#aa3b4fa198c648421759a8500d2e8d97a">ParallaxNode</a>.</p>

</div>
</div>
<a id="a0e179356e2ffbff60f02149b35edacc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e179356e2ffbff60f02149b35edacc1">&#9670;&nbsp;</a></span>removeAllChildrenWithCleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeAllChildrenWithCleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>True if all running actions on all children nodes should be cleanup, false otherwise.  removeAllChildren  removeAllChildren </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a5ea31447a69e1a0974aee74ad9a072e2">Label</a>, <a class="el" href="classLabel.html#a085855ab76a711d7314ae6ae6ce44c47">Label</a>, <a class="el" href="classSprite.html#aaaf5e178d5fd88574b9803fe3fab94fa">Sprite</a>, <a class="el" href="classSprite.html#a10eb2d2ae7c326487850cd1fec42382c">Sprite</a>, <a class="el" href="classui_1_1Layout.html#a7dcfdbe18bfc9e55169e957597aa19ca">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a7c317fa2fc294158776962b9218304b9">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#ab72a5f9a41f99b6b8c41596bacdd116f">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#ac71d0fe89be6291abbccf6a6f8f011b4">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#a04bcc9bd8c55dea8f034a8380b3ab3a8">ui::ListView</a>, <a class="el" href="classui_1_1ListView.html#a01691c095058bc86f372e6439b15b151">ui::ListView</a>, <a class="el" href="classScrollView.html#a8b2cfd556bae69ffbd5ae3d5813d53e5">ScrollView</a>, <a class="el" href="classScrollView.html#ac71d0fe89be6291abbccf6a6f8f011b4">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#aef759fbb4337b71813e05bf91a0daae8">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a1b49c2764f43641c912c66c2d58b85a0">SpriteBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ac4875ff56dadd5f836d9b99a36201bb1">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ac4875ff56dadd5f836d9b99a36201bb1">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#acff596a0ad508105213baddf02cb05e8">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#aa3b4fa198c648421759a8500d2e8d97a">ParallaxNode</a>.</p>

</div>
</div>
<a id="a6c5d3cf6a590df570cac7ddbfe85c9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5d3cf6a590df570cac7ddbfe85c9d3">&#9670;&nbsp;</a></span>removeAllComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeAllComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all components </p>

</div>
</div>
<a id="a4b776f7b64fc5d0fd32280eabf5c3a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b776f7b64fc5d0fd32280eabf5c3a71">&#9670;&nbsp;</a></span>removeAllComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeAllComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all components </p>

</div>
</div>
<a id="a872d4a7d389b26b0c6ad7ed99c8b1b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872d4a7d389b26b0c6ad7ed99c8b1b65">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#adbd0b3a732d798e37ee50faa99453647">Label</a>, <a class="el" href="classLabel.html#a2fc940a01f34e1ea809bb09e1f82575f">Label</a>, <a class="el" href="classSprite.html#a84cbb6f523e114e8d5c5767ec7796111">Sprite</a>, <a class="el" href="classSprite.html#a64aee8360870f15193ad46565565a0f2">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#ae3b50790cd7fa0feeacc9204fe86fc1a">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#a3a391ace9855a825523cdc882c271abe">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a13d675c669b6b926956baf484ce0857a">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a678108e716966e8beccc25c0de1d9b29">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#ace4890246e03a8de66cfe9d0312df365">ui::ListView</a>, <a class="el" href="classTMXLayer.html#abaf25490e1f7807816c07167a8d4af46">TMXLayer</a>, <a class="el" href="classTMXLayer.html#abaf25490e1f7807816c07167a8d4af46">TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a13544208580495a457a7ec1f2da9a4d1">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#ade60657de43636151aef237010b2965b">experimental::TMXLayer</a>, <a class="el" href="classui_1_1ListView.html#a7002fe4ad783aeccf56cebbe4144036e">ui::ListView</a>, <a class="el" href="classScrollView.html#a10009c987a878297cabe629369142972">ScrollView</a>, <a class="el" href="classScrollView.html#a678108e716966e8beccc25c0de1d9b29">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#a918786ec36ffac4169444d478e455c5c">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a7bebdfd28805ed83d0a78b49f8b52803">SpriteBatchNode</a>, <a class="el" href="classMenu.html#ab08cab6e153f4d7fabf06cbc941c8c58">Menu</a>, <a class="el" href="classMenu.html#a671c3f506ddcf0532144056289721540">Menu</a>, <a class="el" href="classParticleBatchNode.html#a384b404f2f29463180517528f6f350dc">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a44ecab9f55fdf0196cb40fd39781bea6">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a0ce03b1f03d63885b0ffae5a17662f45">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#ae7a8f0dc0855dd89ac16bc4bd3f55621">ParallaxNode</a>.</p>

</div>
</div>
<a id="ae2e85ab2de9e93e3998a40df1b4b61fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e85ab2de9e93e3998a40df1b4b61fc">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#adbd0b3a732d798e37ee50faa99453647">Label</a>, <a class="el" href="classLabel.html#a2fc940a01f34e1ea809bb09e1f82575f">Label</a>, <a class="el" href="classSprite.html#a84cbb6f523e114e8d5c5767ec7796111">Sprite</a>, <a class="el" href="classSprite.html#a64aee8360870f15193ad46565565a0f2">Sprite</a>, <a class="el" href="classui_1_1ScrollView.html#ae3b50790cd7fa0feeacc9204fe86fc1a">ui::ScrollView</a>, <a class="el" href="classui_1_1Layout.html#a3a391ace9855a825523cdc882c271abe">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a13d675c669b6b926956baf484ce0857a">ui::Layout</a>, <a class="el" href="classui_1_1ScrollView.html#a678108e716966e8beccc25c0de1d9b29">ui::ScrollView</a>, <a class="el" href="classui_1_1ListView.html#ace4890246e03a8de66cfe9d0312df365">ui::ListView</a>, <a class="el" href="classTMXLayer.html#abaf25490e1f7807816c07167a8d4af46">TMXLayer</a>, <a class="el" href="classTMXLayer.html#abaf25490e1f7807816c07167a8d4af46">TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#a13544208580495a457a7ec1f2da9a4d1">experimental::TMXLayer</a>, <a class="el" href="classexperimental_1_1TMXLayer.html#ade60657de43636151aef237010b2965b">experimental::TMXLayer</a>, <a class="el" href="classui_1_1ListView.html#a7002fe4ad783aeccf56cebbe4144036e">ui::ListView</a>, <a class="el" href="classScrollView.html#a10009c987a878297cabe629369142972">ScrollView</a>, <a class="el" href="classScrollView.html#a678108e716966e8beccc25c0de1d9b29">ScrollView</a>, <a class="el" href="classSpriteBatchNode.html#a918786ec36ffac4169444d478e455c5c">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a7bebdfd28805ed83d0a78b49f8b52803">SpriteBatchNode</a>, <a class="el" href="classMenu.html#ab08cab6e153f4d7fabf06cbc941c8c58">Menu</a>, <a class="el" href="classMenu.html#a671c3f506ddcf0532144056289721540">Menu</a>, <a class="el" href="classParticleBatchNode.html#a384b404f2f29463180517528f6f350dc">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#a44ecab9f55fdf0196cb40fd39781bea6">ParticleBatchNode</a>, <a class="el" href="classParallaxNode.html#a0ce03b1f03d63885b0ffae5a17662f45">ParallaxNode</a>, and <a class="el" href="classParallaxNode.html#ae7a8f0dc0855dd89ac16bc4bd3f55621">ParallaxNode</a>.</p>

</div>
</div>
<a id="a91086b878367386bd070789f2ea7c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91086b878367386bd070789f2ea7c8a8">&#9670;&nbsp;</a></span>removeChildByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that identifies a child node. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70e99fad1cb0a446e9d2bfeefd8b115f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e99fad1cb0a446e9d2bfeefd8b115f">&#9670;&nbsp;</a></span>removeChildByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that identifies a child node. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2e53ef64e2252d07304429889278864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e53ef64e2252d07304429889278864">&#9670;&nbsp;</a></span>removeChildByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An integer number that identifies a child node. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code>removeChildByName</code> instead. </p>

</div>
</div>
<a id="a7d2e9aae23d04f4355eadd5d38bc6200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2e9aae23d04f4355eadd5d38bc6200">&#9670;&nbsp;</a></span>removeChildByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeChildByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An integer number that identifies a child node. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code>removeChildByName</code> instead. </p>

</div>
</div>
<a id="acce5160468bfd35be6804b8cf7a88142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5160468bfd35be6804b8cf7a88142">&#9670;&nbsp;</a></span>removeComponent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::removeComponent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a component by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A given name of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if removed success. </dd></dl>

</div>
</div>
<a id="a857bce3dc69f84d4746fbbb8ab2ea720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857bce3dc69f84d4746fbbb8ab2ea720">&#9670;&nbsp;</a></span>removeComponent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::removeComponent </td>
          <td>(</td>
          <td class="paramtype">Component *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a component by its pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>A given component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if removed success. </dd></dl>

</div>
</div>
<a id="a79887a0cfaa3705f0478c14044f93eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79887a0cfaa3705f0478c14044f93eea">&#9670;&nbsp;</a></span>removeComponent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::removeComponent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a component by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A given name of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if removed success. </dd></dl>

</div>
</div>
<a id="a4b9ccb90f2206b1d9b8ccf7b96a361f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9ccb90f2206b1d9b8ccf7b96a361f5">&#9670;&nbsp;</a></span>removeComponent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Node::removeComponent </td>
          <td>(</td>
          <td class="paramtype">Component *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a component by its pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>A given component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if removed success. </dd></dl>

</div>
</div>
<a id="a26f717b3bf15017bae1a070a121b0289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f717b3bf15017bae1a070a121b0289">&#9670;&nbsp;</a></span>removeFromParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeFromParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node itself from its parent node with a cleanup. If the node orphan, then nothing happens. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ad0ee70d65cb9675b64dc447d821a91e5">removeFromParentAndCleanup(bool)</a></code> </dd></dl>

</div>
</div>
<a id="a9a2cf07d3723b1394d8943e24a785704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2cf07d3723b1394d8943e24a785704">&#9670;&nbsp;</a></span>removeFromParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeFromParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node itself from its parent node with a cleanup. If the node orphan, then nothing happens. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#ad0ee70d65cb9675b64dc447d821a91e5">removeFromParentAndCleanup(bool)</a></code> </dd></dl>

</div>
</div>
<a id="ad0ee70d65cb9675b64dc447d821a91e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ee70d65cb9675b64dc447d821a91e5">&#9670;&nbsp;</a></span>removeFromParentAndCleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeFromParentAndCleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node itself from its parent node. If the node orphan, then nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>true if all actions and callbacks on this node should be removed, false otherwise.  removeFromParent  removeFromParent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab22d0fe060ea35fba5eee6fe2fba5f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d0fe060ea35fba5eee6fe2fba5f42">&#9670;&nbsp;</a></span>removeFromParentAndCleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::removeFromParentAndCleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node itself from its parent node. If the node orphan, then nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>true if all actions and callbacks on this node should be removed, false otherwise.  removeFromParent  removeFromParent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c9bc72e7f53c1e7f0ef6bc87c07a08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9bc72e7f53c1e7f0ef6bc87c07a08f">&#9670;&nbsp;</a></span>reorderChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::reorderChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorders a child according to a new z value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>An already added child node. It MUST be already added. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a1b21c65760769e17477ae02ce75adf9f">Sprite</a>, <a class="el" href="classSprite.html#a128a1da95c110579928bdef1c3dacc78">Sprite</a>, <a class="el" href="classSpriteBatchNode.html#a8125810f4a9d5e1c4a4c82cd906baafd">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a9f4e7d0be49a3c044424624ea283c301">SpriteBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ab872c436a2cb7058f589aa7d16bcdd06">ParticleBatchNode</a>, and <a class="el" href="classParticleBatchNode.html#a252befcd88cd095ab65809e94bb852ad">ParticleBatchNode</a>.</p>

</div>
</div>
<a id="a3bbfa613acd0eba2e67ae8274e8114ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbfa613acd0eba2e67ae8274e8114ee">&#9670;&nbsp;</a></span>reorderChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::reorderChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorders a child according to a new z value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>An already added child node. It MUST be already added. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder(int)</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a1b21c65760769e17477ae02ce75adf9f">Sprite</a>, <a class="el" href="classSprite.html#a128a1da95c110579928bdef1c3dacc78">Sprite</a>, <a class="el" href="classSpriteBatchNode.html#a8125810f4a9d5e1c4a4c82cd906baafd">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#a9f4e7d0be49a3c044424624ea283c301">SpriteBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ab872c436a2cb7058f589aa7d16bcdd06">ParticleBatchNode</a>, and <a class="el" href="classParticleBatchNode.html#a252befcd88cd095ab65809e94bb852ad">ParticleBatchNode</a>.</p>

</div>
</div>
<a id="a7db2011610576bcba564fcf1f47c2e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db2011610576bcba564fcf1f47c2e64">&#9670;&nbsp;</a></span>resume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes all scheduled selectors, actions and event listeners. This method is called internally by onEnter. </p>

</div>
</div>
<a id="ab7915bc94d66dd198bc93c5034d454b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7915bc94d66dd198bc93c5034d454b0">&#9670;&nbsp;</a></span>resume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes all scheduled selectors, actions and event listeners. This method is called internally by onEnter. </p>

</div>
</div>
<a id="add0904e6d8d94df6c5dddc26c230cf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0904e6d8d94df6c5dddc26c230cf4c">&#9670;&nbsp;</a></span>resumeSchedulerAndActions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::resumeSchedulerAndActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes all scheduled selectors, actions and event listeners. This method is called internally by onEnter. </p>

</div>
</div>
<a id="ac23454950364265a3da67fb9e8becdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23454950364265a3da67fb9e8becdd1">&#9670;&nbsp;</a></span>resumeSchedulerAndActions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Node::resumeSchedulerAndActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes all scheduled selectors, actions and event listeners. This method is called internally by onEnter. </p>

</div>
</div>
<a id="a07b8c313d5c753c5dbabbe68c77f3128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b8c313d5c753c5dbabbe68c77f3128">&#9670;&nbsp;</a></span>runAction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAction.html">Action</a> * Node::runAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAction.html">Action</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes an action, and returns the action that is executed.</p>
<p>This node becomes the action's target. Refer to <a class="el" href="classAction.html#a696d1ef82807cc18207ba93d59d6ca16">Action::getTarget()</a>. </p><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classActions.html">Actions</a> don't retain their target.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>An <a class="el" href="classAction.html" title="Base class for Action objects. ">Action</a> pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite3D.html#acd2905d934e4d7c873b8a1973297d2a8">Sprite3D</a>, and <a class="el" href="classSprite3D.html#a6447200e96db21bc79df873e598fcf4a">Sprite3D</a>.</p>

</div>
</div>
<a id="a7af4b13a5b4a595b94d788aaf1961b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af4b13a5b4a595b94d788aaf1961b30">&#9670;&nbsp;</a></span>runAction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAction.html">Action</a>* Node::runAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAction.html">Action</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes an action, and returns the action that is executed.</p>
<p>This node becomes the action's target. Refer to <a class="el" href="classAction.html#a696d1ef82807cc18207ba93d59d6ca16">Action::getTarget()</a>. </p><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classActions.html">Actions</a> don't retain their target.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>An <a class="el" href="classAction.html" title="Base class for Action objects. ">Action</a> pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite3D.html#acd2905d934e4d7c873b8a1973297d2a8">Sprite3D</a>, and <a class="el" href="classSprite3D.html#a6447200e96db21bc79df873e598fcf4a">Sprite3D</a>.</p>

</div>
</div>
<a id="a5957efe46bfe7f83f9adb5b737f7ce11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5957efe46bfe7f83f9adb5b737f7ce11">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector.</p>
<p>If the selector is already scheduled, then the interval parameter will be updated without scheduling it again. </p><div class="fragment"><div class="line"><span class="comment">// firstly, implement a schedule function</span></div><div class="line"><span class="keywordtype">void</span> MyNode::TickMe(<span class="keywordtype">float</span> dt);</div><div class="line"><span class="comment">// wrap this function into a selector via schedule_selector macro.</span></div><div class="line">this-&gt;<a class="code" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule</a>(CC_SCHEDULE_SELECTOR(MyNode::TickMe), 0, 0, 0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">interval</td><td>Tick interval in seconds. 0 means tick every frame. If interval = 0, it's recommended to use <a class="el" href="classNode.html#a8ff9ae5e15fe4d737da30f2b05f84c1c">scheduleUpdate()</a> instead. </td></tr>
    <tr><td class="paramname">repeat</td><td>The selector will be executed (repeat + 1) times, you can use CC_REPEAT_FOREVER for tick infinitely. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf87e23665a003982321d5e4fc98c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf87e23665a003982321d5e4fc98c11">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector with an interval time in seconds. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">interval</td><td>Callback interval time in seconds. 0 means tick every frame,  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5957efe46bfe7f83f9adb5b737f7ce11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5957efe46bfe7f83f9adb5b737f7ce11">&#9670;&nbsp;</a></span>schedule() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector.</p>
<p>If the selector is already scheduled, then the interval parameter will be updated without scheduling it again. </p><div class="fragment"><div class="line"><span class="comment">// firstly, implement a schedule function</span></div><div class="line"><span class="keywordtype">void</span> MyNode::TickMe(<span class="keywordtype">float</span> dt);</div><div class="line"><span class="comment">// wrap this function into a selector via schedule_selector macro.</span></div><div class="line">this-&gt;<a class="code" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule</a>(CC_SCHEDULE_SELECTOR(MyNode::TickMe), 0, 0, 0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">interval</td><td>Tick interval in seconds. 0 means tick every frame. If interval = 0, it's recommended to use <a class="el" href="classNode.html#a8ff9ae5e15fe4d737da30f2b05f84c1c">scheduleUpdate()</a> instead. </td></tr>
    <tr><td class="paramname">repeat</td><td>The selector will be executed (repeat + 1) times, you can use CC_REPEAT_FOREVER for tick infinitely. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf87e23665a003982321d5e4fc98c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf87e23665a003982321d5e4fc98c11">&#9670;&nbsp;</a></span>schedule() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector with an interval time in seconds. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">interval</td><td>Callback interval time in seconds. 0 means tick every frame,  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0944b744eb47a227780375597ba997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0944b744eb47a227780375597ba997">&#9670;&nbsp;</a></span>schedule() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector, the scheduled selector will be ticked every frame. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function wrapped as a selector  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30934785a4592d0704ce952e47f69664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30934785a4592d0704ce952e47f69664">&#9670;&nbsp;</a></span>schedule() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function. The scheduled lambda function will be called every frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac48adc693c721c34a98357c088f2d97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48adc693c721c34a98357c088f2d97a">&#9670;&nbsp;</a></span>schedule() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function. The scheduled lambda function will be called every "interval" seconds</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled </td></tr>
    <tr><td class="paramname">interval</td><td>Callback interval time in seconds. 0 means every frame, </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0944b744eb47a227780375597ba997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0944b744eb47a227780375597ba997">&#9670;&nbsp;</a></span>schedule() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a custom selector, the scheduled selector will be ticked every frame. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function wrapped as a selector  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac771b98b6729cc3845fd95cc74c3ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac771b98b6729cc3845fd95cc74c3ae41">&#9670;&nbsp;</a></span>schedule() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be schedule. </td></tr>
    <tr><td class="paramname">interval</td><td>Tick interval in seconds. 0 means tick every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>The selector will be executed (repeat + 1) times, you can use CC_REPEAT_FOREVER for tick infinitely. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30934785a4592d0704ce952e47f69664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30934785a4592d0704ce952e47f69664">&#9670;&nbsp;</a></span>schedule() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function. The scheduled lambda function will be called every frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac48adc693c721c34a98357c088f2d97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48adc693c721c34a98357c088f2d97a">&#9670;&nbsp;</a></span>schedule() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function. The scheduled lambda function will be called every "interval" seconds</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled </td></tr>
    <tr><td class="paramname">interval</td><td>Callback interval time in seconds. 0 means every frame, </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac771b98b6729cc3845fd95cc74c3ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac771b98b6729cc3845fd95cc74c3ae41">&#9670;&nbsp;</a></span>schedule() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::schedule </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be schedule. </td></tr>
    <tr><td class="paramname">interval</td><td>Tick interval in seconds. 0 means tick every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>The selector will be executed (repeat + 1) times, you can use CC_REPEAT_FOREVER for tick infinitely. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85353a5e8ae9f374001fa9f89ccc9adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85353a5e8ae9f374001fa9f89ccc9adb">&#9670;&nbsp;</a></span>scheduleOnce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleOnce </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a selector that runs only once, with a delay of 0 or larger </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a733ed19d0f4bbffcab1536b43ce8407d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733ed19d0f4bbffcab1536b43ce8407d">&#9670;&nbsp;</a></span>scheduleOnce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleOnce </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function that runs only once, with a delay of 0 or larger</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85353a5e8ae9f374001fa9f89ccc9adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85353a5e8ae9f374001fa9f89ccc9adb">&#9670;&nbsp;</a></span>scheduleOnce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleOnce </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a selector that runs only once, with a delay of 0 or larger </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The SEL_SCHEDULE selector to be scheduled. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a733ed19d0f4bbffcab1536b43ce8407d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733ed19d0f4bbffcab1536b43ce8407d">&#9670;&nbsp;</a></span>scheduleOnce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleOnce </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(float)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules a lambda function that runs only once, with a delay of 0 or larger</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The lambda function to be scheduled. </td></tr>
    <tr><td class="paramname">delay</td><td>The amount of time that the first tick will wait before execution. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the lambda function. To be used if you want to unschedule it.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ff9ae5e15fe4d737da30f2b05f84c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9ae5e15fe4d737da30f2b05f84c1c">&#9670;&nbsp;</a></span>scheduleUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules the "update" method.</p>
<p>It will use the order number 0. This method will be called every frame. Scheduled methods with a lower order value will be called before the ones that have a higher order value. Only one "update" method could be scheduled per node.  NA </p>

</div>
</div>
<a id="a8ff9ae5e15fe4d737da30f2b05f84c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9ae5e15fe4d737da30f2b05f84c1c">&#9670;&nbsp;</a></span>scheduleUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules the "update" method.</p>
<p>It will use the order number 0. This method will be called every frame. Scheduled methods with a lower order value will be called before the ones that have a higher order value. Only one "update" method could be scheduled per node.  NA </p>

</div>
</div>
<a id="aa86137d5229cb83acf5cee129a83b818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86137d5229cb83acf5cee129a83b818">&#9670;&nbsp;</a></span>scheduleUpdateWithPriority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdateWithPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules the "update" method with a custom priority.</p>
<p>This selector will be called every frame. Scheduled methods with a lower priority will be called before the ones that have a higher value. Only one "update" selector could be scheduled per node (You can't have 2 'update' selectors).  NA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>A given priority value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa86137d5229cb83acf5cee129a83b818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86137d5229cb83acf5cee129a83b818">&#9670;&nbsp;</a></span>scheduleUpdateWithPriority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdateWithPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules the "update" method with a custom priority.</p>
<p>This selector will be called every frame. Scheduled methods with a lower priority will be called before the ones that have a higher value. Only one "update" selector could be scheduled per node (You can't have 2 'update' selectors).  NA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>A given priority value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc543c82cc9b139cfb57f65eb770fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc543c82cc9b139cfb57f65eb770fb0">&#9670;&nbsp;</a></span>scheduleUpdateWithPriorityLua() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdateWithPriorityLua </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules for lua script.  NA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The key to search lua function. </td></tr>
    <tr><td class="paramname">priority</td><td>A given priority value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc543c82cc9b139cfb57f65eb770fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc543c82cc9b139cfb57f65eb770fb0">&#9670;&nbsp;</a></span>scheduleUpdateWithPriorityLua() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scheduleUpdateWithPriorityLua </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedules for lua script.  NA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The key to search lua function. </td></tr>
    <tr><td class="paramname">priority</td><td>A given priority value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2807ac202214bee721a75c098da54bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2807ac202214bee721a75c098da54bc6">&#9670;&nbsp;</a></span>setActionManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setActionManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td>
          <td class="paramname"><em>actionManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you set a new <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a>, then previously created actions will be removed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actionManager</td><td>A <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8736ca61076cf9e27267c51884890348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8736ca61076cf9e27267c51884890348">&#9670;&nbsp;</a></span>setActionManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setActionManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classActionManager.html">ActionManager</a> *&#160;</td>
          <td class="paramname"><em>actionManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you set a new <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a>, then previously created actions will be removed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actionManager</td><td>A <a class="el" href="classActionManager.html" title="ActionManager is a singleton that manages all the actions. Normally you won&#39;t need to use this single...">ActionManager</a> object that is used by all actions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7375e0112b9bf3e5ace5afb32a5cd044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7375e0112b9bf3e5ace5afb32a5cd044">&#9670;&nbsp;</a></span>setAdditionalTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setAdditionalTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> *&#160;</td>
          <td class="paramname"><em>additionalTransform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an additional transform matrix to the node.</p>
<p>In order to remove it, call it again with the argument <code>nullptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The additional transform will be concatenated at the end of getNodeToParentTransform. It could be used to simulate <code>parent-child</code> relationship between two nodes (e.g. one is in BatchNode, another isn't).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additionalTransform</td><td>An additional transform matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7375e0112b9bf3e5ace5afb32a5cd044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7375e0112b9bf3e5ace5afb32a5cd044">&#9670;&nbsp;</a></span>setAdditionalTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setAdditionalTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> *&#160;</td>
          <td class="paramname"><em>additionalTransform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an additional transform matrix to the node.</p>
<p>In order to remove it, call it again with the argument <code>nullptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The additional transform will be concatenated at the end of getNodeToParentTransform. It could be used to simulate <code>parent-child</code> relationship between two nodes (e.g. one is in BatchNode, another isn't).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additionalTransform</td><td>An additional transform matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dd45cb48a51df7c257675f527e3f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd45cb48a51df7c257675f527e3f277">&#9670;&nbsp;</a></span>setAnchorPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setAnchorPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the anchor point in percent.</p>
<p>anchorPoint is the point around which all transformations and positioning manipulations take place. It's like a pin in the node where it is "attached" to its parent. The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. But you can use values higher than (1,1) and lower than (0,0) too. The default anchorPoint is (0.5,0.5), so it starts in the center of the node. </p><dl class="section note"><dt>Note</dt><dd>If node has a physics body, the anchor must be in the middle, you can't change this to other value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anchorPoint</td><td>The anchor point of node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a6e433ab6bbaa15560a049dfe05087294">ui::EditBox</a>, <a class="el" href="classSprite.html#a218c16399fb6c93f2f6dd7b29b54e238">Sprite</a>, <a class="el" href="classSprite.html#ace1c8b1ba17bcf1086730e192b914a78">Sprite</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a7153fb170a630efc0748e0db6678963f">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1EditBox.html#ad17a8fc58f78d77e47106170e6db9f39">ui::EditBox</a>, <a class="el" href="classProgressTimer.html#a9f177a39d3158dd2f48f6558db5dcd02">ProgressTimer</a>, and <a class="el" href="classProgressTimer.html#a2d83a3a9d2aa6a7d949a3800c82dfc68">ProgressTimer</a>.</p>

</div>
</div>
<a id="aa861dc1d80a74801ee198a7a63a58a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa861dc1d80a74801ee198a7a63a58a55">&#9670;&nbsp;</a></span>setAnchorPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setAnchorPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the anchor point in percent.</p>
<p>anchorPoint is the point around which all transformations and positioning manipulations take place. It's like a pin in the node where it is "attached" to its parent. The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. But you can use values higher than (1,1) and lower than (0,0) too. The default anchorPoint is (0,0), so it starts in the lower left corner of the node. </p><dl class="section note"><dt>Note</dt><dd>If node has a physics body, the anchor must be in the middle, you can't change this to other value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anchorPoint</td><td>The anchor point of node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a6e433ab6bbaa15560a049dfe05087294">ui::EditBox</a>, <a class="el" href="classSprite.html#a218c16399fb6c93f2f6dd7b29b54e238">Sprite</a>, <a class="el" href="classSprite.html#ace1c8b1ba17bcf1086730e192b914a78">Sprite</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a7153fb170a630efc0748e0db6678963f">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1EditBox.html#ad17a8fc58f78d77e47106170e6db9f39">ui::EditBox</a>, <a class="el" href="classProgressTimer.html#a9f177a39d3158dd2f48f6558db5dcd02">ProgressTimer</a>, and <a class="el" href="classProgressTimer.html#a2d83a3a9d2aa6a7d949a3800c82dfc68">ProgressTimer</a>.</p>

</div>
</div>
<a id="a0403546687b2cb6fc211fb461e33ba4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0403546687b2cb6fc211fb461e33ba4d">&#9670;&nbsp;</a></span>setCameraMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setCameraMask </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>applyChildren</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the camera mask for current node. If applyChildren is true, then it will modify the camera mask of its children recursively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>A unsigned short bit for mask. </td></tr>
    <tr><td class="paramname">applyChildren</td><td>A boolean value to determine whether the mask bit should apply to its children or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#ab871c3756134c9f991876cd78ae1ef03">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a8657a6d35049d6e66a79759f93890a6d">Label</a>, <a class="el" href="classLabel.html#a2766bd9d3aa727ee7c50d730af35b9dc">Label</a>, <a class="el" href="classui_1_1Layout.html#a7468a69a70aa481c7a429db365f0362c">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a38e44717b8af16b5b5c1f299081ae854">ui::Layout</a>, <a class="el" href="classProtectedNode.html#ad259bd1bedc5f273b3850c74dc58c2f2">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a45ddaa88c746ea6707b8a09bb50b457d">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a1a2f97b7a006e6b830632eab1e812f90">ClippingNode</a>, and <a class="el" href="classClippingNode.html#afced4609ebbd5d239d1e3d07b6d4b217">ClippingNode</a>.</p>

</div>
</div>
<a id="ad9901c9b33e733877b2c4a47af38787d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9901c9b33e733877b2c4a47af38787d">&#9670;&nbsp;</a></span>setCameraMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setCameraMask </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>applyChildren</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the camera mask for current node. If applyChildren is true, then it will modify the camera mask of its children recursively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>A unsigned short bit for mask. </td></tr>
    <tr><td class="paramname">applyChildren</td><td>A boolean value to determine whether the mask bit should apply to its children or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#ab871c3756134c9f991876cd78ae1ef03">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a8657a6d35049d6e66a79759f93890a6d">Label</a>, <a class="el" href="classLabel.html#a2766bd9d3aa727ee7c50d730af35b9dc">Label</a>, <a class="el" href="classui_1_1Layout.html#a7468a69a70aa481c7a429db365f0362c">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a38e44717b8af16b5b5c1f299081ae854">ui::Layout</a>, <a class="el" href="classProtectedNode.html#ad259bd1bedc5f273b3850c74dc58c2f2">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#a45ddaa88c746ea6707b8a09bb50b457d">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a1a2f97b7a006e6b830632eab1e812f90">ClippingNode</a>, and <a class="el" href="classClippingNode.html#afced4609ebbd5d239d1e3d07b6d4b217">ClippingNode</a>.</p>

</div>
</div>
<a id="a4e7f2dde1e3a7d56880f59f1480955e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7f2dde1e3a7d56880f59f1480955e7">&#9670;&nbsp;</a></span>setCascadeColorEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setCascadeColorEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascadeColorEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want node's color affect the children node's color, then set it to true. Otherwise, set it to false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cascadeColorEnabled</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a07c6d23e55cc2ba21115d2b93ef25bcd">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a07c6d23e55cc2ba21115d2b93ef25bcd">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a6559d3d54c2a7a8a35873390043b0aa6">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a6559d3d54c2a7a8a35873390043b0aa6">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a0638fb9f5b4c522e75ee4ad01393bb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0638fb9f5b4c522e75ee4ad01393bb48">&#9670;&nbsp;</a></span>setCascadeColorEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setCascadeColorEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascadeColorEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want node's color affect the children node's color, then set it to true. Otherwise, set it to false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cascadeColorEnabled</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a07c6d23e55cc2ba21115d2b93ef25bcd">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a07c6d23e55cc2ba21115d2b93ef25bcd">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a6559d3d54c2a7a8a35873390043b0aa6">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#a6559d3d54c2a7a8a35873390043b0aa6">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a56b08f1d19bb0345f6fb40d9a3e3b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b08f1d19bb0345f6fb40d9a3e3b4a4">&#9670;&nbsp;</a></span>setCascadeOpacityEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setCascadeOpacityEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascadeOpacityEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change node's cascadeOpacity property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cascadeOpacityEnabled</td><td>True to enable cascadeOpacity, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a10fe85e705700fbe2bd28da1a17eda68">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a10fe85e705700fbe2bd28da1a17eda68">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab25a8418f19d14a064f8c8072b3468a5">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#ab25a8418f19d14a064f8c8072b3468a5">__LayerRGBA</a>.</p>

</div>
</div>
<a id="a9e36b274a6ee75f4931611b4c53f6180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e36b274a6ee75f4931611b4c53f6180">&#9670;&nbsp;</a></span>setCascadeOpacityEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setCascadeOpacityEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cascadeOpacityEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change node's cascadeOpacity property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cascadeOpacityEnabled</td><td>True to enable cascadeOpacity, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a10fe85e705700fbe2bd28da1a17eda68">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a10fe85e705700fbe2bd28da1a17eda68">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#ab25a8418f19d14a064f8c8072b3468a5">__LayerRGBA</a>, and <a class="el" href="class____LayerRGBA.html#ab25a8418f19d14a064f8c8072b3468a5">__LayerRGBA</a>.</p>

</div>
</div>
<a id="af45037de5b13602263b1ce51b50cafdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45037de5b13602263b1ce51b50cafdd">&#9670;&nbsp;</a></span>setColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the color of node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>A <a class="el" href="structColor3B.html">Color3B</a> color value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#adaec184f0ee740557ffddaece7ece996">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#adaec184f0ee740557ffddaece7ece996">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#aed346ddd9f7f7eab1e3d1417fa9a9831">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#aed346ddd9f7f7eab1e3d1417fa9a9831">__LayerRGBA</a>, <a class="el" href="classControlButton.html#ade75d696a57fbe334ee40152aa2f4bc8">ControlButton</a>, <a class="el" href="classControlButton.html#a7a6e29777bb4a89dab5ac436d92287ac">ControlButton</a>, <a class="el" href="classProgressTimer.html#a3cd315f15a68b541ab276648fa5803cf">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#aabc06a02c225d876ac5746dc6561949f">ProgressTimer</a>, <a class="el" href="classAtlasNode.html#a4205343f55700284ffba22a2988c5445">AtlasNode</a>, <a class="el" href="classAtlasNode.html#a67a26fd695101fe4efa0533cb3dc9f39">AtlasNode</a>, <a class="el" href="classControlColourPicker.html#a23536124c2fbdad9fb93b0de8bf9b85e">ControlColourPicker</a>, and <a class="el" href="classControlColourPicker.html#af83da2a45dd64f202132830729711513">ControlColourPicker</a>.</p>

</div>
</div>
<a id="a2360069ccef753ff1f9665d0e2d3f83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2360069ccef753ff1f9665d0e2d3f83a">&#9670;&nbsp;</a></span>setColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the color of node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>A <a class="el" href="structColor3B.html">Color3B</a> color value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#adaec184f0ee740557ffddaece7ece996">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#adaec184f0ee740557ffddaece7ece996">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#aed346ddd9f7f7eab1e3d1417fa9a9831">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#aed346ddd9f7f7eab1e3d1417fa9a9831">__LayerRGBA</a>, <a class="el" href="classControlButton.html#ade75d696a57fbe334ee40152aa2f4bc8">ControlButton</a>, <a class="el" href="classControlButton.html#a7a6e29777bb4a89dab5ac436d92287ac">ControlButton</a>, <a class="el" href="classProgressTimer.html#a3cd315f15a68b541ab276648fa5803cf">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#aabc06a02c225d876ac5746dc6561949f">ProgressTimer</a>, <a class="el" href="classAtlasNode.html#a4205343f55700284ffba22a2988c5445">AtlasNode</a>, <a class="el" href="classAtlasNode.html#a67a26fd695101fe4efa0533cb3dc9f39">AtlasNode</a>, <a class="el" href="classControlColourPicker.html#a23536124c2fbdad9fb93b0de8bf9b85e">ControlColourPicker</a>, and <a class="el" href="classControlColourPicker.html#af83da2a45dd64f202132830729711513">ControlColourPicker</a>.</p>

</div>
</div>
<a id="ade113d7fc9244f58ac98a4712da49818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade113d7fc9244f58ac98a4712da49818">&#9670;&nbsp;</a></span>setContentSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setContentSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSize.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>contentSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed size of the node.</p>
<p>The contentSize remains the same no matter the node is scaled or rotated. All nodes has a size. <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> has the same size of the screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contentSize</td><td>The untransformed size of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a3fbf590dff29ba873d9c72af308f7edd">ui::EditBox</a>, <a class="el" href="classLayerRadialGradient.html#ad8edf7d6ace4a1cf07966fd63c942c4b">LayerRadialGradient</a>, <a class="el" href="classSprite.html#a040ac797e7c5a3a7ffee7acee8904629">Sprite</a>, <a class="el" href="classui_1_1Widget.html#af5f35184ff3de275929e937f81a4ae30">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#af5f35184ff3de275929e937f81a4ae30">ui::Widget</a>, <a class="el" href="classui_1_1Scale9Sprite.html#af7a55ebc4ba4b0da9ce2ce34bb3bda37">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a1aadf938d146d0469da42e42d33e2a1e">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a3db3f4ffab871cc95a3dca8476c22251">LayerColor</a>, <a class="el" href="classLayerColor.html#a066da112c29c206c4638f84b5d3a9f37">LayerColor</a>, <a class="el" href="classScrollView.html#a9d52bf1ed3831200285167c35fafa686">ScrollView</a>, and <a class="el" href="classScrollView.html#a3cf1d7fd072898e64498a7dc9c5932c1">ScrollView</a>.</p>

</div>
</div>
<a id="af2cee4ec181c4f879e14e32c7c4b96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cee4ec181c4f879e14e32c7c4b96ca">&#9670;&nbsp;</a></span>setContentSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setContentSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSize.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>contentSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed size of the node.</p>
<p>The contentSize remains the same no matter the node is scaled or rotated. All nodes has a size. <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> has the same size of the screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contentSize</td><td>The untransformed size of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a3fbf590dff29ba873d9c72af308f7edd">ui::EditBox</a>, <a class="el" href="classLayerRadialGradient.html#ad8edf7d6ace4a1cf07966fd63c942c4b">LayerRadialGradient</a>, <a class="el" href="classSprite.html#a040ac797e7c5a3a7ffee7acee8904629">Sprite</a>, <a class="el" href="classui_1_1Widget.html#af5f35184ff3de275929e937f81a4ae30">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#af5f35184ff3de275929e937f81a4ae30">ui::Widget</a>, <a class="el" href="classui_1_1Scale9Sprite.html#af7a55ebc4ba4b0da9ce2ce34bb3bda37">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a1aadf938d146d0469da42e42d33e2a1e">ui::EditBox</a>, <a class="el" href="classLayerColor.html#a3db3f4ffab871cc95a3dca8476c22251">LayerColor</a>, <a class="el" href="classLayerColor.html#a066da112c29c206c4638f84b5d3a9f37">LayerColor</a>, <a class="el" href="classScrollView.html#a9d52bf1ed3831200285167c35fafa686">ScrollView</a>, and <a class="el" href="classScrollView.html#a3cf1d7fd072898e64498a7dc9c5932c1">ScrollView</a>.</p>

</div>
</div>
<a id="add71c94aeabd15707311742797d21bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add71c94aeabd15707311742797d21bb3">&#9670;&nbsp;</a></span>setEventDispatcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setEventDispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEventDispatcher.html">EventDispatcher</a> *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set event dispatcher for scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The event dispatcher of scene. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c33fba3541a982e253f9d6c908daaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c33fba3541a982e253f9d6c908daaa">&#9670;&nbsp;</a></span>setEventDispatcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setEventDispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEventDispatcher.html">EventDispatcher</a> *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set event dispatcher for scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The event dispatcher of scene. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a5b9cb9a408d04008c4935a4776566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a5b9cb9a408d04008c4935a4776566">&#9670;&nbsp;</a></span>setGlobalZOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setGlobalZOrder </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>globalZOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the order in which the nodes are renderer. Nodes that have a Global Z Order lower, are renderer first.</p>
<p>In case two or more nodes have the same Global Z Order, the order is not guaranteed. The only exception if the Nodes have a Global Z Order == 0. In that case, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order is used.</p>
<p>By default, all nodes have a Global Z Order = 0. That means that by default, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order is used to render the nodes.</p>
<p>Global Z Order is useful when you need to render nodes in an order different than the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order.</p>
<p>Limitations: Global Z Order can't be used by Nodes that have <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a> as one of their ancestors. And if <a class="el" href="classClippingNode.html">ClippingNode</a> is one of the ancestors, then "global Z order" will be relative to the <a class="el" href="classClippingNode.html">ClippingNode</a>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder()</a></code> </dd>
<dd>
<code>setVertexZ()</code></dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalZOrder</td><td>The global Z order value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7347765b62bbd3f21677e25e1ca164a3">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a8a3965a4546b01df9e3f1302c6ce62dc">Label</a>, <a class="el" href="classLabel.html#a0c53017f28f3e1f2c65f3ea7693a69b2">Label</a>, <a class="el" href="classui_1_1Layout.html#a5ac5023a3f35c0ba03769ef6794c8537">ui::Layout</a>, and <a class="el" href="classProtectedNode.html#a0d067b9056a934255c7a44a675dc9e92">ProtectedNode</a>.</p>

</div>
</div>
<a id="aad45bcba0411770b5ef88f5409d06bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad45bcba0411770b5ef88f5409d06bb2">&#9670;&nbsp;</a></span>setGlobalZOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setGlobalZOrder </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>globalZOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the order in which the nodes are renderer. Nodes that have a Global Z Order lower, are renderer first.</p>
<p>In case two or more nodes have the same Global Z Order, the order is not guaranteed. The only exception if the Nodes have a Global Z Order == 0. In that case, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order is used.</p>
<p>By default, all nodes have a Global Z Order = 0. That means that by default, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order is used to render the nodes.</p>
<p>Global Z Order is useful when you need to render nodes in an order different than the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph order.</p>
<p>Limitations: Global Z Order can't be used by Nodes that have <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a> as one of their ancestors. And if <a class="el" href="classClippingNode.html">ClippingNode</a> is one of the ancestors, then "global Z order" will be relative to the <a class="el" href="classClippingNode.html">ClippingNode</a>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#aee4e616c2d55b722226aae1e68b4946f">setLocalZOrder()</a></code> </dd>
<dd>
<code>setVertexZ()</code></dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalZOrder</td><td>The global Z order value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7347765b62bbd3f21677e25e1ca164a3">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a8a3965a4546b01df9e3f1302c6ce62dc">Label</a>, <a class="el" href="classLabel.html#a0c53017f28f3e1f2c65f3ea7693a69b2">Label</a>, <a class="el" href="classui_1_1Layout.html#a5ac5023a3f35c0ba03769ef6794c8537">ui::Layout</a>, and <a class="el" href="classProtectedNode.html#a0d067b9056a934255c7a44a675dc9e92">ProtectedNode</a>.</p>

</div>
</div>
<a id="a16ac830f1b38ae931da062c0833b2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ac830f1b38ae931da062c0833b2db0">&#9670;&nbsp;</a></span>setGLProgram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setGLProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td>
          <td class="paramname"><em>glprogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the shader program for this node</p>
<p>Since v2.0, each rendering node must set its shader program. It should be set in initialize phase. </p><div class="fragment"><div class="line">node-&gt;setGLrProgram(<a class="code" href="classGLProgramCache.html#a084359da301355ed6c32b12689669d37">GLProgramCache::getInstance</a>()-&gt;getProgram(<a class="code" href="classGLProgram.html#a7f7e223328336e8792add8633171aa96">GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR</a>));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glprogram</td><td>The shader program. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#add60f59da603e007e2d4794d667f40bb">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1ImageView.html#adf4dee6b3cee1d981f2a671dcef2ce7a">ui::ImageView</a>, <a class="el" href="classui_1_1ImageView.html#a98d9a45e777ea30849634eacf5b58509">ui::ImageView</a>, <a class="el" href="classSprite3D.html#aa71609d7f3a35a0d86a70f28bafffa9c">Sprite3D</a>, and <a class="el" href="classSprite3D.html#addcfa64162310ce40ec097738442af9f">Sprite3D</a>.</p>

</div>
</div>
<a id="aa257b40f74bea71ab419f2b8d76f6ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa257b40f74bea71ab419f2b8d76f6ba4">&#9670;&nbsp;</a></span>setGLProgram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setGLProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGLProgram.html">GLProgram</a> *&#160;</td>
          <td class="paramname"><em>glprogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the shader program for this node</p>
<p>Since v2.0, each rendering node must set its shader program. It should be set in initialize phase. </p><div class="fragment"><div class="line">node-&gt;setGLProgram(<a class="code" href="classGLProgramCache.html#a084359da301355ed6c32b12689669d37">GLProgramCache::getInstance</a>()-&gt;getProgram(<a class="code" href="classGLProgram.html#a7f7e223328336e8792add8633171aa96">GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR</a>));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glprogram</td><td>The shader program. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#add60f59da603e007e2d4794d667f40bb">ui::Scale9Sprite</a>, <a class="el" href="classui_1_1ImageView.html#adf4dee6b3cee1d981f2a671dcef2ce7a">ui::ImageView</a>, <a class="el" href="classui_1_1ImageView.html#a98d9a45e777ea30849634eacf5b58509">ui::ImageView</a>, <a class="el" href="classSprite3D.html#aa71609d7f3a35a0d86a70f28bafffa9c">Sprite3D</a>, and <a class="el" href="classSprite3D.html#addcfa64162310ce40ec097738442af9f">Sprite3D</a>.</p>

</div>
</div>
<a id="a3fe706d4e7b601eee9ccc8eb8ecf90c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe706d4e7b601eee9ccc8eb8ecf90c0">&#9670;&nbsp;</a></span>setGLProgramState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setGLProgramState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGLProgramState.html">GLProgramState</a> *&#160;</td>
          <td class="paramname"><em>glProgramState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <a class="el" href="classGLProgramState.html">GLProgramState</a> for this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glProgramState</td><td>The <a class="el" href="classGLProgramState.html">GLProgramState</a> for this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#ac5d1aa898d17b1417f8d6ac5589d0440">ui::Scale9Sprite</a>, <a class="el" href="classSprite3D.html#a8bfa814ae2f4584b69dbb776de1c327b">Sprite3D</a>, and <a class="el" href="classSprite3D.html#ab9e57d29350dc6886360d433c023b935">Sprite3D</a>.</p>

</div>
</div>
<a id="a3fe706d4e7b601eee9ccc8eb8ecf90c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe706d4e7b601eee9ccc8eb8ecf90c0">&#9670;&nbsp;</a></span>setGLProgramState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setGLProgramState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGLProgramState.html">GLProgramState</a> *&#160;</td>
          <td class="paramname"><em>glProgramState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <a class="el" href="classGLProgramState.html">GLProgramState</a> for this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glProgramState</td><td>The <a class="el" href="classGLProgramState.html">GLProgramState</a> for this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#ac5d1aa898d17b1417f8d6ac5589d0440">ui::Scale9Sprite</a>, <a class="el" href="classSprite3D.html#a8bfa814ae2f4584b69dbb776de1c327b">Sprite3D</a>, and <a class="el" href="classSprite3D.html#ab9e57d29350dc6886360d433c023b935">Sprite3D</a>.</p>

</div>
</div>
<a id="ad218be5dafbfc529444c1e619841260e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad218be5dafbfc529444c1e619841260e">&#9670;&nbsp;</a></span>setGLServerState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Node::setGLServerState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serverState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>No longer needed  NA </dd></dl>

</div>
</div>
<a id="a5eb3c79871dc219ae8345fc72c7a00de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb3c79871dc219ae8345fc72c7a00de">&#9670;&nbsp;</a></span>setGLServerState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Node::setGLServerState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000259">Deprecated:</a></b></dt><dd>No longer needed  NA </dd></dl>

</div>
</div>
<a id="a75e8f6a6a46358d6faf8683e720d47b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e8f6a6a46358d6faf8683e720d47b5">&#9670;&nbsp;</a></span>setIgnoreAnchorPointForPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setIgnoreAnchorPointForPosition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isRelativeAnchorPoint setter </p>
<p>Sets whether the anchor point will be (0,0) when you position this node.</p>
<p>This is an internal method, only used by <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. Don't call it outside framework. The default value is false, while in <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore</td><td>true if anchor point will be (0,0) when you position this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a0466d4642ed98aefe0febeb4a20bb78f">Sprite</a>, and <a class="el" href="classSprite.html#a6cbc37c64ba7d2f0d37070c1c1a750ec">Sprite</a>.</p>

</div>
</div>
<a id="a0bedb5e314188f86e32fd986c449b28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bedb5e314188f86e32fd986c449b28b">&#9670;&nbsp;</a></span>setIgnoreAnchorPointForPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setIgnoreAnchorPointForPosition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether the anchor point will be (0,0) when you position this node.</p>
<p>This is an internal method, only used by <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. Don't call it outside framework. The default value is false, while in <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore</td><td>true if anchor point will be (0,0) when you position this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a0466d4642ed98aefe0febeb4a20bb78f">Sprite</a>, and <a class="el" href="classSprite.html#a6cbc37c64ba7d2f0d37070c1c1a750ec">Sprite</a>.</p>

</div>
</div>
<a id="aee4e616c2d55b722226aae1e68b4946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4e616c2d55b722226aae1e68b4946f">&#9670;&nbsp;</a></span>setLocalZOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setLocalZOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LocalZOrder is the 'key' used to sort the node relative to its siblings.</p>
<p>The <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s parent will sort all its children based on the LocalZOrder value. If two nodes have the same LocalZOrder, then the node that was added first to the children's array will be in front of the other node in the array.</p>
<p>Also, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph is traversed using the "In-Order" tree traversal algorithm ( <a href="http://en.wikipedia.org/wiki/Tree_traversal#In-order">http://en.wikipedia.org/wiki/Tree_traversal#In-order</a> ) And Nodes that have LocalZOrder values &lt; 0 are the "left" subtree While Nodes with LocalZOrder &gt;=0 are the "right" subtree.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a32a5b9cb9a408d04008c4935a4776566">setGlobalZOrder</a></code> </dd>
<dd>
<code>setVertexZ</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localZOrder</td><td>The local Z order value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a240c11ff1bbc265e46bbc2e1d34179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a240c11ff1bbc265e46bbc2e1d34179">&#9670;&nbsp;</a></span>setLocalZOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setLocalZOrder </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>localZOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LocalZOrder is the 'key' used to sort the node relative to its siblings.</p>
<p>The <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s parent will sort all its children based on the LocalZOrder value. If two nodes have the same LocalZOrder, then the node that was added first to the children's array will be in front of the other node in the array.</p>
<p>Also, the <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a> Graph is traversed using the "In-Order" tree traversal algorithm ( <a href="http://en.wikipedia.org/wiki/Tree_traversal#In-order">http://en.wikipedia.org/wiki/Tree_traversal#In-order</a> ) And Nodes that have LocalZOrder values &lt; 0 are the "left" subtree While Nodes with LocalZOrder &gt;=0 are the "right" subtree.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a32a5b9cb9a408d04008c4935a4776566">setGlobalZOrder</a></code> </dd>
<dd>
<code>setVertexZ</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localZOrder</td><td>The local Z order value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a519730c66b26e65c6539a908e6905edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519730c66b26e65c6539a908e6905edc">&#9670;&nbsp;</a></span>setName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the name that is used to identify the node easily. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that identifies the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="a09a7d879835c2d3fbcbcdcd8f415938a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a7d879835c2d3fbcbcdcd8f415938a">&#9670;&nbsp;</a></span>setName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the name that is used to identify the node easily. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that identifies the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.2 </dd></dl>

</div>
</div>
<a id="a36afac09102cefcdf692f20358add455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36afac09102cefcdf692f20358add455">&#9670;&nbsp;</a></span>setNodeToParentTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setNodeToParentTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the transformation matrix manually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>A given transformation matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d96a56bda1b61c829918f771a02a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d96a56bda1b61c829918f771a02a8e">&#9670;&nbsp;</a></span>setNodeToParentTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setNodeToParentTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the transformation matrix manually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>A given transformation matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3665662090ae9ebd3820ee4e7199da7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3665662090ae9ebd3820ee4e7199da7b">&#9670;&nbsp;</a></span>setNormalizedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setNormalizedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position setter </p>
<p>Sets the position (x,y) using values between 0 and 1. The positions in pixels is calculated like the following: </p><div class="fragment"><div class="line"><span class="comment">// pseudo code</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classNode.html#a3665662090ae9ebd3820ee4e7199da7b">setNormalizedPosition</a>(<a class="code" href="classVec2.html">Vec2</a> pos) {</div><div class="line">  <a class="code" href="classSize.html">Size</a> s = <a class="code" href="classNode.html#af4c8a4ae726c6dd984db05c89454652d">getParent</a>()-&gt;<a class="code" href="classNode.html#a3828836a62dbf0862ecaa99a72babc13">getContentSize</a>();</div><div class="line">  <a class="code" href="classNode.html#a3b3dff369c98537eeeab4c0bcbf3a69f">_position</a> = pos * s;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The normalized position (x,y) of the node, using value between 0 and 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c42f72323ef791d720b9083f480cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c42f72323ef791d720b9083f480cb4">&#9670;&nbsp;</a></span>setOnEnterCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOnEnterCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event onEnter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c42f72323ef791d720b9083f480cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c42f72323ef791d720b9083f480cb4">&#9670;&nbsp;</a></span>setOnEnterCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOnEnterCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event onEnter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad666c48b3a6952c3c4b6c4c1eb446ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad666c48b3a6952c3c4b6c4c1eb446ad">&#9670;&nbsp;</a></span>setonEnterTransitionDidFinishCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setonEnterTransitionDidFinishCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event EnterTransitionDidFinish. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad666c48b3a6952c3c4b6c4c1eb446ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad666c48b3a6952c3c4b6c4c1eb446ad">&#9670;&nbsp;</a></span>setonEnterTransitionDidFinishCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setonEnterTransitionDidFinishCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event EnterTransitionDidFinish. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e2254c47969bfa81be037230738367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e2254c47969bfa81be037230738367">&#9670;&nbsp;</a></span>setOnExitCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOnExitCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event onExit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e2254c47969bfa81be037230738367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e2254c47969bfa81be037230738367">&#9670;&nbsp;</a></span>setOnExitCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOnExitCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event onExit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0270c92c148c57b0605aae8298e356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0270c92c148c57b0605aae8298e356">&#9670;&nbsp;</a></span>setonExitTransitionDidStartCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setonExitTransitionDidStartCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event ExitTransitionDidStart. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0270c92c148c57b0605aae8298e356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0270c92c148c57b0605aae8298e356">&#9670;&nbsp;</a></span>setonExitTransitionDidStartCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setonExitTransitionDidStartCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback of event ExitTransitionDidStart. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A std::function&lt;void()&gt; callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae41a9db63bfa3d466ee7c9d79c35352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41a9db63bfa3d466ee7c9d79c35352d">&#9670;&nbsp;</a></span>setOpacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOpacity </td>
          <td>(</td>
          <td class="paramtype">GLubyte&#160;</td>
          <td class="paramname"><em>opacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change node opacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opacity</td><td>A GLubyte opacity value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#aa0ac4f9dca25f519f175e668ba4f3306">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#aa0ac4f9dca25f519f175e668ba4f3306">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a1b172623ee7486835fd189672d19d8d7">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a1b172623ee7486835fd189672d19d8d7">__LayerRGBA</a>, <a class="el" href="classControlButton.html#adfe6c80adc5ba24d50d21f5ff742f6a1">ControlButton</a>, <a class="el" href="classControlButton.html#aa6076ef32569a9be5361f12bf00d4aa1">ControlButton</a>, <a class="el" href="classProgressTimer.html#a757eb314cc8f4633c6e5e240b2e6a4e8">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#a9f36a7fde3a6490b81e53f23ebbd3df9">ProgressTimer</a>, <a class="el" href="classMotionStreak.html#af5d9d6c438239621c6931d312a92fcec">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a7240b2a7e1340cf0139774421b7ca80e">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aaf983644b09cefdf815a650c7cfd426a">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#aebd12e84f982bb11ab3cc3c92e769f73">MotionStreak3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a89da6d683d0157d90c93b559e90c69e3">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a89da6d683d0157d90c93b559e90c69e3">ui::ScrollViewBar</a>, <a class="el" href="classAtlasNode.html#af95a54e5d5157983414cad3d837853eb">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a396e36e894a70722806e90c7101207bc">AtlasNode</a>.</p>

</div>
</div>
<a id="add84cdfdadeb8862c2149a57a565017c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add84cdfdadeb8862c2149a57a565017c">&#9670;&nbsp;</a></span>setOpacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setOpacity </td>
          <td>(</td>
          <td class="paramtype">GLubyte&#160;</td>
          <td class="paramname"><em>opacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change node opacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opacity</td><td>A GLubyte opacity value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#aa0ac4f9dca25f519f175e668ba4f3306">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#aa0ac4f9dca25f519f175e668ba4f3306">__NodeRGBA</a>, <a class="el" href="class____LayerRGBA.html#a1b172623ee7486835fd189672d19d8d7">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a1b172623ee7486835fd189672d19d8d7">__LayerRGBA</a>, <a class="el" href="classControlButton.html#adfe6c80adc5ba24d50d21f5ff742f6a1">ControlButton</a>, <a class="el" href="classControlButton.html#aa6076ef32569a9be5361f12bf00d4aa1">ControlButton</a>, <a class="el" href="classProgressTimer.html#a757eb314cc8f4633c6e5e240b2e6a4e8">ProgressTimer</a>, <a class="el" href="classProgressTimer.html#a9f36a7fde3a6490b81e53f23ebbd3df9">ProgressTimer</a>, <a class="el" href="classMotionStreak.html#af5d9d6c438239621c6931d312a92fcec">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a7240b2a7e1340cf0139774421b7ca80e">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#aaf983644b09cefdf815a650c7cfd426a">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#aebd12e84f982bb11ab3cc3c92e769f73">MotionStreak3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a89da6d683d0157d90c93b559e90c69e3">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a89da6d683d0157d90c93b559e90c69e3">ui::ScrollViewBar</a>, <a class="el" href="classAtlasNode.html#af95a54e5d5157983414cad3d837853eb">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#a396e36e894a70722806e90c7101207bc">AtlasNode</a>.</p>

</div>
</div>
<a id="a978c5435ab23f76e9efdf0f7e9e288e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978c5435ab23f76e9efdf0f7e9e288e5">&#9670;&nbsp;</a></span>setOpacityModifyRGB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want the opacity affect the color property, then set to true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a2baa7449894e58c0bc78e749058b9c0e">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a2baa7449894e58c0bc78e749058b9c0e">__NodeRGBA</a>, <a class="el" href="classParticleSystem.html#a2c5a931c70aaa80e3fc098ec0aaf9827">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a2c5a931c70aaa80e3fc098ec0aaf9827">ParticleSystem</a>, <a class="el" href="classLabel.html#a29fe05b89ed819988763ae013ca8fe48">Label</a>, <a class="el" href="classLabel.html#ab548565b1faa8449ced97d96a591e955">Label</a>, <a class="el" href="classSprite.html#a4b86bd0afb6fa3bb3ed5521041800458">Sprite</a>, <a class="el" href="classSprite.html#adf41c2705eb6b1317a14c469c84da78c">Sprite</a>, <a class="el" href="class____LayerRGBA.html#a04037a60b1a1f9d5ba2760252ad2da35">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a04037a60b1a1f9d5ba2760252ad2da35">__LayerRGBA</a>, <a class="el" href="classControl.html#afc69bf17ee302a8efd9db70d5bb4c5b7">Control</a>, <a class="el" href="classControl.html#ad2bebed567807e1e309513666f67ad5e">Control</a>, <a class="el" href="classMenu.html#ae2979f44049f67f2a2411cb3901842ef">Menu</a>, <a class="el" href="classMenu.html#a7dc62dd40fb8b6cd4addee5fb38cb6b9">Menu</a>, <a class="el" href="classMotionStreak.html#a03e92253595f528d79528bbb4be1b2ad">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aa140ca21b82d41fbe8c0ba08d8060c3b">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#ad201e04b841b5fb15fea56bfd6b9cb03">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#ac4ef49b3087c63f5cea40efe91d4f271">MotionStreak3D</a>, <a class="el" href="classAtlasNode.html#ab9dacc4ad5e4701ff0a531605f2d1f11">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#adb5151b64bb92b157133f9efb07124a8">AtlasNode</a>.</p>

</div>
</div>
<a id="a03297671eb3440831666a3aa25875f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03297671eb3440831666a3aa25875f1d">&#9670;&nbsp;</a></span>setOpacityModifyRGB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you want the opacity affect the color property, then set to true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a2baa7449894e58c0bc78e749058b9c0e">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a2baa7449894e58c0bc78e749058b9c0e">__NodeRGBA</a>, <a class="el" href="classParticleSystem.html#a2c5a931c70aaa80e3fc098ec0aaf9827">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a2c5a931c70aaa80e3fc098ec0aaf9827">ParticleSystem</a>, <a class="el" href="classLabel.html#a29fe05b89ed819988763ae013ca8fe48">Label</a>, <a class="el" href="classLabel.html#ab548565b1faa8449ced97d96a591e955">Label</a>, <a class="el" href="classSprite.html#a4b86bd0afb6fa3bb3ed5521041800458">Sprite</a>, <a class="el" href="classSprite.html#adf41c2705eb6b1317a14c469c84da78c">Sprite</a>, <a class="el" href="class____LayerRGBA.html#a04037a60b1a1f9d5ba2760252ad2da35">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a04037a60b1a1f9d5ba2760252ad2da35">__LayerRGBA</a>, <a class="el" href="classControl.html#afc69bf17ee302a8efd9db70d5bb4c5b7">Control</a>, <a class="el" href="classControl.html#ad2bebed567807e1e309513666f67ad5e">Control</a>, <a class="el" href="classMenu.html#ae2979f44049f67f2a2411cb3901842ef">Menu</a>, <a class="el" href="classMenu.html#a7dc62dd40fb8b6cd4addee5fb38cb6b9">Menu</a>, <a class="el" href="classMotionStreak.html#a03e92253595f528d79528bbb4be1b2ad">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aa140ca21b82d41fbe8c0ba08d8060c3b">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#ad201e04b841b5fb15fea56bfd6b9cb03">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#ac4ef49b3087c63f5cea40efe91d4f271">MotionStreak3D</a>, <a class="el" href="classAtlasNode.html#ab9dacc4ad5e4701ff0a531605f2d1f11">AtlasNode</a>, and <a class="el" href="classAtlasNode.html#adb5151b64bb92b157133f9efb07124a8">AtlasNode</a>.</p>

</div>
</div>
<a id="ab5f0786bcb59591c528efb0b776797fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f0786bcb59591c528efb0b776797fc">&#9670;&nbsp;</a></span>setParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parent setter </p>
<p>Sets the parent node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the parent node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4d4495d7ca6de96a2ce4dbc63514022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d4495d7ca6de96a2ce4dbc63514022">&#9670;&nbsp;</a></span>setParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the parent node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the parent node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ffbf25763ef5f15eeae7227779505bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffbf25763ef5f15eeae7227779505bc">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position setter </p>
<p>Sets the position (x,y) of the node in its parent's coordinate system.</p>
<p>Usually we use <code><a class="el" href="classVec2.html">Vec2(x,y)</a></code> to compose <a class="el" href="classVec2.html">Vec2</a> object. This code snippet sets the node in the center of screen. </p><div class="fragment"><div class="line"><a class="code" href="classSize.html">Size</a> size = <a class="code" href="classDirector.html#a8d2a4ca9e20cd400ddadd516efa111e0">Director::getInstance</a>()-&gt;<a class="code" href="classDirector.html#af07668df4a8916e6eb0f79a93f6588fe">getWinSize</a>();</div><div class="line">node-&gt;setPosition(size.<a class="code" href="classSize.html#af0be19024ddd79e7843492b3760c21f0">width</a>/2, size.<a class="code" href="classSize.html#a880fa21eaad5a5a0fe439d440776fd05">height</a>/2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position (x,y) of the node in OpenGL coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a92e525c7152c0a974632d4810b392f11">ui::EditBox</a>, <a class="el" href="classSprite.html#a0c950da6338ba62938d7b2af6eea8b39">Sprite</a>, <a class="el" href="classSprite.html#aace7c480af3721709b218bdc579f8903">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a9920fc994750f83db1c80be0417143f6">ui::EditBox</a>, <a class="el" href="classui_1_1Widget.html#a290404b9d89d66e9f5bc7225fe68f2b5">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#ad1983665a8a2463e77c9ff7e13fcac97">ui::Widget</a>, <a class="el" href="classMotionStreak.html#a2b77305ae80661b9508b928cf0a1699d">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a2d7df706b1ec462093363d18fd0baf58">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a070710f82d947115207e9bfc0eeb4d30">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a8e4698c3850e094f90600e3ba4604651">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a63f9ed194c372246c8018222d303faa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f9ed194c372246c8018222d303faa7">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position (x,y) of the node in its parent's coordinate system.</p>
<p>Usually we use <code><a class="el" href="classVec2.html">Vec2(x,y)</a></code> to compose <a class="el" href="classVec2.html">Vec2</a> object. This code snippet sets the node in the center of screen. </p><div class="fragment"><div class="line"><a class="code" href="classSize.html">Size</a> size = <a class="code" href="classDirector.html#a8d2a4ca9e20cd400ddadd516efa111e0">Director::getInstance</a>()-&gt;<a class="code" href="classDirector.html#af07668df4a8916e6eb0f79a93f6588fe">getWinSize</a>();</div><div class="line">node-&gt;setPosition(size.<a class="code" href="classSize.html#af0be19024ddd79e7843492b3760c21f0">width</a>/2, size.<a class="code" href="classSize.html#a880fa21eaad5a5a0fe439d440776fd05">height</a>/2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position (x,y) of the node in OpenGL coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a92e525c7152c0a974632d4810b392f11">ui::EditBox</a>, <a class="el" href="classSprite.html#a0c950da6338ba62938d7b2af6eea8b39">Sprite</a>, <a class="el" href="classSprite.html#aace7c480af3721709b218bdc579f8903">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#a9920fc994750f83db1c80be0417143f6">ui::EditBox</a>, <a class="el" href="classui_1_1Widget.html#a290404b9d89d66e9f5bc7225fe68f2b5">ui::Widget</a>, <a class="el" href="classui_1_1Widget.html#ad1983665a8a2463e77c9ff7e13fcac97">ui::Widget</a>, <a class="el" href="classMotionStreak.html#a2b77305ae80661b9508b928cf0a1699d">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a2d7df706b1ec462093363d18fd0baf58">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a070710f82d947115207e9bfc0eeb4d30">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a8e4698c3850e094f90600e3ba4604651">MotionStreak3D</a>.</p>

</div>
</div>
<a id="aaa8545c103ef1b35e5076dbedab93af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8545c103ef1b35e5076dbedab93af5">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position (x,y) of the node in its parent's coordinate system.</p>
<p>Passing two numbers (x,y) is much efficient than passing <a class="el" href="classVec2.html">Vec2</a> object. This method is bound to Lua and JavaScript. Passing a number is 10 times faster than passing a object from Lua to c++.</p>
<div class="fragment"><div class="line"><span class="comment">// sample code in Lua</span></div><div class="line">local pos  = node::getPosition()  -- returns <a class="code" href="classVec2.html">Vec2</a> <span class="keywordtype">object</span> from C++.</div><div class="line">node:<a class="code" href="classNode.html#a8ffbf25763ef5f15eeae7227779505bc">setPosition</a>(x, y)            -- pass x, y coordinate to C++.</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate for position. </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate for position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#aaef708324799384499b67c1721ad36d1">Sprite</a>, <a class="el" href="classSprite.html#ad6ceb4be9c4664798908bb0f8dd3bf70">Sprite</a>, <a class="el" href="classMotionStreak.html#a5aee78ffa74f687a09d9167b8da6d075">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a8799ee17a6842cad944b85d67f1155d0">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#af19878b923b0caae1704f93a9ee21699">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#ada67cecb8a81f0f48615d24eb9fc2373">MotionStreak3D</a>.</p>

</div>
</div>
<a id="aa23be53d56922c9ee20ff63ec296a1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23be53d56922c9ee20ff63ec296a1f7">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position (x,y) of the node in its parent's coordinate system.</p>
<p>Passing two numbers (x,y) is much efficient than passing <a class="el" href="classVec2.html">Vec2</a> object. This method is bound to Lua and JavaScript. Passing a number is 10 times faster than passing a object from Lua to c++.</p>
<div class="fragment"><div class="line"><span class="comment">// sample code in Lua</span></div><div class="line">local pos  = node::getPosition()  -- returns <a class="code" href="classVec2.html">Vec2</a> <span class="keywordtype">object</span> from C++.</div><div class="line">node:<a class="code" href="classNode.html#a8ffbf25763ef5f15eeae7227779505bc">setPosition</a>(x, y)            -- pass x, y coordinate to C++.</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate for position. </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate for position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#aaef708324799384499b67c1721ad36d1">Sprite</a>, <a class="el" href="classSprite.html#ad6ceb4be9c4664798908bb0f8dd3bf70">Sprite</a>, <a class="el" href="classMotionStreak.html#a5aee78ffa74f687a09d9167b8da6d075">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a8799ee17a6842cad944b85d67f1155d0">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#af19878b923b0caae1704f93a9ee21699">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#ada67cecb8a81f0f48615d24eb9fc2373">MotionStreak3D</a>.</p>

</div>
</div>
<a id="aa9eee02836d359b1469cf8a1484b485f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eee02836d359b1469cf8a1484b485f">&#9670;&nbsp;</a></span>setPosition3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPosition3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position (X, Y, and Z) in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position (X, Y, and Z) in its parent's coordinate system.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a34fac2c60502d074f8e40e99d01d9180">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a0a0d2f5f302ecaecb2e6652e5863f28f">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ad3343ed96ab373ab30bef52123179a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3343ed96ab373ab30bef52123179a86">&#9670;&nbsp;</a></span>setPosition3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPosition3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position (X, Y, and Z) in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position (X, Y, and Z) in its parent's coordinate system.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a34fac2c60502d074f8e40e99d01d9180">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a0a0d2f5f302ecaecb2e6652e5863f28f">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a4014e9c3840ed79bf9e5b5193e1f1a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4014e9c3840ed79bf9e5b5193e1f1a4b">&#9670;&nbsp;</a></span>setPositionNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPositionNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position setter </p>
<p>Sets the position (x,y) using values between 0 and 1. The positions in pixels is calculated like the following: </p><div class="fragment"><div class="line"><span class="comment">// pseudo code</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classNode.html#a3665662090ae9ebd3820ee4e7199da7b">setNormalizedPosition</a>(<a class="code" href="classVec2.html">Vec2</a> pos) {</div><div class="line">  <a class="code" href="classSize.html">Size</a> s = <a class="code" href="classNode.html#af4c8a4ae726c6dd984db05c89454652d">getParent</a>()-&gt;<a class="code" href="classNode.html#a3828836a62dbf0862ecaa99a72babc13">getContentSize</a>();</div><div class="line">  <a class="code" href="classNode.html#a3b3dff369c98537eeeab4c0bcbf3a69f">_position</a> = pos * s;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The normalized position (x,y) of the node, using value between 0 and 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1dfc73d6122a95778d5d9db3d1fd913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dfc73d6122a95778d5d9db3d1fd913">&#9670;&nbsp;</a></span>setPositionX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPositionX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets/Sets x or y coordinate individually for position. These methods are used in Lua and Javascript Bindings Sets the x coordinate of the node in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x coordinate of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#af6cb7fe8388e16af000893b75c9676a0">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aabc8d8fedcddd0f9e1e77b090ce8f7ed">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a1b723a27b44aa12ced168fe18ca920de">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a9c363f74a20d8b5e83357343ecfad7d4">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a2b26ff930ebb0b241bc40b7f573be417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b26ff930ebb0b241bc40b7f573be417">&#9670;&nbsp;</a></span>setPositionX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPositionX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets/Sets x or y coordinate individually for position. These methods are used in Lua and Javascript Bindings Sets the x coordinate of the node in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x coordinate of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#af6cb7fe8388e16af000893b75c9676a0">MotionStreak</a>, <a class="el" href="classMotionStreak.html#aabc8d8fedcddd0f9e1e77b090ce8f7ed">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a1b723a27b44aa12ced168fe18ca920de">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#a9c363f74a20d8b5e83357343ecfad7d4">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a5c97d36655f0daa71a5f6c715d2b0470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c97d36655f0daa71a5f6c715d2b0470">&#9670;&nbsp;</a></span>setPositionY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPositionY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the y coordinate of the node in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a75b545604e6a5f2351f6d4b034edb185">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a78b4896032c6ef6e21ce5d9012d82d13">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a8f63bcfa700cf9d67907d9e6f31bace6">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#afb3de2f3e93486b5be3877d081159d57">MotionStreak3D</a>.</p>

</div>
</div>
<a id="acec74667c8b24b5164e536b999bc8eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec74667c8b24b5164e536b999bc8eaa">&#9670;&nbsp;</a></span>setPositionY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPositionY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the y coordinate of the node in its parent's coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak.html#a75b545604e6a5f2351f6d4b034edb185">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a78b4896032c6ef6e21ce5d9012d82d13">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a8f63bcfa700cf9d67907d9e6f31bace6">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#afb3de2f3e93486b5be3877d081159d57">MotionStreak3D</a>.</p>

</div>
</div>
<a id="aaea9bcbb6e5972122c590b930b5a90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea9bcbb6e5972122c590b930b5a90b9">&#9670;&nbsp;</a></span>setPositionZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPositionZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>positionZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the 'z' coordinate in the position. It is the OpenGL Z vertex value.</p>
<p>The OpenGL depth buffer and depth testing are disabled by default. You need to turn them on. In order to use this property correctly.</p>
<p><code><a class="el" href="classNode.html#aaea9bcbb6e5972122c590b930b5a90b9">setPositionZ()</a></code> also sets the <code>setGlobalZValue()</code> with the positionZ as value.</p>
<dl class="section see"><dt>See also</dt><dd><code>setGlobalZValue()</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionZ</td><td>OpenGL Z vertex of this node.  setVertexZ </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a3ebbeab90f8e3f136fa9cce2c85ee197">Sprite</a>, and <a class="el" href="classSprite.html#ac22643ba4c10444cce30e0f100bfb041">Sprite</a>.</p>

</div>
</div>
<a id="acf44e31f8e5d05e54e5594228406ed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf44e31f8e5d05e54e5594228406ed76">&#9670;&nbsp;</a></span>setPositionZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setPositionZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>positionZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the 'z' coordinate in the position. It is the OpenGL Z vertex value.</p>
<p>The OpenGL depth buffer and depth testing are disabled by default. You need to turn them on. In order to use this property correctly.</p>
<p><code><a class="el" href="classNode.html#aaea9bcbb6e5972122c590b930b5a90b9">setPositionZ()</a></code> also sets the <code>setGlobalZValue()</code> with the positionZ as value.</p>
<dl class="section see"><dt>See also</dt><dd><code>setGlobalZValue()</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionZ</td><td>OpenGL Z vertex of this node.  setVertexZ </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a3ebbeab90f8e3f136fa9cce2c85ee197">Sprite</a>, and <a class="el" href="classSprite.html#ac22643ba4c10444cce30e0f100bfb041">Sprite</a>.</p>

</div>
</div>
<a id="a62dda439f77712f0d9b405ce887df676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62dda439f77712f0d9b405ce887df676">&#9670;&nbsp;</a></span>setRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotation setter </p>
<p>Sets the rotation (angle) of the node in degrees.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a456ab327b49e657c504cb41ce3f0bd77">Sprite</a>, <a class="el" href="classSprite.html#a943f5aa94fccc46930b978d291ff0cfe">Sprite</a>, <a class="el" href="classParticleSystem.html#a0616c2ca4a0618b811c692e30aa9213f">ParticleSystem</a>, and <a class="el" href="classParticleSystem.html#ad3fffe8df2aafe8a5bbf9402b0dbe4a3">ParticleSystem</a>.</p>

</div>
</div>
<a id="ad2e0cda8797b5b94398a123bfe600f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e0cda8797b5b94398a123bfe600f21">&#9670;&nbsp;</a></span>setRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rotation (angle) of the node in degrees.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a456ab327b49e657c504cb41ce3f0bd77">Sprite</a>, <a class="el" href="classSprite.html#a943f5aa94fccc46930b978d291ff0cfe">Sprite</a>, <a class="el" href="classParticleSystem.html#a0616c2ca4a0618b811c692e30aa9213f">ParticleSystem</a>, and <a class="el" href="classParticleSystem.html#ad3fffe8df2aafe8a5bbf9402b0dbe4a3">ParticleSystem</a>.</p>

</div>
</div>
<a id="a2ce988bebd6c8b804d8bfdfafd511c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce988bebd6c8b804d8bfdfafd511c40">&#9670;&nbsp;</a></span>setRotation3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setRotation3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rotation (X,Y,Z) in degrees. Useful for 3d rotations.</p>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation of the node in 3d.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a6ef719a2412711e81c3bfc40ce53c3e2">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#abe4bc651d6ce068c366edc18cb0aaead">MotionStreak3D</a>.</p>

</div>
</div>
<a id="ad53b989e70e96a62f2aabaa26094f4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53b989e70e96a62f2aabaa26094f4b0">&#9670;&nbsp;</a></span>setRotation3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setRotation3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rotation (X,Y,Z) in degrees. Useful for 3d rotations.</p>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation of the node in 3d.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a6ef719a2412711e81c3bfc40ce53c3e2">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#abe4bc651d6ce068c366edc18cb0aaead">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a59c0b9e9afc4668320d90c340e5727e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c0b9e9afc4668320d90c340e5727e7">&#9670;&nbsp;</a></span>setRotationQuat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setRotationQuat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set rotation by quaternion. You should make sure the quaternion is normalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>The rotation in quaternion, note that the quat must be normalized.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a7e9e94bce7204f28d6b8dff196d163d9">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#ab3b762bdfe6cbda5cda6b69ca8d31845">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a3da11f365bd691d42161cca0c729e5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da11f365bd691d42161cca0c729e5e5">&#9670;&nbsp;</a></span>setRotationQuat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setRotationQuat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set rotation by quaternion. You should make sure the quaternion is normalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>The rotation in quaternion, note that the quat must be normalized.  NA </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMotionStreak3D.html#a7e9e94bce7204f28d6b8dff196d163d9">MotionStreak3D</a>, and <a class="el" href="classMotionStreak3D.html#ab3b762bdfe6cbda5cda6b69ca8d31845">MotionStreak3D</a>.</p>

</div>
</div>
<a id="a66a533225994dbfe125c3421df4cbb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a533225994dbfe125c3421df4cbb38">&#9670;&nbsp;</a></span>setRotationSkewX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setRotationSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationX</td><td>The X rotation in degrees which performs a horizontal rotational skew.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.  setRotationX </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#adcc286e6eb86f3fd6242de9cdf321301">Sprite</a>, and <a class="el" href="classSprite.html#a8fe7bd093a18a2245c230b96f2c59897">Sprite</a>.</p>

</div>
</div>
<a id="a63c7e9e926cf94379b437a41eba0b111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c7e9e926cf94379b437a41eba0b111">&#9670;&nbsp;</a></span>setRotationSkewX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setRotationSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationX</td><td>The X rotation in degrees which performs a horizontal rotational skew.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.  setRotationX </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#adcc286e6eb86f3fd6242de9cdf321301">Sprite</a>, and <a class="el" href="classSprite.html#a8fe7bd093a18a2245c230b96f2c59897">Sprite</a>.</p>

</div>
</div>
<a id="a901c5fbd2327fbd6fd14771fd45d71af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901c5fbd2327fbd6fd14771fd45d71af">&#9670;&nbsp;</a></span>setRotationSkewY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setRotationSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationY</td><td>The Y rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.  setRotationY </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a5f3af508d1f9e146ac93c0eaad44dfb1">Sprite</a>, and <a class="el" href="classSprite.html#a7ed528b143e0a099f143bc1dbb39cdb1">Sprite</a>.</p>

</div>
</div>
<a id="abb8744ead180b08a285e56f59e5e178c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8744ead180b08a285e56f59e5e178c">&#9670;&nbsp;</a></span>setRotationSkewY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setRotationSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationY</td><td>The Y rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this.  setRotationY </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a5f3af508d1f9e146ac93c0eaad44dfb1">Sprite</a>, and <a class="el" href="classSprite.html#a7ed528b143e0a099f143bc1dbb39cdb1">Sprite</a>.</p>

</div>
</div>
<a id="acf0955a52f51a9d6c8b0c9267b1e8668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0955a52f51a9d6c8b0c9267b1e8668">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scale setter </p>
<p>Sets the scale (x,y,z) of the node.</p>
<p>It is a scaling factor that multiplies the width, height and depth of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale factor for both X and Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a6824394dc8d5f26668b5e6f8b3cae3ba">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#a5a48d940455148277f65a3f6c68f5442">Sprite</a>, <a class="el" href="classSprite.html#a91251019ce74f40cc8d0f04a1dbf70c1">Sprite</a>, <a class="el" href="classParticleSystem.html#a9bf57aacb9df62eb5e836c2504904678">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#ad53bd7f8621c6ea670a5c63866d7b682">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#aa614e1883fa58c0c7fefaa71d9055fd5">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a811bffaa1d3bae377c00a15edccb396f">ui::Widget</a>.</p>

</div>
</div>
<a id="a666da31a8bf7f106409ea8aef707f215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666da31a8bf7f106409ea8aef707f215">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the scale (x,y,z) of the node.</p>
<p>It is a scaling factor that multiplies the width, height and depth of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale factor for both X and Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a6824394dc8d5f26668b5e6f8b3cae3ba">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#a5a48d940455148277f65a3f6c68f5442">Sprite</a>, <a class="el" href="classSprite.html#a91251019ce74f40cc8d0f04a1dbf70c1">Sprite</a>, <a class="el" href="classParticleSystem.html#a9bf57aacb9df62eb5e836c2504904678">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#ad53bd7f8621c6ea670a5c63866d7b682">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#aa614e1883fa58c0c7fefaa71d9055fd5">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a811bffaa1d3bae377c00a15edccb396f">ui::Widget</a>.</p>

</div>
</div>
<a id="a31f8130cfd505a5c327c4cc66fe4fa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f8130cfd505a5c327c4cc66fe4fa69">&#9670;&nbsp;</a></span>setScale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scale setter </p>
<p>Sets the scale (x,y) of the node.</p>
<p>It is a scaling factor that multiplies the width and height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis. </td></tr>
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a5c98e355992ab8f4e4cfc2f4eac8e104">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#a52e1d2937d38baf4ad067f029e33b901">Sprite</a>, <a class="el" href="classSprite.html#aa91d58969ba99f1bfd3ade56bda6fc5c">Sprite</a>, <a class="el" href="classui_1_1Widget.html#a2ff6617263887b25fdb0ac06ac94f31a">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#ace618234c5e35f66a9c569027cc9c5cf">ui::Widget</a>.</p>

</div>
</div>
<a id="a4a3e5ab7d2a14b166ba539f0db9010e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3e5ab7d2a14b166ba539f0db9010e3">&#9670;&nbsp;</a></span>setScale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the scale (x,y) of the node.</p>
<p>It is a scaling factor that multiplies the width and height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis. </td></tr>
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a5c98e355992ab8f4e4cfc2f4eac8e104">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#a52e1d2937d38baf4ad067f029e33b901">Sprite</a>, <a class="el" href="classSprite.html#aa91d58969ba99f1bfd3ade56bda6fc5c">Sprite</a>, <a class="el" href="classui_1_1Widget.html#a2ff6617263887b25fdb0ac06ac94f31a">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#ace618234c5e35f66a9c569027cc9c5cf">ui::Widget</a>.</p>

</div>
</div>
<a id="acf7f04074f7f49972e152788c090b877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7f04074f7f49972e152788c090b877">&#9670;&nbsp;</a></span>setScaleX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScaleX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleX setter </p>
<p>Sets the scale (x) of the node.</p>
<p>It is a scaling factor that multiplies the width of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7f9db0e954aca485c0d37a665927881c">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#af688d9902835f46c9690b29ab5a001a3">Sprite</a>, <a class="el" href="classSprite.html#a94c2d64bfcfd193f6b9ec927f9bb44b7">Sprite</a>, <a class="el" href="classParticleSystem.html#a48e07e72b7694502ed1375c1df37f9fe">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#aa1634f3d3f3d13ad5d3c14f901be0bc0">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a70186a0520486c8706b6326be6453fb4">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a7163529b3d2f436adec05d3ae6c3cb75">ui::Widget</a>.</p>

</div>
</div>
<a id="a49f8182769547584d8d7297b7a946da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f8182769547584d8d7297b7a946da4">&#9670;&nbsp;</a></span>setScaleX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScaleX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the scale (x) of the node.</p>
<p>It is a scaling factor that multiplies the width of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7f9db0e954aca485c0d37a665927881c">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#af688d9902835f46c9690b29ab5a001a3">Sprite</a>, <a class="el" href="classSprite.html#a94c2d64bfcfd193f6b9ec927f9bb44b7">Sprite</a>, <a class="el" href="classParticleSystem.html#a48e07e72b7694502ed1375c1df37f9fe">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#aa1634f3d3f3d13ad5d3c14f901be0bc0">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a70186a0520486c8706b6326be6453fb4">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#a7163529b3d2f436adec05d3ae6c3cb75">ui::Widget</a>.</p>

</div>
</div>
<a id="aec805a1fa9e8e1038556e468138bb804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec805a1fa9e8e1038556e468138bb804">&#9670;&nbsp;</a></span>setScaleY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScaleY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleY setter </p>
<p>Sets the scale (y) of the node.</p>
<p>It is a scaling factor that multiplies the height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7c108e20a3b0b479258447335531bfe2">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#ab7e7db21d5cd13269074fde7195fa3e2">Sprite</a>, <a class="el" href="classSprite.html#a167e418b057071cbaf57f75f7c88c9df">Sprite</a>, <a class="el" href="classParticleSystem.html#a1e6720f314dfec3f5b7ca02c305ea28e">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a3b3ba015dde4abcf804692cacef4f575">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a8d68ee46f555dc23b8fcec84542eadcc">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#acac2f88e6a4fb013377bc981a4a10c57">ui::Widget</a>.</p>

</div>
</div>
<a id="af464e6b40bc036450fed05f8c74103e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af464e6b40bc036450fed05f8c74103e7">&#9670;&nbsp;</a></span>setScaleY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScaleY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the scale (y) of the node.</p>
<p>It is a scaling factor that multiplies the height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classui_1_1Scale9Sprite.html#a7c108e20a3b0b479258447335531bfe2">ui::Scale9Sprite</a>, <a class="el" href="classSprite.html#ab7e7db21d5cd13269074fde7195fa3e2">Sprite</a>, <a class="el" href="classSprite.html#a167e418b057071cbaf57f75f7c88c9df">Sprite</a>, <a class="el" href="classParticleSystem.html#a1e6720f314dfec3f5b7ca02c305ea28e">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a3b3ba015dde4abcf804692cacef4f575">ParticleSystem</a>, <a class="el" href="classui_1_1Widget.html#a8d68ee46f555dc23b8fcec84542eadcc">ui::Widget</a>, and <a class="el" href="classui_1_1Widget.html#acac2f88e6a4fb013377bc981a4a10c57">ui::Widget</a>.</p>

</div>
</div>
<a id="a79518b90226335e0997552687eb7b33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79518b90226335e0997552687eb7b33f">&#9670;&nbsp;</a></span>setScaleZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScaleZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scaleY setter </p>
<p>Changes the scale factor on Z axis of this node</p>
<p>The Default value is 1.0 if you haven't changed it before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleZ</td><td>The scale factor on Z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

</div>
</div>
<a id="aeaafb9dc116fdf029f51c7d3e6011a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaafb9dc116fdf029f51c7d3e6011a7f">&#9670;&nbsp;</a></span>setScaleZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScaleZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the scale factor on Z axis of this node</p>
<p>The Default value is 1.0 if you haven't changed it before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleZ</td><td>The scale factor on Z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

</div>
</div>
<a id="a9f0c84dfabdce76b5251725944ae7706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c84dfabdce76b5251725944ae7706">&#9670;&nbsp;</a></span>setScheduler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object that is used to schedule all "updates" and timers.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you set a new <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a>, then previously created timers/update are going to be removed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>A <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object that is used to schedule all "update" and timers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06d543a8e7750e30ba3d1efe0de336de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d543a8e7750e30ba3d1efe0de336de">&#9670;&nbsp;</a></span>setScheduler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScheduler.html">Scheduler</a> *&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object that is used to schedule all "updates" and timers.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you set a new <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a>, then previously created timers/update are going to be removed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>A <a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> object that is used to schedule all "update" and timers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48cf4d7b304b57a3f593d9eecde3ac7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cf4d7b304b57a3f593d9eecde3ac7f">&#9670;&nbsp;</a></span>setSkewX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the X skew angle of the node in degrees.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the X direction. Thus, it is the angle between the Y coordinate and the left edge of the shape The default skewX angle is 0. Positive values distort the node in a CW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewX</td><td>The X skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a975b779e48841943ebbe5147331fc8c2">Sprite</a>, and <a class="el" href="classSprite.html#ae6ad4d3c0f8be8d4ac45a0c1f8012896">Sprite</a>.</p>

</div>
</div>
<a id="a237a875e4c96d5ef4286d8fa31062047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237a875e4c96d5ef4286d8fa31062047">&#9670;&nbsp;</a></span>setSkewX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the X skew angle of the node in degrees.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the X direction. Thus, it is the angle between the Y coordinate and the left edge of the shape The default skewX angle is 0. Positive values distort the node in a CW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewX</td><td>The X skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a975b779e48841943ebbe5147331fc8c2">Sprite</a>, and <a class="el" href="classSprite.html#ae6ad4d3c0f8be8d4ac45a0c1f8012896">Sprite</a>.</p>

</div>
</div>
<a id="ac1f4c4be8099a0d4bca1464c51f81f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f4c4be8099a0d4bca1464c51f81f94">&#9670;&nbsp;</a></span>setSkewY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the Y skew angle of the node in degrees.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the Y direction. Thus, it is the angle between the X coordinate and the bottom edge of the shape. The default skewY angle is 0. Positive values distort the node in a CCW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewY</td><td>The Y skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a5472345454102a7682c929b974573879">Sprite</a>, and <a class="el" href="classSprite.html#ab1d4bdeffe2b1fa8720481316123316a">Sprite</a>.</p>

</div>
</div>
<a id="aa785fa12d35c571bac718f7b025cc684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa785fa12d35c571bac718f7b025cc684">&#9670;&nbsp;</a></span>setSkewY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the Y skew angle of the node in degrees.</p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the Y direction. Thus, it is the angle between the X coordinate and the bottom edge of the shape. The default skewY angle is 0. Positive values distort the node in a CCW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewY</td><td>The Y skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#a5472345454102a7682c929b974573879">Sprite</a>, and <a class="el" href="classSprite.html#ab1d4bdeffe2b1fa8720481316123316a">Sprite</a>.</p>

</div>
</div>
<a id="a41ecfc5e9e398e70dfe2e158f926c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ecfc5e9e398e70dfe2e158f926c16f">&#9670;&nbsp;</a></span>setTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tag setter </p>
<p>Changes the tag that is used to identify the node easily.</p>
<p>Please refer to getTag for the sample code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A integer that identifies the node.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code><a class="el" href="classNode.html#a519730c66b26e65c6539a908e6905edc">setName()</a></code> instead. </p>

</div>
</div>
<a id="ad07179e61008c76e7a996636267c74a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07179e61008c76e7a996636267c74a5">&#9670;&nbsp;</a></span>setTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the tag that is used to identify the node easily.</p>
<p>Please refer to getTag for the sample code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A integer that identifies the node.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code><a class="el" href="classNode.html#a519730c66b26e65c6539a908e6905edc">setName()</a></code> instead. </p>

</div>
</div>
<a id="ad07f1d7702df679c5d07772bcfd316a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07f1d7702df679c5d07772bcfd316a2">&#9670;&nbsp;</a></span>setUserData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>userData setter </p>
<p>Sets a custom user data pointer.</p>
<p>You can set everything in UserData pointer, a data block, a structure or an object, etc. </p><dl class="section warning"><dt>Warning</dt><dd>Don't forget to release the memory manually, especially before you change this data pointer, and before this node is autoreleased.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>A custom user data pointer.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd8dc715df27f90ec04f795495836d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd8dc715df27f90ec04f795495836d7">&#9670;&nbsp;</a></span>setUserData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a custom user data pointer.</p>
<p>You can set everything in UserData pointer, a data block, a structure or an object, etc. </p><dl class="section warning"><dt>Warning</dt><dd>Don't forget to release the memory manually, especially before you change this data pointer, and before this node is autoreleased.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>A custom user data pointer.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9ccf509ea89dcbd94e3b1d383aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ccf509ea89dcbd94e3b1d383aeda6f">&#9670;&nbsp;</a></span>setUserObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setUserObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>userObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a user assigned Object.</p>
<p>Similar to UserData, but instead of holding a void* it holds an object. The UserObject will be retained once in this method, and the previous UserObject (if existed) will be released. The UserObject will be released in <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userObject</td><td>A user assigned Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a306c369ecb71feb0206b277d9bf81fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306c369ecb71feb0206b277d9bf81fab">&#9670;&nbsp;</a></span>setUserObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setUserObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>userObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a user assigned Object.</p>
<p>Similar to UserData, but instead of holding a void* it holds an object. The UserObject will be retained once in this method, and the previous UserObject (if existed) will be released. The UserObject will be released in <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>'s destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userObject</td><td>A user assigned Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8d9f6f838941a2a8ae18420757af158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d9f6f838941a2a8ae18420757af158">&#9670;&nbsp;</a></span>setVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isVisible setter </p>
<p>Sets whether the node is visible.</p>
<p>The default value is true, a node is default to visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>true if the node is visible, false if the node is hidden. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a73a03efc1b904b6386d037fdcdc7ff92">ui::EditBox</a>, <a class="el" href="classSprite.html#a5bf8d98b0feb78acf0bbf4b3b3fa6d59">Sprite</a>, <a class="el" href="classSprite.html#abdaaa50259a13af3d6e8effded4ba42b">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#afd90efc8e80090f96e54f39520405883">ui::EditBox</a>, <a class="el" href="classLabelLetter.html#aa46db980ecd91de0f00c7aee1f2f52f9">LabelLetter</a>, and <a class="el" href="classLabelLetter.html#aa46db980ecd91de0f00c7aee1f2f52f9">LabelLetter</a>.</p>

</div>
</div>
<a id="aa6dd28750fa14ef6e2ec4525c4491ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dd28750fa14ef6e2ec4525c4491ad8">&#9670;&nbsp;</a></span>setVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether the node is visible.</p>
<p>The default value is true, a node is default to visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>true if the node is visible, false if the node is hidden. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classui_1_1EditBox.html#a73a03efc1b904b6386d037fdcdc7ff92">ui::EditBox</a>, <a class="el" href="classSprite.html#a5bf8d98b0feb78acf0bbf4b3b3fa6d59">Sprite</a>, <a class="el" href="classSprite.html#abdaaa50259a13af3d6e8effded4ba42b">Sprite</a>, <a class="el" href="classui_1_1EditBox.html#afd90efc8e80090f96e54f39520405883">ui::EditBox</a>, <a class="el" href="classLabelLetter.html#aa46db980ecd91de0f00c7aee1f2f52f9">LabelLetter</a>, and <a class="el" href="classLabelLetter.html#aa46db980ecd91de0f00c7aee1f2f52f9">LabelLetter</a>.</p>

</div>
</div>
<a id="adfaeea03013d3eae710c4d4d725bce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaeea03013d3eae710c4d4d725bce0b">&#9670;&nbsp;</a></span>sortAllChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::sortAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the children array once before drawing, instead of every time when a child is added or reordered. This approach can improves the performance massively. </p><dl class="section note"><dt>Note</dt><dd>Don't call this manually unless a child added needs to be removed in the same frame. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#ae3553d2d41b7c9fb764fc0ca1b41ef86">Sprite</a>, <a class="el" href="classSprite.html#adf75ebee22c9ff3f4d72f99c86ff365c">Sprite</a>, <a class="el" href="classSpriteBatchNode.html#a939e68291147526d7d452a310b59b0b7">SpriteBatchNode</a>, and <a class="el" href="classSpriteBatchNode.html#af2a850d2c664d2fd1a796601129a0413">SpriteBatchNode</a>.</p>

</div>
</div>
<a id="a5911e98e2230b164daf283f707e1748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5911e98e2230b164daf283f707e1748d">&#9670;&nbsp;</a></span>sortAllChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::sortAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the children array once before drawing, instead of every time when a child is added or reordered. This approach can improve the performance massively. </p><dl class="section note"><dt>Note</dt><dd>Don't call this manually unless a child added needs to be removed in the same frame. </dd></dl>

<p>Reimplemented in <a class="el" href="classSprite.html#ae3553d2d41b7c9fb764fc0ca1b41ef86">Sprite</a>, <a class="el" href="classSprite.html#adf75ebee22c9ff3f4d72f99c86ff365c">Sprite</a>, <a class="el" href="classSpriteBatchNode.html#a939e68291147526d7d452a310b59b0b7">SpriteBatchNode</a>, and <a class="el" href="classSpriteBatchNode.html#af2a850d2c664d2fd1a796601129a0413">SpriteBatchNode</a>.</p>

</div>
</div>
<a id="a17a2149cbfe0819a11f3e109cc67645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a2149cbfe0819a11f3e109cc67645c">&#9670;&nbsp;</a></span>sortNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Node::sortNodes </td>
          <td>(</td>
          <td class="paramtype">cocos2d::Vector&lt; _T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts helper function </p>

</div>
</div>
<a id="a17a2149cbfe0819a11f3e109cc67645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a2149cbfe0819a11f3e109cc67645c">&#9670;&nbsp;</a></span>sortNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Node::sortNodes </td>
          <td>(</td>
          <td class="paramtype">cocos2d::Vector&lt; _T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts helper function </p>

</div>
</div>
<a id="a7f07a11c8550f7be6b6215b56ab69723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f07a11c8550f7be6b6215b56ab69723">&#9670;&nbsp;</a></span>stopAction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAction.html">Action</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops and removes an action from the running action <a class="el" href="protocollist-p.html">list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action object to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f07a11c8550f7be6b6215b56ab69723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f07a11c8550f7be6b6215b56ab69723">&#9670;&nbsp;</a></span>stopAction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAction.html">Action</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops and removes an action from the running action <a class="el" href="protocollist-p.html">list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action object to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58833aec8d21bf1ed647865c220c7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58833aec8d21bf1ed647865c220c7c49">&#9670;&nbsp;</a></span>stopActionByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopActionByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an action from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A tag that indicates the action to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58833aec8d21bf1ed647865c220c7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58833aec8d21bf1ed647865c220c7c49">&#9670;&nbsp;</a></span>stopActionByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopActionByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an action from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A tag that indicates the action to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36eef67f2b7d8026328d452e9a5ab09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eef67f2b7d8026328d452e9a5ab09c">&#9670;&nbsp;</a></span>stopActionsByFlags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopActionsByFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> by its flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A flag field that removes actions based on bitwise AND. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36eef67f2b7d8026328d452e9a5ab09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eef67f2b7d8026328d452e9a5ab09c">&#9670;&nbsp;</a></span>stopActionsByFlags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopActionsByFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> by its flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A flag field that removes actions based on bitwise AND. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d542784d864cffe325e9e32d180aa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d542784d864cffe325e9e32d180aa6d">&#9670;&nbsp;</a></span>stopAllActions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAllActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops and removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> . </p>

</div>
</div>
<a id="a1d542784d864cffe325e9e32d180aa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d542784d864cffe325e9e32d180aa6d">&#9670;&nbsp;</a></span>stopAllActions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAllActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops and removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> . </p>

</div>
</div>
<a id="a70f8518979a58094c1ed2dbbe7ebcb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f8518979a58094c1ed2dbbe7ebcb9f">&#9670;&nbsp;</a></span>stopAllActionsByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAllActionsByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A tag that indicates the action to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f8518979a58094c1ed2dbbe7ebcb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f8518979a58094c1ed2dbbe7ebcb9f">&#9670;&nbsp;</a></span>stopAllActionsByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::stopAllActionsByTag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all actions from the running action <a class="el" href="protocollist-p.html">list</a> by its tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A tag that indicates the action to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04fd599a10f38d31fa0c07bfda6cc90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fd599a10f38d31fa0c07bfda6cc90c">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unschedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a custom selector. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function wrapped as a selector.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7864aa1e9a8391007eca370628d3ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7864aa1e9a8391007eca370628d3ce7">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unschedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a lambda function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the lambda function to be unscheduled.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04fd599a10f38d31fa0c07bfda6cc90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fd599a10f38d31fa0c07bfda6cc90c">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unschedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a custom selector. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classNode.html#a5957efe46bfe7f83f9adb5b737f7ce11">schedule(SEL_SCHEDULE, float, unsigned int, float)</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>A function wrapped as a selector.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7864aa1e9a8391007eca370628d3ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7864aa1e9a8391007eca370628d3ce7">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unschedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a lambda function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the lambda function to be unscheduled.  NA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8711d9b97d8b944a95c4227c7e9869f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8711d9b97d8b944a95c4227c7e9869f">&#9670;&nbsp;</a></span>unscheduleAllCallbacks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unscheduleAllCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedule all scheduled selectors and lambda functions: custom selectors, and the 'update' selector and lambda functions. <a class="el" href="classActions.html">Actions</a> are not affected by this method.  NA </p>

</div>
</div>
<a id="ab8711d9b97d8b944a95c4227c7e9869f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8711d9b97d8b944a95c4227c7e9869f">&#9670;&nbsp;</a></span>unscheduleAllCallbacks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::unscheduleAllCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedule all scheduled selectors and lambda functions: custom selectors, and the 'update' selector and lambda functions. <a class="el" href="classActions.html">Actions</a> are not affected by this method.  NA </p>

</div>
</div>
<a id="a32878481ba54b3856ab53c10af13848e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32878481ba54b3856ab53c10af13848e">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update method will be called automatically every frame if "scheduleUpdate" is called, and the node is "live". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>In seconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classParticleSystem.html#ac2b03d34a27150678a2737453ad1b7e3">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a11a1c88736ddcd626ba8039b4268e82e">ParticleSystem</a>, <a class="el" href="classui_1_1TextField.html#a7684f9503909dfc66085922bd52ec449">ui::TextField</a>, <a class="el" href="classui_1_1TextField.html#a9caf0239e6855d3f608946b432b9ad59">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#a4daad841add32c92b12e8c4c909b2b2e">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#a15b50cbbccdeff8dd34e8d0ab6ea82f7">ui::ScrollView</a>, <a class="el" href="classTextFieldTTF.html#a81ad55bca952a4927d3c4acfe8385030">TextFieldTTF</a>, <a class="el" href="classPUParticleSystem3D.html#a42ba23b8909057126e8a9606f9cd4e8c">PUParticleSystem3D</a>, <a class="el" href="classPUParticleSystem3D.html#a9fdfe542cd05fcf270644dff49f81857">PUParticleSystem3D</a>, <a class="el" href="classTextFieldTTF.html#a004230b3dc3f90069b3094152e7c8eb0">TextFieldTTF</a>, <a class="el" href="classParticleSystem3D.html#a446b0819b60fb46ce308e3d17e7625b0">ParticleSystem3D</a>, <a class="el" href="classParticleSystem3D.html#a04fb4f09a517f393b5deb8174b964e40">ParticleSystem3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a9584b184a09bc1bf24f1a8805641294b">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a26112897dfbfd6d3d727337f65177f1f">ui::ScrollViewBar</a>, <a class="el" href="classMotionStreak.html#a03d1e1113084f8e91b537539e7c19b9c">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a915b84eec6e1e4576d9aa0c1e6528fe7">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a3d336bcb41bd598ba73389378b278382">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a195dbdebb5c5d55d3d09c4e5dc716a91">MotionStreak3D</a>, <a class="el" href="classControlStepper.html#a29a2d69a159c790691365db8a9f87d33">ControlStepper</a>, and <a class="el" href="classControlStepper.html#a29a2d69a159c790691365db8a9f87d33">ControlStepper</a>.</p>

</div>
</div>
<a id="ac907777c1012f808043412c76cf9e183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac907777c1012f808043412c76cf9e183">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update method will be called automatically every frame if "scheduleUpdate" is called, and the node is "live". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>In seconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classParticleSystem.html#ac2b03d34a27150678a2737453ad1b7e3">ParticleSystem</a>, <a class="el" href="classParticleSystem.html#a11a1c88736ddcd626ba8039b4268e82e">ParticleSystem</a>, <a class="el" href="classui_1_1TextField.html#a7684f9503909dfc66085922bd52ec449">ui::TextField</a>, <a class="el" href="classui_1_1TextField.html#a9caf0239e6855d3f608946b432b9ad59">ui::TextField</a>, <a class="el" href="classui_1_1ScrollView.html#a4daad841add32c92b12e8c4c909b2b2e">ui::ScrollView</a>, <a class="el" href="classui_1_1ScrollView.html#a15b50cbbccdeff8dd34e8d0ab6ea82f7">ui::ScrollView</a>, <a class="el" href="classTextFieldTTF.html#a81ad55bca952a4927d3c4acfe8385030">TextFieldTTF</a>, <a class="el" href="classPUParticleSystem3D.html#a42ba23b8909057126e8a9606f9cd4e8c">PUParticleSystem3D</a>, <a class="el" href="classPUParticleSystem3D.html#a9fdfe542cd05fcf270644dff49f81857">PUParticleSystem3D</a>, <a class="el" href="classTextFieldTTF.html#a004230b3dc3f90069b3094152e7c8eb0">TextFieldTTF</a>, <a class="el" href="classParticleSystem3D.html#a446b0819b60fb46ce308e3d17e7625b0">ParticleSystem3D</a>, <a class="el" href="classParticleSystem3D.html#a04fb4f09a517f393b5deb8174b964e40">ParticleSystem3D</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a9584b184a09bc1bf24f1a8805641294b">ui::ScrollViewBar</a>, <a class="el" href="classui_1_1ScrollViewBar.html#a26112897dfbfd6d3d727337f65177f1f">ui::ScrollViewBar</a>, <a class="el" href="classMotionStreak.html#a03d1e1113084f8e91b537539e7c19b9c">MotionStreak</a>, <a class="el" href="classMotionStreak.html#a915b84eec6e1e4576d9aa0c1e6528fe7">MotionStreak</a>, <a class="el" href="classMotionStreak3D.html#a3d336bcb41bd598ba73389378b278382">MotionStreak3D</a>, <a class="el" href="classMotionStreak3D.html#a195dbdebb5c5d55d3d09c4e5dc716a91">MotionStreak3D</a>, <a class="el" href="classControlStepper.html#a29a2d69a159c790691365db8a9f87d33">ControlStepper</a>, and <a class="el" href="classControlStepper.html#a29a2d69a159c790691365db8a9f87d33">ControlStepper</a>.</p>

</div>
</div>
<a id="ac733bae7b9590f8da746cbc3d1337a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac733bae7b9590f8da746cbc3d1337a2f">&#9670;&nbsp;</a></span>updateDisplayedColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateDisplayedColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td>
          <td class="paramname"><em>parentColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update node's displayed color with its parent color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentColor</td><td>A <a class="el" href="structColor3B.html">Color3B</a> color value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a7b792b469020beebcd515a2eacba90f7">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a7b792b469020beebcd515a2eacba90f7">__NodeRGBA</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a130c78092b506d4b06fec469e80c554c">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a5810437c76649477d86f278a15e5f260">Label</a>, <a class="el" href="classLabel.html#a22ddaa3b9fb25f6295dcd5ac9545202b">Label</a>, <a class="el" href="class____LayerRGBA.html#aa0406779f58fc6586f51129bee7aed36">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#aa0406779f58fc6586f51129bee7aed36">__LayerRGBA</a>, <a class="el" href="classControlButton.html#ab493879910cbb468f4f510a3e9393203">ControlButton</a>, <a class="el" href="classControlButton.html#a3f7857c3ce4bec5b375db1a6efea5920">ControlButton</a>, <a class="el" href="classProtectedNode.html#ab628cf3ac452302f0c653600bb145b49">ProtectedNode</a>, and <a class="el" href="classProtectedNode.html#a53b09aefb1db2c87f6ee6560b0c48430">ProtectedNode</a>.</p>

</div>
</div>
<a id="a9e96bdf8038cd786486941f2f5a712ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e96bdf8038cd786486941f2f5a712ea">&#9670;&nbsp;</a></span>updateDisplayedColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::updateDisplayedColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColor3B.html">Color3B</a> &amp;&#160;</td>
          <td class="paramname"><em>parentColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update node's displayed color with its parent color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentColor</td><td>A <a class="el" href="structColor3B.html">Color3B</a> color value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a7b792b469020beebcd515a2eacba90f7">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a7b792b469020beebcd515a2eacba90f7">__NodeRGBA</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a130c78092b506d4b06fec469e80c554c">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a5810437c76649477d86f278a15e5f260">Label</a>, <a class="el" href="classLabel.html#a22ddaa3b9fb25f6295dcd5ac9545202b">Label</a>, <a class="el" href="class____LayerRGBA.html#aa0406779f58fc6586f51129bee7aed36">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#aa0406779f58fc6586f51129bee7aed36">__LayerRGBA</a>, <a class="el" href="classControlButton.html#ab493879910cbb468f4f510a3e9393203">ControlButton</a>, <a class="el" href="classControlButton.html#a3f7857c3ce4bec5b375db1a6efea5920">ControlButton</a>, <a class="el" href="classProtectedNode.html#ab628cf3ac452302f0c653600bb145b49">ProtectedNode</a>, and <a class="el" href="classProtectedNode.html#a53b09aefb1db2c87f6ee6560b0c48430">ProtectedNode</a>.</p>

</div>
</div>
<a id="a3a0122884e7e1ce310b8b68abfbb245b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0122884e7e1ce310b8b68abfbb245b">&#9670;&nbsp;</a></span>updateDisplayedOpacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateDisplayedOpacity </td>
          <td>(</td>
          <td class="paramtype">GLubyte&#160;</td>
          <td class="paramname"><em>parentOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the displayed opacity of node with it's parent opacity; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentOpacity</td><td>The opacity of parent node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a428c41148bb3d1fe27d7eac80bb6df59">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a428c41148bb3d1fe27d7eac80bb6df59">__NodeRGBA</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a85bca0738c6bff049fe0a962d285bda4">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a89d48e49df588b91d259cac6f8732162">Label</a>, <a class="el" href="classLabel.html#a20eff3ff123e54a021c4149a7fcf0494">Label</a>, <a class="el" href="class____LayerRGBA.html#a53e78a19fb9780fec84476f1bce1d3f6">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a53e78a19fb9780fec84476f1bce1d3f6">__LayerRGBA</a>, <a class="el" href="classControlButton.html#a0d46b6a123c22e09c50e786b6dd5c68f">ControlButton</a>, <a class="el" href="classControlButton.html#a51a1da3e1972b7e1d98e2318feaf498e">ControlButton</a>, <a class="el" href="classProtectedNode.html#aef8f27d6204a82d0ed5372e9082d12ae">ProtectedNode</a>, and <a class="el" href="classProtectedNode.html#abe8e7d89709e01b0500ae8cf63991806">ProtectedNode</a>.</p>

</div>
</div>
<a id="aed685e5e2976c1387525aae96f39f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed685e5e2976c1387525aae96f39f4f5">&#9670;&nbsp;</a></span>updateDisplayedOpacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::updateDisplayedOpacity </td>
          <td>(</td>
          <td class="paramtype">GLubyte&#160;</td>
          <td class="paramname"><em>parentOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the displayed opacity of node with it's parent opacity; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentOpacity</td><td>The opacity of parent node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class____NodeRGBA.html#a428c41148bb3d1fe27d7eac80bb6df59">__NodeRGBA</a>, <a class="el" href="class____NodeRGBA.html#a428c41148bb3d1fe27d7eac80bb6df59">__NodeRGBA</a>, <a class="el" href="classui_1_1Scale9Sprite.html#a85bca0738c6bff049fe0a962d285bda4">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#a89d48e49df588b91d259cac6f8732162">Label</a>, <a class="el" href="classLabel.html#a20eff3ff123e54a021c4149a7fcf0494">Label</a>, <a class="el" href="class____LayerRGBA.html#a53e78a19fb9780fec84476f1bce1d3f6">__LayerRGBA</a>, <a class="el" href="class____LayerRGBA.html#a53e78a19fb9780fec84476f1bce1d3f6">__LayerRGBA</a>, <a class="el" href="classControlButton.html#a0d46b6a123c22e09c50e786b6dd5c68f">ControlButton</a>, <a class="el" href="classControlButton.html#a51a1da3e1972b7e1d98e2318feaf498e">ControlButton</a>, <a class="el" href="classProtectedNode.html#aef8f27d6204a82d0ed5372e9082d12ae">ProtectedNode</a>, and <a class="el" href="classProtectedNode.html#abe8e7d89709e01b0500ae8cf63991806">ProtectedNode</a>.</p>

</div>
</div>
<a id="a75318d1418261ae7e8856ba2868b5a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75318d1418261ae7e8856ba2868b5a81">&#9670;&nbsp;</a></span>updateOrderOfArrival() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateOrderOfArrival </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>!!! ONLY FOR INTERNAL USE Sets the arrival order when this node has a same ZOrder with other children.</p>
<p>A node which called addChild subsequently will take a larger arrival order, If two children have the same Z order, the child with larger arrival order will be drawn later.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is used internally for localZOrder sorting, don't change this manually</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orderOfArrival</td><td>The arrival order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75318d1418261ae7e8856ba2868b5a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75318d1418261ae7e8856ba2868b5a81">&#9670;&nbsp;</a></span>updateOrderOfArrival() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateOrderOfArrival </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>!!! ONLY FOR INTERNAL USE Sets the arrival order when this node has a same ZOrder with other children.</p>
<p>A node which called addChild subsequently will take a larger arrival order, If two children have the same Z order, the child with larger arrival order will be drawn later.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is used internally for localZOrder sorting, don't change this manually</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orderOfArrival</td><td>The arrival order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8583decfa6069f06ec1e9f8080c1ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583decfa6069f06ec1e9f8080c1ae36">&#9670;&nbsp;</a></span>updateTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateTransform </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls children's <a class="el" href="classNode.html#a8583decfa6069f06ec1e9f8080c1ae36">updateTransform()</a> method recursively.</p>
<p>This method is moved from <a class="el" href="classSprite.html">Sprite</a>, so it's no longer specific to <a class="el" href="classSprite.html">Sprite</a>. As the result, you apply <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a>'s optimization on your customed <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>. e.g., <code>batchNode-&gt;addChild(myCustomNode)</code>, while you can only addChild(sprite) before. </p>

<p>Reimplemented in <a class="el" href="classSprite.html#aa486a133eeb98d0872f4a71e5926aeeb">Sprite</a>, <a class="el" href="classSprite.html#a6b64d23ba646325021c2a5118dc5163d">Sprite</a>, <a class="el" href="classLabelLetter.html#ae52821b1e8fb7782602524f23c23b3ac">LabelLetter</a>, and <a class="el" href="classLabelLetter.html#ae52821b1e8fb7782602524f23c23b3ac">LabelLetter</a>.</p>

</div>
</div>
<a id="ae570e9d69b67d8f182c076b002fe2d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae570e9d69b67d8f182c076b002fe2d08">&#9670;&nbsp;</a></span>updateTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::updateTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls children's <a class="el" href="classNode.html#a8583decfa6069f06ec1e9f8080c1ae36">updateTransform()</a> method recursively.</p>
<p>This method is moved from <a class="el" href="classSprite.html">Sprite</a>, so it's no longer specific to <a class="el" href="classSprite.html">Sprite</a>. As the result, you apply <a class="el" href="classSpriteBatchNode.html">SpriteBatchNode</a>'s optimization on your customed <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>. e.g., <code>batchNode-&gt;addChild(myCustomNode)</code>, while you can only addChild(sprite) before. </p>

<p>Reimplemented in <a class="el" href="classSprite.html#aa486a133eeb98d0872f4a71e5926aeeb">Sprite</a>, <a class="el" href="classSprite.html#a6b64d23ba646325021c2a5118dc5163d">Sprite</a>, <a class="el" href="classLabelLetter.html#ae52821b1e8fb7782602524f23c23b3ac">LabelLetter</a>, and <a class="el" href="classLabelLetter.html#ae52821b1e8fb7782602524f23c23b3ac">LabelLetter</a>.</p>

</div>
</div>
<a id="a7d794a5e30745611ec33881a625edf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d794a5e30745611ec33881a625edf26">&#9670;&nbsp;</a></span>visit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRenderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>parentTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parentFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Visits this node's children and draw them recursively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A given renderer. </td></tr>
    <tr><td class="paramname">parentTransform</td><td>A transform matrix. </td></tr>
    <tr><td class="paramname">parentFlags</td><td><a class="el" href="classRenderer.html">Renderer</a> flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a380d30d32cf8f19f28418e706d5929b5">Label</a>, <a class="el" href="classui_1_1Scale9Sprite.html#ad939fbf33d73420369e251a990b01bc2">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#ae8e300dcf7e2a6b98e2ae39632d290c8">Label</a>, <a class="el" href="classui_1_1Layout.html#a7857b109e0d674106c9fe22830ef4076">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a46a4f4f4836e1b9c985acb26f8fa4163">ui::Layout</a>, <a class="el" href="classDrawNode.html#adffd70536383fa1dd73ab4a6e785808a">DrawNode</a>, <a class="el" href="classCamera.html#add749a2d2338f0373a6a440e4cba5afa">Camera</a>, <a class="el" href="classCamera.html#a9af4106a5c83986160cb975d53205fce">Camera</a>, <a class="el" href="classRenderTexture.html#a92007b10e5dab891532bd0daa1a24be8">RenderTexture</a>, <a class="el" href="classRenderTexture.html#a57e0f63ce401e1b5915882f7be1884db">RenderTexture</a>, <a class="el" href="classScrollView.html#a7aee8e0ccdc8235a7ed9e2932ccdcf25">ScrollView</a>, <a class="el" href="classScrollView.html#a9766dfe15b34a8d7d1e3fd7b6acfcc32">ScrollView</a>, <a class="el" href="classTextFieldTTF.html#a4e4d61648a15b14774923fc8d2738683">TextFieldTTF</a>, <a class="el" href="classSprite3D.html#a7c6db1d1a851a0a1d2ca17f4c9ad8c67">Sprite3D</a>, <a class="el" href="classSprite3D.html#a7c6db1d1a851a0a1d2ca17f4c9ad8c67">Sprite3D</a>, <a class="el" href="classTextFieldTTF.html#af7cb31f513a3699cac12a42aebcd8bec">TextFieldTTF</a>, <a class="el" href="classSpriteBatchNode.html#a2cccb328ace35dc3e02d7ca8824df65d">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#afcdd1f0032ac902a52256fee7687cc36">SpriteBatchNode</a>, <a class="el" href="classProtectedNode.html#a705c838f46afa1b9eac5dae2aa4bc310">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#afb1b2f3712d91a38bd5c691eeec6bbb9">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a2c3e648bc28a51189cecda4ae431e38b">ClippingNode</a>, <a class="el" href="classClippingNode.html#abe6402dbaf99cbf1e4b16add726b2a56">ClippingNode</a>, <a class="el" href="classParticleBatchNode.html#af1dd3c3d3e8d7d17d0b1b00d634eb434">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ad11baa30bf900df09491dd652d16b954">ParticleBatchNode</a>, <a class="el" href="classBillBoard.html#ae51a82da848a1a3c70cf109cdb1b79ba">BillBoard</a>, <a class="el" href="classBillBoard.html#a2caec4c849717693e62be305a0ca789c">BillBoard</a>, <a class="el" href="classClippingRectangleNode.html#acffefe2919ca5110110e091d79448260">ClippingRectangleNode</a>, <a class="el" href="classClippingRectangleNode.html#ae875ea898f086aa7106b803ddbcbf47f">ClippingRectangleNode</a>, <a class="el" href="classNodeGrid.html#accaa8bcbf32f1d9e2b62ae0103ff5169">NodeGrid</a>, <a class="el" href="classNodeGrid.html#afb46783d7e7fdaf8e3d58c0dde9ebd21">NodeGrid</a>, <a class="el" href="classParallaxNode.html#a3e451b09972ed6e158c7b8f88da4b636">ParallaxNode</a>, <a class="el" href="classParallaxNode.html#aee4c2a79089a02e872db670ed07638c1">ParallaxNode</a>, <a class="el" href="classAttachNode.html#a34dd14d134d83f3c5458bf4ea94361fe">AttachNode</a>, and <a class="el" href="classAttachNode.html#a0781a31350ac165126c852540d7de7da">AttachNode</a>.</p>

</div>
</div>
<a id="a76252604e0e9e0f8a8830c97993133f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76252604e0e9e0f8a8830c97993133f4">&#9670;&nbsp;</a></span>visit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Node::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRenderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>parentTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parentFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Visits this node's children and draw them recursively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A given renderer. </td></tr>
    <tr><td class="paramname">parentTransform</td><td>A transform matrix. </td></tr>
    <tr><td class="paramname">parentFlags</td><td><a class="el" href="classRenderer.html">Renderer</a> flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLabel.html#a380d30d32cf8f19f28418e706d5929b5">Label</a>, <a class="el" href="classui_1_1Scale9Sprite.html#ad939fbf33d73420369e251a990b01bc2">ui::Scale9Sprite</a>, <a class="el" href="classLabel.html#ae8e300dcf7e2a6b98e2ae39632d290c8">Label</a>, <a class="el" href="classui_1_1Layout.html#a7857b109e0d674106c9fe22830ef4076">ui::Layout</a>, <a class="el" href="classui_1_1Layout.html#a46a4f4f4836e1b9c985acb26f8fa4163">ui::Layout</a>, <a class="el" href="classDrawNode.html#adffd70536383fa1dd73ab4a6e785808a">DrawNode</a>, <a class="el" href="classCamera.html#add749a2d2338f0373a6a440e4cba5afa">Camera</a>, <a class="el" href="classCamera.html#a9af4106a5c83986160cb975d53205fce">Camera</a>, <a class="el" href="classRenderTexture.html#a92007b10e5dab891532bd0daa1a24be8">RenderTexture</a>, <a class="el" href="classRenderTexture.html#a57e0f63ce401e1b5915882f7be1884db">RenderTexture</a>, <a class="el" href="classScrollView.html#a7aee8e0ccdc8235a7ed9e2932ccdcf25">ScrollView</a>, <a class="el" href="classScrollView.html#a9766dfe15b34a8d7d1e3fd7b6acfcc32">ScrollView</a>, <a class="el" href="classTextFieldTTF.html#a4e4d61648a15b14774923fc8d2738683">TextFieldTTF</a>, <a class="el" href="classSprite3D.html#a7c6db1d1a851a0a1d2ca17f4c9ad8c67">Sprite3D</a>, <a class="el" href="classSprite3D.html#a7c6db1d1a851a0a1d2ca17f4c9ad8c67">Sprite3D</a>, <a class="el" href="classTextFieldTTF.html#af7cb31f513a3699cac12a42aebcd8bec">TextFieldTTF</a>, <a class="el" href="classSpriteBatchNode.html#a2cccb328ace35dc3e02d7ca8824df65d">SpriteBatchNode</a>, <a class="el" href="classSpriteBatchNode.html#afcdd1f0032ac902a52256fee7687cc36">SpriteBatchNode</a>, <a class="el" href="classProtectedNode.html#a705c838f46afa1b9eac5dae2aa4bc310">ProtectedNode</a>, <a class="el" href="classProtectedNode.html#afb1b2f3712d91a38bd5c691eeec6bbb9">ProtectedNode</a>, <a class="el" href="classClippingNode.html#a2c3e648bc28a51189cecda4ae431e38b">ClippingNode</a>, <a class="el" href="classClippingNode.html#abe6402dbaf99cbf1e4b16add726b2a56">ClippingNode</a>, <a class="el" href="classParticleBatchNode.html#af1dd3c3d3e8d7d17d0b1b00d634eb434">ParticleBatchNode</a>, <a class="el" href="classParticleBatchNode.html#ad11baa30bf900df09491dd652d16b954">ParticleBatchNode</a>, <a class="el" href="classBillBoard.html#ae51a82da848a1a3c70cf109cdb1b79ba">BillBoard</a>, <a class="el" href="classBillBoard.html#a2caec4c849717693e62be305a0ca789c">BillBoard</a>, <a class="el" href="classClippingRectangleNode.html#acffefe2919ca5110110e091d79448260">ClippingRectangleNode</a>, <a class="el" href="classClippingRectangleNode.html#ae875ea898f086aa7106b803ddbcbf47f">ClippingRectangleNode</a>, <a class="el" href="classNodeGrid.html#accaa8bcbf32f1d9e2b62ae0103ff5169">NodeGrid</a>, <a class="el" href="classNodeGrid.html#afb46783d7e7fdaf8e3d58c0dde9ebd21">NodeGrid</a>, <a class="el" href="classParallaxNode.html#a3e451b09972ed6e158c7b8f88da4b636">ParallaxNode</a>, <a class="el" href="classParallaxNode.html#aee4c2a79089a02e872db670ed07638c1">ParallaxNode</a>, <a class="el" href="classAttachNode.html#a34dd14d134d83f3c5458bf4ea94361fe">AttachNode</a>, and <a class="el" href="classAttachNode.html#a0781a31350ac165126c852540d7de7da">AttachNode</a>.</p>

</div>
</div>
<a id="a0b6b4ad592891ca7ec7ec0bd09341dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b4ad592891ca7ec7ec0bd09341dd1">&#9670;&nbsp;</a></span>worldToNodeTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::worldToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#ab41da5111de6d98710d0497e35063989">getWorldToNodeTransform()</a> instead </dd></dl>

</div>
</div>
<a id="a0b6b4ad592891ca7ec7ec0bd09341dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b4ad592891ca7ec7ec0bd09341dd1">&#9670;&nbsp;</a></span>worldToNodeTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CC_DEPRECATED_ATTRIBUTE <a class="el" href="structAffineTransform.html">AffineTransform</a> Node::worldToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000266">Deprecated:</a></b></dt><dd>Use <a class="el" href="classNode.html#ab41da5111de6d98710d0497e35063989">getWorldToNodeTransform()</a> instead </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada8c37d773103afb51bd5ca06bdb42b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8c37d773103afb51bd5ca06bdb42b2">&#9670;&nbsp;</a></span>_globalZOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::_globalZOrder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; Local order (relative to its siblings) used to sort the node </p>
<p>Global order used to sort the node.</p>
<p>Global order used to sort the node </p>

</div>
</div>
<a id="aef122b1552bec154a2a8923641b4e0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef122b1552bec154a2a8923641b4e0f2">&#9670;&nbsp;</a></span>_ignoreAnchorPointForPosition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::_ignoreAnchorPointForPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by <a class="el" href="classLayer.html" title="Layer is a subclass of Node that implements the TouchEventsDelegate protocol. ">Layer</a> and <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. </p>
<p>true if the Anchor <a class="el" href="classVec2.html">Vec2</a> will be (0,0) when you position the <a class="el" href="classNode.html" title="Node is the base element of the Scene Graph. Elements of the Scene Graph must be Node objects or subc...">Node</a>, false otherwise. </p>

</div>
</div>
<a id="ad297aabd4789b5bdb3ddff6034691edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad297aabd4789b5bdb3ddff6034691edb">&#9670;&nbsp;</a></span>_scaleX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Node::_scaleX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotation using quaternion, if _rotationZ_X == _rotationZ_Y, _rotationQuat = RotationZ_X * RotationY * RotationX, else _rotationQuat = RotationY * RotationX </p>
<p>scaling factor on x-axis </p>

</div>
</div>
<a id="aa8e6bb26098082b3d5bd5b6ba89e48c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e6bb26098082b3d5bd5b6ba89e48c8">&#9670;&nbsp;</a></span>INVALID_TAG</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const int Node::INVALID_TAG = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default tag used for all the nodes </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/2d/<a class="el" href="cocos2d_2cocos_22d_2CCNode_8h_source.html">CCNode.h</a></li>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/2d/CCNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
