<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: User Callback</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">User Callback</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__ssl__info.html">lws_ssl_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memItemLeft" align="right" valign="top"><a id="ga55ae49e9f9dd9e5af97568b3e00fad17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga55ae49e9f9dd9e5af97568b3e00fad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be6b9e42356874e915476668ba02607"><td class="memItemLeft" align="right" valign="top"><a id="ga2be6b9e42356874e915476668ba02607"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__PROXY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2be6b9e42356874e915476668ba02607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memItemLeft" align="right" valign="top"><a id="ga7aa29e393bb83d2a84f8f119ba0710c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_CHUNK_END</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga7aa29e393bb83d2a84f8f119ba0710c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247529a09d7ca262812e907f45012d9"><td class="memItemLeft" align="right" valign="top"><a id="ga7247529a09d7ca262812e907f45012d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_CB_REASON_AUX_BF__CGI_HEADERS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga7247529a09d7ca262812e907f45012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:gad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<br />
&#160;&#160;<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<br />
&#160;&#160;<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<b>LWS_CALLBACK_CLOSED</b> = 4, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<b>LWS_CALLBACK_HTTP</b> = 12, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<br />
&#160;&#160;<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<br />
&#160;&#160;<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_USER</b> = 1000, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED</b> = 0, 
<b>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</b> = 1, 
<b>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</b> = 2, 
<b>LWS_CALLBACK_CLIENT_ESTABLISHED</b> = 3, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLOSED</b> = 4, 
<b>LWS_CALLBACK_CLOSED_HTTP</b> = 5, 
<b>LWS_CALLBACK_RECEIVE</b> = 6, 
<b>LWS_CALLBACK_RECEIVE_PONG</b> = 7, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_RECEIVE</b> = 8, 
<b>LWS_CALLBACK_CLIENT_RECEIVE_PONG</b> = 9, 
<b>LWS_CALLBACK_CLIENT_WRITEABLE</b> = 10, 
<b>LWS_CALLBACK_SERVER_WRITEABLE</b> = 11, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP</b> = 12, 
<b>LWS_CALLBACK_HTTP_BODY</b> = 13, 
<b>LWS_CALLBACK_HTTP_BODY_COMPLETION</b> = 14, 
<b>LWS_CALLBACK_HTTP_FILE_COMPLETION</b> = 15, 
<br />
&#160;&#160;<b>LWS_CALLBACK_HTTP_WRITEABLE</b> = 16, 
<b>LWS_CALLBACK_FILTER_NETWORK_CONNECTION</b> = 17, 
<b>LWS_CALLBACK_FILTER_HTTP_CONNECTION</b> = 18, 
<b>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</b> = 19, 
<br />
&#160;&#160;<b>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</b> = 20, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</b> = 21, 
<b>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</b> = 22, 
<b>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</b> = 23, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</b> = 24, 
<b>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</b> = 25, 
<b>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</b> = 26, 
<b>LWS_CALLBACK_PROTOCOL_INIT</b> = 27, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROTOCOL_DESTROY</b> = 28, 
<b>LWS_CALLBACK_WSI_CREATE</b> = 29, 
<b>LWS_CALLBACK_WSI_DESTROY</b> = 30, 
<b>LWS_CALLBACK_GET_THREAD_ID</b> = 31, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ADD_POLL_FD</b> = 32, 
<b>LWS_CALLBACK_DEL_POLL_FD</b> = 33, 
<b>LWS_CALLBACK_CHANGE_MODE_POLL_FD</b> = 34, 
<b>LWS_CALLBACK_LOCK_POLL</b> = 35, 
<br />
&#160;&#160;<b>LWS_CALLBACK_UNLOCK_POLL</b> = 36, 
<b>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</b> = 37, 
<b>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</b> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_USER</b> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<br />
&#160;&#160;<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<br />
&#160;&#160;<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<br />
&#160;&#160;<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25">LWS_CALLBACK_WS_EXT_DEFAULTS</a> = 39, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5">LWS_CALLBACK_CGI</a> = 40, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4">LWS_CALLBACK_CGI_TERMINATED</a> = 41, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31">LWS_CALLBACK_CGI_STDIN_DATA</a> = 42, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d">LWS_CALLBACK_CGI_STDIN_COMPLETED</a> = 43, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01">LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</a> = 44, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc">LWS_CALLBACK_CLOSED_CLIENT_HTTP</a> = 45, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900">LWS_CALLBACK_RECEIVE_CLIENT_HTTP</a> = 46, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308">LWS_CALLBACK_COMPLETED_CLIENT_HTTP</a> = 47, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1">LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</a> = 48, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba">LWS_CALLBACK_HTTP_BIND_PROTOCOL</a> = 49, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd">LWS_CALLBACK_HTTP_DROP_PROTOCOL</a> = 50, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310">LWS_CALLBACK_CHECK_ACCESS_RIGHTS</a> = 51, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d">LWS_CALLBACK_PROCESS_HTML</a> = 52, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725">LWS_CALLBACK_ADD_HEADERS</a> = 53, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8">LWS_CALLBACK_SESSION_INFO</a> = 54, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026">LWS_CALLBACK_GS_EVENT</a> = 55, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a">LWS_CALLBACK_HTTP_PMO</a> = 56, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6">LWS_CALLBACK_CLIENT_HTTP_WRITEABLE</a> = 57, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b">LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION</a> = 58, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d">LWS_CALLBACK_RAW_RX</a> = 59, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9">LWS_CALLBACK_RAW_CLOSE</a> = 60, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82">LWS_CALLBACK_RAW_WRITEABLE</a> = 61, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b">LWS_CALLBACK_RAW_ADOPT</a> = 62, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b">LWS_CALLBACK_RAW_ADOPT_FILE</a> = 63, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4">LWS_CALLBACK_RAW_RX_FILE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b">LWS_CALLBACK_RAW_WRITEABLE_FILE</a> = 65, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2">LWS_CALLBACK_RAW_CLOSE_FILE</a> = 66, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d">LWS_CALLBACK_SSL_INFO</a> = 67, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de">LWS_CALLBACK_CHILD_WRITE_VIA_PARENT</a> = 68, 
<br />
&#160;&#160;<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1">LWS_CALLBACK_CHILD_CLOSING</a> = 69, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962">LWS_CALLBACK_CGI_PROCESS_ATTACH</a> = 70, 
<a class="el" href="group__usercb.html#ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:gad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>User protocol callback</h2>
<p>The protocol callback is the primary way lws interacts with user code. For one of a <a class="el" href="protocollist-p.html">list</a> of a few dozen reasons the callback gets called at some event to be handled.</p>
<p>All of the events can be ignored, returning 0 is taken as "OK" and returning nonzero in most cases indicates that the connection should be closed. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<a id="gad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fcb82e68d60ffacca61a3f783a0a2f">&#9670;&nbsp;</a></span>lws_callback_function <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct <a class="el" href="structlws.html">lws</a> *wsi, enum <a class="el" href="group__usercb.html#gad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="group__usercb.html#gad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is the way the user controls what is served. All the protocol detail is hidden and handled by the library.</p>
<p>For each connection / session there is user data allocated that is pointed to by "user". You set the size of this user data area when the library is initialized with lws_create_server. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62860e19975ba4c4af401c3cdb6abf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62860e19975ba4c4af401c3cdb6abf7">&#9670;&nbsp;</a></span>lws_callback_reasons <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lws_callback_reasons</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including / above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc"><p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support, in is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc"><p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to</p>
<p>Diagnostic strings that may be returned include </p><pre class="fragment">    "getaddrinfo (ipv6) failed"
    "unknown address family"
    "getaddrinfo (ipv4) failed"
    "set socket opts failed"
    "insert wsi failed"
    "lws_ssl_client_connect1 failed"
    "lws_ssl_client_connect2 failed"
    "Peer hung up"
    "read failed"
    "HS: URI missing"
    "HS: Redirect code but no Location"
    "HS: URI did not parse"
    "HS: Redirect failed"
    "HS: Server did not return 200"
    "HS: OOM"
    "HS: disallowed by client filter"
    "HS: disallowed at ESTABLISHED"
    "HS: ACCEPT missing"
    "HS: ws upgrade response not 101"
    "HS: UPGRADE missing"
    "HS: Upgrade to something other than websocket"
    "HS: CONNECTION missing"
    "HS: UPGRADE malformed"
    "HS: PROTOCOL malformed"
    "HS: Cannot match protocol"
    "HS: EXT: list too big"
    "HS: EXT: failed setting defaults"
    "HS: EXT: failed parsing defaults"
    "HS: EXT: failed parsing options"
    "HS: EXT: Rejects server options"
    "HS: EXT: unknown ext"
    "HS: Accept hash wrong"
    "HS: Rejected by filter cb"
    "HS: OOM"
    "HS: SO_SNDBUF failed"
    "HS: Rejected at CLIENT_ESTABLISHED"</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc"><p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point since it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc"><p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc"><p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc"><p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc"><p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc"><p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc"><p>If you call <a class="el" href="group__callback-when-writeable.html#ga941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc"><p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. in points to the URI path requested and <a class="el" href="group__httpft.html#gab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, since the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc"><p>the next len bytes data from the http request body HTTP connection is now available in in. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc"><p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc"><p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc"><p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP. in contains the connection socket's descriptor. Since the client connection information is not available yet, wsi still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc"><p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc"><p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only wsi is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc"><p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. user is a pointer to the connection user space allocation, in is the requested protocol name In your handler you can use the public APIs <a class="el" href="group__HTTP-headers-read.html#ga8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="group__HTTP-headers-read.html#ga6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from libwebsockets.h to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity. user is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support, this callback allows your user code to load extra certificates into the server which allow it to verify the validity of certificates returned by clients. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc"><p>this callback happens when a client handshake is being compiled. user is NULL, in is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and len is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to:</p>
<p>char **p = (char **)in;</p>
<p>if (len &lt; 100) return 1;</p>
<p>*p += sprintf(*p, "Cookie: a=b\x0d\x0a");</p>
<p>return 0;</p>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc"><p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the <a class="el" href="protocollist-p.html">list</a> sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with in being the extension name, len is 0 and user is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize user content there, user content during this callback might not be useful for anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc"><p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc"><p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc"><p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc"><p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc"><p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc"><p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop: in points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the fd member of the struct is the file descriptor, and events contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when a socket descriptor needs to be removed from an external polling array. in is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the fd member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc"><p>This callback happens when lws wants to modify the events for a connection. in is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the fd to change. The new event mask is in events member and the old mask is in the prev_events member. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc"><p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc"><p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc"><p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. user is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc"><p>The peer has sent an unsolicited Close WS packet. in and len are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readable data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7abcf9c720cd3d361a83d1ac65bf052a25"></a>LWS_CALLBACK_WS_EXT_DEFAULTS&#160;</td><td class="fielddoc"><p>Gives client connections an opportunity to adjust negotiated extension defaults. <code>user</code> is the extension name that was negotiated (eg, "permessage-deflate"). <code>in</code> points to a buffer and <code>len</code> is the buffer size. The user callback can set the buffer to a string describing options the extension should parse. Or just ignore for defaults. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a23b90b5e5146e760bc3123ae1fd2a6e5"></a>LWS_CALLBACK_CGI&#160;</td><td class="fielddoc"><p>CGI: CGI IO events on stdin / out / err are sent here on protocols[0]. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac8c0ae966ef1877e0020c0077ff2e4a4"></a>LWS_CALLBACK_CGI_TERMINATED&#160;</td><td class="fielddoc"><p>CGI: The related CGI process ended, this is called before the wsi is closed. Used to, eg, terminate chunking. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. The child PID that terminated is in len. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a659539cfa65c66e0d813113b09900d31"></a>LWS_CALLBACK_CGI_STDIN_DATA&#160;</td><td class="fielddoc"><p>CGI: <a class="el" href="classData.html">Data</a> is, to be sent to the CGI process stdin, eg from a POST body. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad724974204d51d688f569c5d387b967d"></a>LWS_CALLBACK_CGI_STDIN_COMPLETED&#160;</td><td class="fielddoc"><p>CGI: no more stdin is coming. The provided <code>lws_callback_http_dummy()</code> handles this and the callback should be directed there if you use CGI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6a09ee9c01c4a233aedbe6697e29cc01"></a>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection has succeeded, and is now connected to the server </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac432e9f891c733ba8f968c1bf57c0ddc"></a>LWS_CALLBACK_CLOSED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The HTTP client connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aaffd08a5cae791c9f3c38ee242203900"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>This simply indicates data was received on the HTTP client connection. It does NOT drain or provide the data. This exists to neatly allow a proxying type situation, where this incoming data will go out on another connection. If the outgoing connection stalls, we should stall processing the incoming data. So a handler for this in that case should simply set a flag to indicate there is incoming data ready and ask for a writeable callback on the outgoing connection. In the writable callback he can check the flag and then get and drain the waiting incoming data using <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a>. This will use callbacks to LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ to get and drain the incoming data, where it should be sent back out on the outgoing connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a182a4a14c3278784505cea6d516a8308"></a>LWS_CALLBACK_COMPLETED_CLIENT_HTTP&#160;</td><td class="fielddoc"><p>The client transaction completed... at the moment this is the same as closing since transaction pipelining on client side is not yet supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad87774f1c7784cf632e1e2f5b51036e1"></a>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ&#160;</td><td class="fielddoc"><p>This is generated by <a class="el" href="group__client.html#ga4450c34200bf9dab3beb90ef23221870">lws_http_client_read()</a> used to drain incoming data. In the case the incoming data was chunked, it will be split into multiple smaller callbacks for each chunk block, removing the chunk headers. If not chunked, it will appear all in one callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a0418587d5083bb4850faa438648496ba"></a>LWS_CALLBACK_HTTP_BIND_PROTOCOL&#160;</td><td class="fielddoc"><p>By default, all HTTP handling is done in protocols[0]. However you can bind different protocols (by name) to different parts of the URL space using callback mounts. This callback occurs in the new protocol when a wsi is bound to that protocol. Any protocol allocation related to the http transaction processing should be created then. These specific callbacks are necessary because with HTTP/1.1, a single connection may perform at series of different transactions at different URLs, thus the lifetime of the protocol bind is just for one transaction, not connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a45d538082dec32dbecfe9d9a05ddfecd"></a>LWS_CALLBACK_HTTP_DROP_PROTOCOL&#160;</td><td class="fielddoc"><p>This is called when a transaction is unbound from a protocol. It indicates the connection completed its transaction and may do something different now. Any protocol allocation related to the http transaction processing should be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7afc4b2f72cc9e424a750b506ce0cc4310"></a>LWS_CALLBACK_CHECK_ACCESS_RIGHTS&#160;</td><td class="fielddoc"><p>This gives the user code a chance to forbid an http access. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code>, which describes the URL, and a bit mask describing the type of authentication required. If the callback returns nonzero, the transaction ends with HTTP_STATUS_UNAUTHORIZED. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a89862929a72bff65257ca1d51a0fce4d"></a>LWS_CALLBACK_PROCESS_HTML&#160;</td><td class="fielddoc"><p>This gives your user code a chance to mangle outgoing HTML. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> which describes the buffer containing outgoing HTML. The buffer may grow up to <code>.max_len</code> (currently +128 bytes per buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ab884f3d5f8a6126a0d34c0172f5e3725"></a>LWS_CALLBACK_ADD_HEADERS&#160;</td><td class="fielddoc"><p>This gives your user code a chance to add headers to a transaction bound to your protocol. <code>in</code> points to a <code>struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></code> describing a buffer and length you can add headers into using the normal lws apis.</p>
<p>Only <code>args-&gt;p</code> and <code>args-&gt;len</code> are valid, and <code>args-&gt;p</code> should be moved on by the amount of bytes written, if any. Eg </p><pre class="fragment">case LWS_CALLBACK_ADD_HEADERS:

     struct lws_process_html_args *args =
            (struct lws_process_html_args *)in;

 if (lws_add_http_header_by_name(wsi,
    (unsigned char *)"set-cookie:",
    (unsigned char *)cookie, cookie_len,
    (unsigned char **)&amp;args-&gt;p,
    (unsigned char *)args-&gt;p + args-&gt;max_len))
return 1;

     break;</pre> </td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac11c336f7052abf3618962902a71ebc8"></a>LWS_CALLBACK_SESSION_INFO&#160;</td><td class="fielddoc"><p>This is only generated by user code using generic sessions. It's used to get a <code>struct <a class="el" href="structlws__session__info.html">lws_session_info</a></code> filled in by generic sessions with information about the logged-in user. See the messageboard sample for an example of how to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7af6cf80e57aae8ba0a57a5c456b1fe026"></a>LWS_CALLBACK_GS_EVENT&#160;</td><td class="fielddoc"><p>Indicates an event happened to the Generic Sessions session. <code>in</code> contains a <code>struct <a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></code> describing the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa5cc921b7697743017a533822a3d556a"></a>LWS_CALLBACK_HTTP_PMO&#160;</td><td class="fielddoc"><p>per-mount options for this connection, called before the normal LWS_CALLBACK_HTTP when the mount has per-mount options. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aeb0cec65ec82a713cd01e9ca9aeeb5e6"></a>LWS_CALLBACK_CLIENT_HTTP_WRITEABLE&#160;</td><td class="fielddoc"><p>when doing an HTTP type client connection, you can call lws_client_http_body_pending(wsi, 1) from LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks sending the HTTP headers.</p>
<p>From this callback, when you have sent everything, you should let lws know by calling lws_client_http_body_pending(wsi, 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a17620dd6cb920b9b6daeae63575be08b"></a>LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION&#160;</td><td class="fielddoc"><p>Similar to LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION this callback is called during OpenSSL verification of the cert sent from the server to the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the wsi is set because lws_client_connect_via_info was successful.</p>
<p>See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback, user is the x509_ctx, in is the ssl pointer and len is preverify_ok.</p>
<p>THIS IS NOT RECOMMENDED BUT if a cert validation error shall be overruled and cert shall be accepted as ok, X509_STORE_CTX_set_error((X509_STORE_CTX*)user, X509_V_OK); must be called and return value must be 0 to mean the cert is OK; returning 1 will fail the cert in any case.</p>
<p>This also means that if you don't handle this callback then the default callback action of returning 0 will not accept the certificate in case of a validation error decided by the SSL lib.</p>
<p>This is expected and secure behaviour when validating certificates.</p>
<p>Note: LCCSCF_ALLOW_SELFSIGNED and LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK still work without this callback being implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a6c4ce79afb3a5d96c8df3c8d5e3c869d"></a>LWS_CALLBACK_RAW_RX&#160;</td><td class="fielddoc"><p>RAW mode connection RX </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ae4cc93dadca4ea4541f3fe6d35bdb0a9"></a>LWS_CALLBACK_RAW_CLOSE&#160;</td><td class="fielddoc"><p>RAW mode connection is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7acd0e80a385c951eceb9c6e2a41ab1c82"></a>LWS_CALLBACK_RAW_WRITEABLE&#160;</td><td class="fielddoc"><p>RAW mode connection may be written </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a13e302be9ed9190d962591eb9c8c5f0b"></a>LWS_CALLBACK_RAW_ADOPT&#160;</td><td class="fielddoc"><p>RAW mode connection was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a47bf47452a410ee391e47cfc9cf4398b"></a>LWS_CALLBACK_RAW_ADOPT_FILE&#160;</td><td class="fielddoc"><p>RAW mode file was adopted (equivalent to 'wsi created') </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac82dd9246d6efe5289fb131ac3fc80c4"></a>LWS_CALLBACK_RAW_RX_FILE&#160;</td><td class="fielddoc"><p>RAW mode file has something to read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ac570926e939d1c3b96057f37c759110b"></a>LWS_CALLBACK_RAW_WRITEABLE_FILE&#160;</td><td class="fielddoc"><p>RAW mode file is writeable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7ad227d7bd87592150df89e211a8815cb2"></a>LWS_CALLBACK_RAW_CLOSE_FILE&#160;</td><td class="fielddoc"><p>RAW mode wsi that adopted a file is closing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a505e1c920c2110c7304e63e83e92b86d"></a>LWS_CALLBACK_SSL_INFO&#160;</td><td class="fielddoc"><p>SSL connections only. An event you registered an interest in at the vhost has occurred on a connection using the vhost. in is a pointer to a struct <a class="el" href="structlws__ssl__info.html">lws_ssl_info</a> containing information about the event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a5d456fab7fa976c958446e7aa87ce2de"></a>LWS_CALLBACK_CHILD_WRITE_VIA_PARENT&#160;</td><td class="fielddoc"><p>Child has been marked with parent_carries_io attribute, so lws_write directs the to this callback at the parent, in is a struct <a class="el" href="structlws__write__passthru.html">lws_write_passthru</a> containing the args the <a class="el" href="group__sending-data.html#gafd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> was called with. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7aa6668624ed0ca65534b5c59eefc47ef1"></a>LWS_CALLBACK_CHILD_CLOSING&#160;</td><td class="fielddoc"><p>Sent to parent to notify them a child is closing / being destroyed. in is the child wsi. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a38399b74fdfe15c634fade1ba0380962"></a>LWS_CALLBACK_CGI_PROCESS_ATTACH&#160;</td><td class="fielddoc"><p>CGI: Sent when the CGI process is spawned for the wsi. The len parameter is the PID of the child process </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc"><p>user code can use any including above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
