<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: TextureCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classTextureCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TextureCache Class Reference<div class="ingroups"><a class="el" href="group____2d.html">2D Nodes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Singleton that handles the loading of textures. Once the texture is loaded, the next time it will return. A reference of the previously loaded texture reducing GPU &amp; CPU memory.  
 <a href="classTextureCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cocos2d_2cocos_2renderer_2CCTextureCache_8h_source.html">CCTextureCache.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TextureCache:</div>
<div class="dyncontent">
<div class="center"><img src="classTextureCache__inherit__graph.png" border="0" usemap="#TextureCache_inherit__map" alt="Inheritance graph"/></div>
<map name="TextureCache_inherit__map" id="TextureCache_inherit__map">
<area shape="rect" id="node2" href="classRef.html" title="Ref" alt="" coords="36,5,79,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TextureCache:</div>
<div class="dyncontent">
<div class="center"><img src="classTextureCache__coll__graph.png" border="0" usemap="#TextureCache_coll__map" alt="Collaboration graph"/></div>
<map name="TextureCache_coll__map" id="TextureCache_coll__map">
<area shape="rect" id="node2" href="classRef.html" title="Ref" alt="" coords="36,5,79,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec6e0e3c0b4c5bfed1c31187cea44c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aaec6e0e3c0b4c5bfed1c31187cea44c4">TextureCache</a> ()</td></tr>
<tr class="separator:aaec6e0e3c0b4c5bfed1c31187cea44c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd218a0a417210f696f6da7c351643"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aacfd218a0a417210f696f6da7c351643">~TextureCache</a> ()</td></tr>
<tr class="separator:aacfd218a0a417210f696f6da7c351643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54c198c9f9a242c0fe8989b494f1a1"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a1e54c198c9f9a242c0fe8989b494f1a1">getDescription</a> () const</td></tr>
<tr class="separator:a1e54c198c9f9a242c0fe8989b494f1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3732061bd450e38a7649dfc4c39858ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a3732061bd450e38a7649dfc4c39858ef">addImage</a> (const std::string &amp;filepath)</td></tr>
<tr class="separator:a3732061bd450e38a7649dfc4c39858ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8506a3a65c61bef4f057ef10facba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a21e8506a3a65c61bef4f057ef10facba">addImageAsync</a> (const std::string &amp;filepath, const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;callback)</td></tr>
<tr class="separator:a21e8506a3a65c61bef4f057ef10facba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de7b70ab03d134d58fdac249c102d65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a3de7b70ab03d134d58fdac249c102d65">unbindImageAsync</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a3de7b70ab03d134d58fdac249c102d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d6cd0e772ecb99b2c140dba4205717"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a92d6cd0e772ecb99b2c140dba4205717">unbindAllImageAsync</a> ()</td></tr>
<tr class="separator:a92d6cd0e772ecb99b2c140dba4205717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a3f1f96a59ebf2addb972e15e87a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a286a3f1f96a59ebf2addb972e15e87a7">addImage</a> (Image *image, const std::string &amp;key)</td></tr>
<tr class="separator:a286a3f1f96a59ebf2addb972e15e87a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe2231b715b485a544ff9c872e6b540"><td class="memItemLeft" align="right" valign="top"><a id="afbe2231b715b485a544ff9c872e6b540"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addUIImage</b> (Image *image, const std::string &amp;key)</td></tr>
<tr class="separator:afbe2231b715b485a544ff9c872e6b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcfc44c403bb587c5883b0e587723d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a0fcfc44c403bb587c5883b0e587723d3">getTextureForKey</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a0fcfc44c403bb587c5883b0e587723d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1e21cee57d60f7c1268e36470e361"><td class="memItemLeft" align="right" valign="top"><a id="a42a1e21cee57d60f7c1268e36470e361"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>textureForKey</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:a42a1e21cee57d60f7c1268e36470e361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6063d9bceafa8a6f60c498f8e2c15b4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a6063d9bceafa8a6f60c498f8e2c15b4a">reloadTexture</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a6063d9bceafa8a6f60c498f8e2c15b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e0ed7bd403b85e91cec4b03057d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a860e0ed7bd403b85e91cec4b03057d61">removeAllTextures</a> ()</td></tr>
<tr class="separator:a860e0ed7bd403b85e91cec4b03057d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec791c5421295c030e097716787f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#acbec791c5421295c030e097716787f68">removeUnusedTextures</a> ()</td></tr>
<tr class="separator:acbec791c5421295c030e097716787f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346fc925fda0b7964bbb57f100275760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a346fc925fda0b7964bbb57f100275760">removeTexture</a> (<a class="el" href="classTexture2D.html">Texture2D</a> *texture)</td></tr>
<tr class="separator:a346fc925fda0b7964bbb57f100275760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad532b26bf9a162d34710aa38f776c134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ad532b26bf9a162d34710aa38f776c134">removeTextureForKey</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad532b26bf9a162d34710aa38f776c134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2">getCachedTextureInfo</a> () const</td></tr>
<tr class="separator:ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51af522306e9449d772c3996509a509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ae51af522306e9449d772c3996509a509">waitForQuit</a> ()</td></tr>
<tr class="separator:ae51af522306e9449d772c3996509a509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd4a314af856fd66bb10b53a61fd0ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a4dd4a314af856fd66bb10b53a61fd0ea">getTextureFilePath</a> (<a class="el" href="classTexture2D.html">Texture2D</a> *texture) const</td></tr>
<tr class="separator:a4dd4a314af856fd66bb10b53a61fd0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735ea61a274834e6b3db7165ce2c26d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a8735ea61a274834e6b3db7165ce2c26d">renameTextureWithKey</a> (const std::string &amp;srcName, const std::string &amp;dstName)</td></tr>
<tr class="separator:a8735ea61a274834e6b3db7165ce2c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6e0e3c0b4c5bfed1c31187cea44c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aaec6e0e3c0b4c5bfed1c31187cea44c4">TextureCache</a> ()</td></tr>
<tr class="separator:aaec6e0e3c0b4c5bfed1c31187cea44c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711da38733f62e7d36346e750fa92666"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a711da38733f62e7d36346e750fa92666">~TextureCache</a> ()</td></tr>
<tr class="separator:a711da38733f62e7d36346e750fa92666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4fd2c1e7bf821300b2bf23e6c70561"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a1e4fd2c1e7bf821300b2bf23e6c70561">getDescription</a> () const</td></tr>
<tr class="separator:a1e4fd2c1e7bf821300b2bf23e6c70561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d8fe88c5a3c5ac20627861d5ac7033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a95d8fe88c5a3c5ac20627861d5ac7033">addImage</a> (const std::string &amp;filepath)</td></tr>
<tr class="separator:a95d8fe88c5a3c5ac20627861d5ac7033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97620a31dc4c03c26d0206b6e834ff2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ac97620a31dc4c03c26d0206b6e834ff2">addImageAsync</a> (const std::string &amp;filepath, const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;callback)</td></tr>
<tr class="separator:ac97620a31dc4c03c26d0206b6e834ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a764b691191f78fb76cc20aa8c80d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#af36a764b691191f78fb76cc20aa8c80d">addImageAsync</a> (const std::string &amp;path, const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;callback, const std::string &amp;callbackKey)</td></tr>
<tr class="separator:af36a764b691191f78fb76cc20aa8c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c48302097f8109e604b64018267046"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a02c48302097f8109e604b64018267046">unbindImageAsync</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a02c48302097f8109e604b64018267046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd53b2493af00f76d7e24a19dc2555d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a8cd53b2493af00f76d7e24a19dc2555d">unbindAllImageAsync</a> ()</td></tr>
<tr class="separator:a8cd53b2493af00f76d7e24a19dc2555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6215487085c4f04c22bc03d6bce95fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a6215487085c4f04c22bc03d6bce95fbe">addImage</a> (Image *image, const std::string &amp;key)</td></tr>
<tr class="separator:a6215487085c4f04c22bc03d6bce95fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe2231b715b485a544ff9c872e6b540"><td class="memItemLeft" align="right" valign="top"><a id="afbe2231b715b485a544ff9c872e6b540"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addUIImage</b> (Image *image, const std::string &amp;key)</td></tr>
<tr class="separator:afbe2231b715b485a544ff9c872e6b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72cb7ee095134531ea8bd03588db94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#adb72cb7ee095134531ea8bd03588db94">getTextureForKey</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:adb72cb7ee095134531ea8bd03588db94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1e21cee57d60f7c1268e36470e361"><td class="memItemLeft" align="right" valign="top"><a id="a42a1e21cee57d60f7c1268e36470e361"></a>
CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>textureForKey</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:a42a1e21cee57d60f7c1268e36470e361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6063d9bceafa8a6f60c498f8e2c15b4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a6063d9bceafa8a6f60c498f8e2c15b4a">reloadTexture</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a6063d9bceafa8a6f60c498f8e2c15b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e0ed7bd403b85e91cec4b03057d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a860e0ed7bd403b85e91cec4b03057d61">removeAllTextures</a> ()</td></tr>
<tr class="separator:a860e0ed7bd403b85e91cec4b03057d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec791c5421295c030e097716787f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#acbec791c5421295c030e097716787f68">removeUnusedTextures</a> ()</td></tr>
<tr class="separator:acbec791c5421295c030e097716787f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346fc925fda0b7964bbb57f100275760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a346fc925fda0b7964bbb57f100275760">removeTexture</a> (<a class="el" href="classTexture2D.html">Texture2D</a> *texture)</td></tr>
<tr class="separator:a346fc925fda0b7964bbb57f100275760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad532b26bf9a162d34710aa38f776c134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ad532b26bf9a162d34710aa38f776c134">removeTextureForKey</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad532b26bf9a162d34710aa38f776c134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2">getCachedTextureInfo</a> () const</td></tr>
<tr class="separator:ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51af522306e9449d772c3996509a509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ae51af522306e9449d772c3996509a509">waitForQuit</a> ()</td></tr>
<tr class="separator:ae51af522306e9449d772c3996509a509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd4a314af856fd66bb10b53a61fd0ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a4dd4a314af856fd66bb10b53a61fd0ea">getTextureFilePath</a> (<a class="el" href="classTexture2D.html">Texture2D</a> *texture) const</td></tr>
<tr class="separator:a4dd4a314af856fd66bb10b53a61fd0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735ea61a274834e6b3db7165ce2c26d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a8735ea61a274834e6b3db7165ce2c26d">renameTextureWithKey</a> (const std::string &amp;srcName, const std::string &amp;dstName)</td></tr>
<tr class="separator:a8735ea61a274834e6b3db7165ce2c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a065f6972ebb82de3e2143cbf10a7ac2d">autorelease</a> ()</td></tr>
<tr class="separator:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a1c3c3986014151251b39041e2556d2e3">~Ref</a> ()</td></tr>
<tr class="separator:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a544b29e4e4b0c7fb32ccb6bf92d28da9">autorelease</a> ()</td></tr>
<tr class="separator:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a97a445f43f3935f3ee6f34ebdec55d12">~Ref</a> ()</td></tr>
<tr class="separator:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aedd5e47ab3b453d894eab82ae18d80af"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aedd5e47ab3b453d894eab82ae18d80af">getInstance</a> ()</td></tr>
<tr class="separator:aedd5e47ab3b453d894eab82ae18d80af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a4493baac10bdfc2c7c91361a9f622"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a77a4493baac10bdfc2c7c91361a9f622">sharedTextureCache</a> ()</td></tr>
<tr class="separator:a77a4493baac10bdfc2c7c91361a9f622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aaf943d5c4969590a5f0c2f2008d68"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a39aaf943d5c4969590a5f0c2f2008d68">destroyInstance</a> ()</td></tr>
<tr class="separator:a39aaf943d5c4969590a5f0c2f2008d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61daeb91b7d2cd8228fd4849384108c1"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#a61daeb91b7d2cd8228fd4849384108c1">purgeSharedTextureCache</a> ()</td></tr>
<tr class="separator:a61daeb91b7d2cd8228fd4849384108c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c8d452f1ac6f8213b5931fbc1e89f"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ab02c8d452f1ac6f8213b5931fbc1e89f">reloadAllTextures</a> ()</td></tr>
<tr class="separator:ab02c8d452f1ac6f8213b5931fbc1e89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c596c1cac94d1ab61f698a835a329f"><td class="memItemLeft" align="right" valign="top"><a id="a41c596c1cac94d1ab61f698a835a329f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setETC1AlphaFileSuffix</b> (const std::string &amp;suffix)</td></tr>
<tr class="separator:a41c596c1cac94d1ab61f698a835a329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b70b207c1fe514b6806695dbc43564"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aa3b70b207c1fe514b6806695dbc43564">getInstance</a> ()</td></tr>
<tr class="separator:aa3b70b207c1fe514b6806695dbc43564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d28e68b30d4d9491db6ab0766eb25c"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ae5d28e68b30d4d9491db6ab0766eb25c">sharedTextureCache</a> ()</td></tr>
<tr class="separator:ae5d28e68b30d4d9491db6ab0766eb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf51262381fa7b3e85066bb1b0a3b06"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#aecf51262381fa7b3e85066bb1b0a3b06">destroyInstance</a> ()</td></tr>
<tr class="separator:aecf51262381fa7b3e85066bb1b0a3b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45bcaee3f6fd43a4d1dc29ff9107b4e"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ab45bcaee3f6fd43a4d1dc29ff9107b4e">purgeSharedTextureCache</a> ()</td></tr>
<tr class="separator:ab45bcaee3f6fd43a4d1dc29ff9107b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70068345cc5744cf0be99ad51615275"><td class="memItemLeft" align="right" valign="top">static CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTextureCache.html#ac70068345cc5744cf0be99ad51615275">reloadAllTextures</a> ()</td></tr>
<tr class="separator:ac70068345cc5744cf0be99ad51615275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2524f0fced01a316a4867aefb3ea5cf8"><td class="memItemLeft" align="right" valign="top"><a id="a2524f0fced01a316a4867aefb3ea5cf8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setETC1AlphaFileSuffix</b> (const std::string &amp;suffix)</td></tr>
<tr class="separator:a2524f0fced01a316a4867aefb3ea5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada8f4f153f490ccde00eb672b58610"><td class="memItemLeft" align="right" valign="top"><a id="a1ada8f4f153f490ccde00eb672b58610"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getETC1AlphaFileSuffix</b> ()</td></tr>
<tr class="separator:a1ada8f4f153f490ccde00eb672b58610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea1f31816298888a7eefdf42d7919432"><td class="memItemLeft" align="right" valign="top"><a id="aea1f31816298888a7eefdf42d7919432"></a>
std::thread *&#160;</td><td class="memItemRight" valign="bottom"><b>_loadingThread</b></td></tr>
<tr class="separator:aea1f31816298888a7eefdf42d7919432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4752665f2610093e710de5296217e613"><td class="memItemLeft" align="right" valign="top"><a id="a4752665f2610093e710de5296217e613"></a>
std::deque&lt; <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_asyncStructQueue</b></td></tr>
<tr class="separator:a4752665f2610093e710de5296217e613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef80c78dee3ef26138317d8395060c"><td class="memItemLeft" align="right" valign="top"><a id="a14ef80c78dee3ef26138317d8395060c"></a>
std::deque&lt; <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_requestQueue</b></td></tr>
<tr class="separator:a14ef80c78dee3ef26138317d8395060c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5bc5e852856e5c2762ff17dba9c3cb"><td class="memItemLeft" align="right" valign="top"><a id="a7f5bc5e852856e5c2762ff17dba9c3cb"></a>
std::deque&lt; <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_responseQueue</b></td></tr>
<tr class="separator:a7f5bc5e852856e5c2762ff17dba9c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d20bdcc9a52e6be22fc54ceafbb812"><td class="memItemLeft" align="right" valign="top"><a id="a11d20bdcc9a52e6be22fc54ceafbb812"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_requestMutex</b></td></tr>
<tr class="separator:a11d20bdcc9a52e6be22fc54ceafbb812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d492edf8421f9ecf58e25d932e79116"><td class="memItemLeft" align="right" valign="top"><a id="a4d492edf8421f9ecf58e25d932e79116"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_responseMutex</b></td></tr>
<tr class="separator:a4d492edf8421f9ecf58e25d932e79116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538bd77f97be3ad8286d91f159da4fd9"><td class="memItemLeft" align="right" valign="top"><a id="a538bd77f97be3ad8286d91f159da4fd9"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>_sleepCondition</b></td></tr>
<tr class="separator:a538bd77f97be3ad8286d91f159da4fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77a610b43e55879fce685ad98f03a37"><td class="memItemLeft" align="right" valign="top"><a id="ae77a610b43e55879fce685ad98f03a37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_needQuit</b></td></tr>
<tr class="separator:ae77a610b43e55879fce685ad98f03a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55a60b971c03ac5d46713cd53e39e4a"><td class="memItemLeft" align="right" valign="top"><a id="af55a60b971c03ac5d46713cd53e39e4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_asyncRefCount</b></td></tr>
<tr class="separator:af55a60b971c03ac5d46713cd53e39e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b65419f3cbcd4a18a1ebbc26dfc66de"><td class="memItemLeft" align="right" valign="top"><a id="a3b65419f3cbcd4a18a1ebbc26dfc66de"></a>
std::unordered_map&lt; std::string, <a class="el" href="classTexture2D.html">Texture2D</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_textures</b></td></tr>
<tr class="separator:a3b65419f3cbcd4a18a1ebbc26dfc66de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memItemLeft" align="right" valign="top"><a id="ab05a4c4ef09ecbaffc7c7c7f57d34bf6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab05a4c4ef09ecbaffc7c7c7f57d34bf6">_referenceCount</a></td></tr>
<tr class="memdesc:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">count of references <br /></td></tr>
<tr class="separator:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a4918a56d5253decf8f5f91491235b7b2"><td class="memItemLeft" align="right" valign="top"><a id="a4918a56d5253decf8f5f91491235b7b2"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>s_etc1AlphaFileSuffix</b> = &quot;@alpha&quot;</td></tr>
<tr class="separator:a4918a56d5253decf8f5f91491235b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab9cf238c39cc7fc6ffde82c8d94c465e">Ref</a> ()</td></tr>
<tr class="separator:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a63f1608b3c105a76e3d0ff1b77d2ae8e">Ref</a> ()</td></tr>
<tr class="separator:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Singleton that handles the loading of textures. Once the texture is loaded, the next time it will return. A reference of the previously loaded texture reducing GPU &amp; CPU memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaec6e0e3c0b4c5bfed1c31187cea44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6e0e3c0b4c5bfed1c31187cea44c4">&#9670;&nbsp;</a></span>TextureCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TextureCache::TextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ctor </p>

</div>
</div>
<a id="aacfd218a0a417210f696f6da7c351643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd218a0a417210f696f6da7c351643">&#9670;&nbsp;</a></span>~TextureCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TextureCache::~TextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA  NA </p>

</div>
</div>
<a id="aaec6e0e3c0b4c5bfed1c31187cea44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6e0e3c0b4c5bfed1c31187cea44c4">&#9670;&nbsp;</a></span>TextureCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TextureCache::TextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ctor </p>

</div>
</div>
<a id="a711da38733f62e7d36346e750fa92666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711da38733f62e7d36346e750fa92666">&#9670;&nbsp;</a></span>~TextureCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TextureCache::~TextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA  NA </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3732061bd450e38a7649dfc4c39858ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3732061bd450e38a7649dfc4c39858ef">&#9670;&nbsp;</a></span>addImage() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a> * TextureCache::addImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given an filename. If the filename was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a>. Object and it will return it. It will use the filename as a key. Otherwise it will return a reference of a previously loaded image. Supported image extensions: .png, .bmp, .tiff, .jpeg, .pvr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>A null terminated string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95d8fe88c5a3c5ac20627861d5ac7033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d8fe88c5a3c5ac20627861d5ac7033">&#9670;&nbsp;</a></span>addImage() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a>* TextureCache::addImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given an filename. If the filename was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a>. Object and it will return it. It will use the filename as a key. Otherwise it will return a reference of a previously loaded image. Supported image extensions: .png, .bmp, .tiff, .jpeg, .pvr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>The file path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a286a3f1f96a59ebf2addb972e15e87a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286a3f1f96a59ebf2addb972e15e87a7">&#9670;&nbsp;</a></span>addImage() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a> * TextureCache::addImage </td>
          <td>(</td>
          <td class="paramtype">Image *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given an Image. If the image was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object and it will return it. Otherwise it will return a reference of a previously loaded image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The "key" parameter will be used as the "key" for the cache. If "key" is nil, then a new texture will be created each time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6215487085c4f04c22bc03d6bce95fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6215487085c4f04c22bc03d6bce95fbe">&#9670;&nbsp;</a></span>addImage() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a>* TextureCache::addImage </td>
          <td>(</td>
          <td class="paramtype">Image *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given an Image. If the image was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object and it will return it. Otherwise it will return a reference of a previously loaded image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The "key" parameter will be used as the "key" for the cache. If "key" is nil, then a new texture will be created each time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21e8506a3a65c61bef4f057ef10facba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e8506a3a65c61bef4f057ef10facba">&#9670;&nbsp;</a></span>addImageAsync() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::addImageAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given a file image. If the file image was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object and it will return it. Otherwise it will load a texture in a new thread, and when the image is loaded, the callback will be called with the <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> as a parameter. The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback. Supported image extensions: .png, .jpg </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>A null terminated string. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function would be invoked after the image is loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.8</dd></dl>
<p>The addImageAsync logic follow the steps:</p><ul>
<li>find the image has been add or not, if not add an <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _requestQueue (GL thread)</li>
<li>get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _requestQueue, load res and fill image data to AsyncStruct.image, then add <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _responseQueue (Load thread)</li>
<li>on schedule callback, get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _responseQueue, convert image to texture, then delete <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> (GL thread)</li>
</ul>
<p>the Critical Area include these members:</p><ul>
<li>_requestQueue: locked by _requestMutex</li>
<li>_responseQueue: locked by _responseMutex</li>
</ul>
<p>the object's life time:</p><ul>
<li><a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a>: construct and destruct in GL thread</li>
<li>image data: new in Load thread, delete in GL thread(by Image instance)</li>
</ul>
<p>Note:</p><ul>
<li>all <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> referenced in _asyncStructQueue, for unbind function use.</li>
</ul>
<p>How to deal add image many times?</p><ul>
<li>At first, this situation is abnormal, we only ensure the logic is correct.</li>
<li>If the image has been loaded, the after load image call will return immediately.</li>
<li>If the image request is in queue already, there will be more than one request in queue,</li>
<li>In addImageAsyncCallback, will deduplicate the request to ensure only create one texture.</li>
</ul>
<p>Does process all response in addImageAsyncCallback consume more time?</p><ul>
<li>Convert image to texture faster than load image from disk, so this isn't a problem.</li>
</ul>
<p>The addImageAsync logic follow the steps:</p><ul>
<li>find the image has been add or not, if not add an <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _requestQueue (GL thread)</li>
<li>get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _requestQueue, load res and fill image data to AsyncStruct.image, then add <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _responseQueue (Load thread)</li>
<li>on schedule callback, get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _responseQueue, convert image to texture, then delete <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> (GL thread)</li>
</ul>
<p>the Critical Area include these members:</p><ul>
<li>_requestQueue: locked by _requestMutex</li>
<li>_responseQueue: locked by _responseMutex</li>
</ul>
<p>the object's life time:</p><ul>
<li><a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a>: construct and destruct in GL thread</li>
<li>image data: new in Load thread, delete in GL thread(by Image instance)</li>
</ul>
<p>Note:</p><ul>
<li>all <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> referenced in _asyncStructQueue, for unbind function use.</li>
</ul>
<p>How to deal add image many times?</p><ul>
<li>At first, this situation is abnormal, we only ensure the logic is correct.</li>
<li>If the image has been loaded, the after load image call will return immediately.</li>
<li>If the image request is in queue already, there will be more than one request in queue,</li>
<li>In addImageAsyncCallback, will deduplicate the request to ensure only create one texture.</li>
</ul>
<p>Does process all response in addImageAsyncCallback consume more time?</p><ul>
<li>Convert image to texture faster than load image from disk, so this isn't a problem.</li>
</ul>
<p>Call unbindImageAsync(path) to prevent the call to the callback when the texture is loaded. </p>

</div>
</div>
<a id="ac97620a31dc4c03c26d0206b6e834ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97620a31dc4c03c26d0206b6e834ff2">&#9670;&nbsp;</a></span>addImageAsync() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TextureCache::addImageAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object given a file image. If the file image was not previously loaded, it will create a new <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object and it will return it. Otherwise it will load a texture in a new thread, and when the image is loaded, the callback will be called with the <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> as a parameter. The callback will be called from the main thread, so it is safe to create any cocos2d object from the callback. Supported image extensions: .png, .jpg </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>The file path. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function would be invoked after the image is loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>

</div>
</div>
<a id="af36a764b691191f78fb76cc20aa8c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36a764b691191f78fb76cc20aa8c80d">&#9670;&nbsp;</a></span>addImageAsync() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::addImageAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classTexture2D.html">Texture2D</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>callbackKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The addImageAsync logic follow the steps:</p><ul>
<li>find the image has been add or not, if not add an <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _requestQueue (GL thread)</li>
<li>get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _requestQueue, load res and fill image data to AsyncStruct.image, then add <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> to _responseQueue (Load thread)</li>
<li>on schedule callback, get <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> from _responseQueue, convert image to texture, then delete <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> (GL thread)</li>
</ul>
<p>the Critical Area include these members:</p><ul>
<li>_requestQueue: locked by _requestMutex</li>
<li>_responseQueue: locked by _responseMutex</li>
</ul>
<p>the object's life time:</p><ul>
<li><a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a>: construct and destruct in GL thread</li>
<li>image data: new in Load thread, delete in GL thread(by Image instance)</li>
</ul>
<p>Note:</p><ul>
<li>all <a class="el" href="structTextureCache_1_1AsyncStruct.html">AsyncStruct</a> referenced in _asyncStructQueue, for unbind function use.</li>
</ul>
<p>How to deal add image many times?</p><ul>
<li>At first, this situation is abnormal, we only ensure the logic is correct.</li>
<li>If the image has been loaded, the after load image call will return immediately.</li>
<li>If the image request is in queue already, there will be more than one request in queue,</li>
<li>In addImageAsyncCallback, will deduplicate the request to ensure only create one texture.</li>
</ul>
<p>Does process all response in addImageAsyncCallback consume more time?</p><ul>
<li>Convert image to texture faster than load image from disk, so this isn't a problem.</li>
</ul>
<p>The callbackKey allows to unbind the callback in cases where the loading of path is requested by several sources simultaneously. Each source can then unbind the callback independently as needed whilst a call to unbindImageAsync(path) would be ambiguous. </p>

</div>
</div>
<a id="a39aaf943d5c4969590a5f0c2f2008d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aaf943d5c4969590a5f0c2f2008d68">&#9670;&nbsp;</a></span>destroyInstance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::destroyInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Purges the cache. It releases the retained instance. </p><dl class="section since"><dt>Since</dt><dd>v0.99.0 </dd></dl>

</div>
</div>
<a id="aecf51262381fa7b3e85066bb1b0a3b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf51262381fa7b3e85066bb1b0a3b06">&#9670;&nbsp;</a></span>destroyInstance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CC_DEPRECATED_ATTRIBUTE void TextureCache::destroyInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Purges the cache. It releases the retained instance. </p><dl class="section since"><dt>Since</dt><dd>v0.99.0 </dd></dl>

</div>
</div>
<a id="ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2">&#9670;&nbsp;</a></span>getCachedTextureInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TextureCache::getCachedTextureInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output to CCLOG the current contents of this <a class="el" href="classTextureCache.html" title="Singleton that handles the loading of textures. Once the texture is loaded, the next time it will ret...">TextureCache</a>. This will attempt to calculate the size of each texture, and the total texture memory in use.</p>
<dl class="section since"><dt>Since</dt><dd>v1.0 </dd></dl>

</div>
</div>
<a id="ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0aaf8d7d614ba1d5dcfac8ed7e1c4b2">&#9670;&nbsp;</a></span>getCachedTextureInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TextureCache::getCachedTextureInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output to CCLOG the current contents of this <a class="el" href="classTextureCache.html" title="Singleton that handles the loading of textures. Once the texture is loaded, the next time it will ret...">TextureCache</a>. This will attempt to calculate the size of each texture, and the total texture memory in use.</p>
<dl class="section since"><dt>Since</dt><dd>v1.0 </dd></dl>

</div>
</div>
<a id="a1e54c198c9f9a242c0fe8989b494f1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54c198c9f9a242c0fe8989b494f1a1">&#9670;&nbsp;</a></span>getDescription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TextureCache::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA  NA </p>

</div>
</div>
<a id="a1e4fd2c1e7bf821300b2bf23e6c70561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4fd2c1e7bf821300b2bf23e6c70561">&#9670;&nbsp;</a></span>getDescription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string TextureCache::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NA  NA </p>

</div>
</div>
<a id="aedd5e47ab3b453d894eab82ae18d80af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd5e47ab3b453d894eab82ae18d80af">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTextureCache.html">TextureCache</a> * TextureCache::getInstance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shared instance of the cache. </p>

</div>
</div>
<a id="aa3b70b207c1fe514b6806695dbc43564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b70b207c1fe514b6806695dbc43564">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a>* TextureCache::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shared instance of the cache. </p>

</div>
</div>
<a id="a4dd4a314af856fd66bb10b53a61fd0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd4a314af856fd66bb10b53a61fd0ea">&#9670;&nbsp;</a></span>getTextureFilePath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TextureCache::getTextureFilePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the file path of the texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full path of the file. </dd></dl>

</div>
</div>
<a id="a4dd4a314af856fd66bb10b53a61fd0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd4a314af856fd66bb10b53a61fd0ea">&#9670;&nbsp;</a></span>getTextureFilePath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TextureCache::getTextureFilePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the file path of the texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A <a class="el" href="classTexture2D.html" title="Texture2D class. This class allows to easily create OpenGL 2D textures from images, text or raw data. The created Texture2D object will always have power-of-two dimensions. Depending on how you create the Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0). Be aware that the content of the generated textures will be upside-down! ">Texture2D</a> object pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full path of the file. </dd></dl>

</div>
</div>
<a id="a0fcfc44c403bb587c5883b0e587723d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcfc44c403bb587c5883b0e587723d3">&#9670;&nbsp;</a></span>getTextureForKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a> * TextureCache::getTextureForKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an already created texture. Returns nil if the texture doesn't exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.5 </dd></dl>

</div>
</div>
<a id="adb72cb7ee095134531ea8bd03588db94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72cb7ee095134531ea8bd03588db94">&#9670;&nbsp;</a></span>getTextureForKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTexture2D.html">Texture2D</a>* TextureCache::getTextureForKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an already created texture. Returns nil if the texture doesn't exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.5 </dd></dl>

</div>
</div>
<a id="a61daeb91b7d2cd8228fd4849384108c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61daeb91b7d2cd8228fd4849384108c1">&#9670;&nbsp;</a></span>purgeSharedTextureCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::purgeSharedTextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000136">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTextureCache.html#a39aaf943d5c4969590a5f0c2f2008d68">destroyInstance()</a> instead. </dd></dl>

</div>
</div>
<a id="ab45bcaee3f6fd43a4d1dc29ff9107b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45bcaee3f6fd43a4d1dc29ff9107b4e">&#9670;&nbsp;</a></span>purgeSharedTextureCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CC_DEPRECATED_ATTRIBUTE void TextureCache::purgeSharedTextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000369">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTextureCache.html#a39aaf943d5c4969590a5f0c2f2008d68">destroyInstance()</a> instead. </dd></dl>

</div>
</div>
<a id="ab02c8d452f1ac6f8213b5931fbc1e89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02c8d452f1ac6f8213b5931fbc1e89f">&#9670;&nbsp;</a></span>reloadAllTextures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::reloadAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reload all textures. Should not call it, called by frame work. Now the function do nothing, use VolatileTextureMgr::reloadAllTextures. </p>

</div>
</div>
<a id="ac70068345cc5744cf0be99ad51615275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70068345cc5744cf0be99ad51615275">&#9670;&nbsp;</a></span>reloadAllTextures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CC_DEPRECATED_ATTRIBUTE void TextureCache::reloadAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reload all textures. Should not call it, called by frame work. Now the function do nothing, use VolatileTextureMgr::reloadAllTextures. </p>

</div>
</div>
<a id="a6063d9bceafa8a6f60c498f8e2c15b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6063d9bceafa8a6f60c498f8e2c15b4a">&#9670;&nbsp;</a></span>reloadTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TextureCache::reloadTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reload texture from the image file. If the file image hasn't loaded before, load it. Otherwise the texture will be reloaded from the file image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the reloading is succeed, otherwise return false. </dd></dl>

</div>
</div>
<a id="a6063d9bceafa8a6f60c498f8e2c15b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6063d9bceafa8a6f60c498f8e2c15b4a">&#9670;&nbsp;</a></span>reloadTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TextureCache::reloadTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reload texture from the image file. If the file image hasn't loaded before, load it. Otherwise the texture will be reloaded from the file image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the reloading is succeed, otherwise return false. </dd></dl>

</div>
</div>
<a id="a860e0ed7bd403b85e91cec4b03057d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e0ed7bd403b85e91cec4b03057d61">&#9670;&nbsp;</a></span>removeAllTextures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges the dictionary of loaded textures. Call this method if you receive the "Memory Warning". In the short term: it will free some resources preventing your app from being killed. In the medium term: it will allocate more resources. In the long term: it will be the same. </p>

</div>
</div>
<a id="a860e0ed7bd403b85e91cec4b03057d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e0ed7bd403b85e91cec4b03057d61">&#9670;&nbsp;</a></span>removeAllTextures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges the dictionary of loaded textures. Call this method if you receive the "Memory Warning". In the short term: it will free some resources preventing your app from being killed. In the medium term: it will allocate more resources. In the long term: it will be the same. </p>

</div>
</div>
<a id="a346fc925fda0b7964bbb57f100275760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346fc925fda0b7964bbb57f100275760">&#9670;&nbsp;</a></span>removeTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a texture from the cache given a texture. </p>

</div>
</div>
<a id="a346fc925fda0b7964bbb57f100275760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346fc925fda0b7964bbb57f100275760">&#9670;&nbsp;</a></span>removeTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture2D.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a texture from the cache given a texture. </p>

</div>
</div>
<a id="ad532b26bf9a162d34710aa38f776c134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad532b26bf9a162d34710aa38f776c134">&#9670;&nbsp;</a></span>removeTextureForKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeTextureForKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a texture from the cache given a its key name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.4 </dd></dl>

</div>
</div>
<a id="ad532b26bf9a162d34710aa38f776c134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad532b26bf9a162d34710aa38f776c134">&#9670;&nbsp;</a></span>removeTextureForKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeTextureForKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a texture from the cache given a its key name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.4 </dd></dl>

</div>
</div>
<a id="acbec791c5421295c030e097716787f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec791c5421295c030e097716787f68">&#9670;&nbsp;</a></span>removeUnusedTextures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeUnusedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes unused textures. Textures that have a retain count of 1 will be deleted. It is convenient to call this method after when starting a new <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. </p><dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>

</div>
</div>
<a id="acbec791c5421295c030e097716787f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec791c5421295c030e097716787f68">&#9670;&nbsp;</a></span>removeUnusedTextures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::removeUnusedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes unused textures. Textures that have a retain count of 1 will be deleted. It is convenient to call this method after when starting a new <a class="el" href="classScene.html" title="Scene is a subclass of Node that is used only as an abstract concept. ">Scene</a>. </p><dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>

</div>
</div>
<a id="a8735ea61a274834e6b3db7165ce2c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8735ea61a274834e6b3db7165ce2c26d">&#9670;&nbsp;</a></span>renameTextureWithKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::renameTextureWithKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>srcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dstName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reload texture from a new file. This function is mainly for editor, won't suggest use it in game for performance reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcName</td><td>Original texture file name. </td></tr>
    <tr><td class="paramname">dstName</td><td>New texture file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.10 </dd></dl>

</div>
</div>
<a id="a8735ea61a274834e6b3db7165ce2c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8735ea61a274834e6b3db7165ce2c26d">&#9670;&nbsp;</a></span>renameTextureWithKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::renameTextureWithKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>srcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dstName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reload texture from a new file. This function is mainly for editor, won't suggest use it in game for performance reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcName</td><td>Original texture file name. </td></tr>
    <tr><td class="paramname">dstName</td><td>New texture file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.10 </dd></dl>

</div>
</div>
<a id="a77a4493baac10bdfc2c7c91361a9f622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a4493baac10bdfc2c7c91361a9f622">&#9670;&nbsp;</a></span>sharedTextureCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTextureCache.html">TextureCache</a> * TextureCache::sharedTextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000135">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTextureCache.html#aedd5e47ab3b453d894eab82ae18d80af">getInstance()</a> instead. </dd></dl>

</div>
</div>
<a id="ae5d28e68b30d4d9491db6ab0766eb25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d28e68b30d4d9491db6ab0766eb25c">&#9670;&nbsp;</a></span>sharedTextureCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CC_DEPRECATED_ATTRIBUTE <a class="el" href="classTextureCache.html">TextureCache</a>* TextureCache::sharedTextureCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000368">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTextureCache.html#aedd5e47ab3b453d894eab82ae18d80af">getInstance()</a> instead. </dd></dl>

</div>
</div>
<a id="a92d6cd0e772ecb99b2c140dba4205717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d6cd0e772ecb99b2c140dba4205717">&#9670;&nbsp;</a></span>unbindAllImageAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::unbindAllImageAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unbind all bound image asynchronous load callbacks. </p><dl class="section since"><dt>Since</dt><dd>v3.1 </dd></dl>

</div>
</div>
<a id="a8cd53b2493af00f76d7e24a19dc2555d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd53b2493af00f76d7e24a19dc2555d">&#9670;&nbsp;</a></span>unbindAllImageAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TextureCache::unbindAllImageAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unbind all bound image asynchronous load callbacks. </p><dl class="section since"><dt>Since</dt><dd>v3.1 </dd></dl>

</div>
</div>
<a id="a3de7b70ab03d134d58fdac249c102d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de7b70ab03d134d58fdac249c102d65">&#9670;&nbsp;</a></span>unbindImageAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::unbindImageAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unbind a specified bound image asynchronous callback. In the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked, the object always need to unbind this callback manually. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.1 </dd></dl>

</div>
</div>
<a id="a02c48302097f8109e604b64018267046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c48302097f8109e604b64018267046">&#9670;&nbsp;</a></span>unbindImageAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TextureCache::unbindImageAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unbind a specified bound image asynchronous callback. In the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked, the object always need to unbind this callback manually. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>It's the related/absolute path of the file image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.1 </dd></dl>

</div>
</div>
<a id="ae51af522306e9449d772c3996509a509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51af522306e9449d772c3996509a509">&#9670;&nbsp;</a></span>waitForQuit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::waitForQuit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by director, please do not called outside. </p>

</div>
</div>
<a id="ae51af522306e9449d772c3996509a509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51af522306e9449d772c3996509a509">&#9670;&nbsp;</a></span>waitForQuit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TextureCache::waitForQuit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by director, please do not called outside. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/renderer/<a class="el" href="cocos2d_2cocos_2renderer_2CCTextureCache_8h_source.html">CCTextureCache.h</a></li>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/renderer/CCTextureCache.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
