<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: dtNavMeshQuery Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdtNavMeshQuery-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dtNavMeshQuery Class Reference<div class="ingroups"><a class="el" href="group__detour.html">Detour</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cocos2d_2external_2recast_2Detour_2DetourNavMeshQuery_8h_source.html">DetourNavMeshQuery.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#acb51d0d2798d0bc7c669ac38c25d4116">init</a> (const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *nav, const int maxNodes)</td></tr>
<tr class="separator:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#acb51d0d2798d0bc7c669ac38c25d4116">init</a> (const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *nav, const int maxNodes)</td></tr>
<tr class="separator:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard Pathfinding Functions</div></td></tr>
<tr class="memitem:a9d86502949fcd4f96ffd350d4ef69e3c"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a9d86502949fcd4f96ffd350d4ef69e3c">findPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath) const</td></tr>
<tr class="separator:a9d86502949fcd4f96ffd350d4ef69e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160434c85bdf9edec24fa621f120d2d"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ac160434c85bdf9edec24fa621f120d2d">findStraightPath</a> (const float *startPos, const float *endPos, const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, const int pathSize, float *straightPath, unsigned char *straightPathFlags, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *straightPathRefs, int *straightPathCount, const int maxStraightPath, const int options=0) const</td></tr>
<tr class="separator:ac160434c85bdf9edec24fa621f120d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86502949fcd4f96ffd350d4ef69e3c"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a9d86502949fcd4f96ffd350d4ef69e3c">findPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath) const</td></tr>
<tr class="separator:a9d86502949fcd4f96ffd350d4ef69e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160434c85bdf9edec24fa621f120d2d"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ac160434c85bdf9edec24fa621f120d2d">findStraightPath</a> (const float *startPos, const float *endPos, const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, const int pathSize, float *straightPath, unsigned char *straightPathFlags, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *straightPathRefs, int *straightPathCount, const int maxStraightPath, const int options=0) const</td></tr>
<tr class="separator:ac160434c85bdf9edec24fa621f120d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sliced Pathfinding Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Common use case:</p><ol type="1">
<li>Call <a class="el" href="classdtNavMeshQuery.html#ae9a478194f14f1a4591f8b6528007d82">initSlicedFindPath()</a> to initialize the sliced path query.</li>
<li>Call <a class="el" href="classdtNavMeshQuery.html#aa0c147e3da7fd0b59342da0fc456afc7">updateSlicedFindPath()</a> until it returns complete.</li>
<li>Call <a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd">finalizeSlicedFindPath()</a> to get the path. </li>
</ol>
</div></td></tr>
<tr class="memitem:ae9a478194f14f1a4591f8b6528007d82"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ae9a478194f14f1a4591f8b6528007d82">initSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, const unsigned int options=0)</td></tr>
<tr class="separator:ae9a478194f14f1a4591f8b6528007d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa0c147e3da7fd0b59342da0fc456afc7">updateSlicedFindPath</a> (const int maxIter, int *doneIters)</td></tr>
<tr class="separator:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98673bb238fbb139ec8407e266fa76fd"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd">finalizeSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="separator:a98673bb238fbb139ec8407e266fa76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a01b18dcb5d25fc392b6030ae5d4f310e">finalizeSlicedFindPathPartial</a> (const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *existing, const int existingSize, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="separator:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a478194f14f1a4591f8b6528007d82"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ae9a478194f14f1a4591f8b6528007d82">initSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, const unsigned int options=0)</td></tr>
<tr class="separator:ae9a478194f14f1a4591f8b6528007d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa0c147e3da7fd0b59342da0fc456afc7">updateSlicedFindPath</a> (const int maxIter, int *doneIters)</td></tr>
<tr class="separator:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98673bb238fbb139ec8407e266fa76fd"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd">finalizeSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="separator:a98673bb238fbb139ec8407e266fa76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a01b18dcb5d25fc392b6030ae5d4f310e">finalizeSlicedFindPathPartial</a> (const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *existing, const int existingSize, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="separator:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dijkstra Search Functions</div></td></tr>
<tr class="memitem:a1131b39f205440349e7efe7f2d9b0ef9"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a1131b39f205440349e7efe7f2d9b0ef9">findPolysAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:a1131b39f205440349e7efe7f2d9b0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142b8c1e54bdefc39ab41507fe931d1"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa142b8c1e54bdefc39ab41507fe931d1">findPolysAroundShape</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *verts, const int nverts, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:aa142b8c1e54bdefc39ab41507fe931d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1131b39f205440349e7efe7f2d9b0ef9"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a1131b39f205440349e7efe7f2d9b0ef9">findPolysAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:a1131b39f205440349e7efe7f2d9b0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142b8c1e54bdefc39ab41507fe931d1"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa142b8c1e54bdefc39ab41507fe931d1">findPolysAroundShape</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *verts, const int nverts, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:aa142b8c1e54bdefc39ab41507fe931d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Query Functions</div></td></tr>
<tr class="memitem:aed1dfebde233657db668416ceaee8537"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aed1dfebde233657db668416ceaee8537">findNearestPoly</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *nearestRef, float *nearestPt) const</td></tr>
<tr class="separator:aed1dfebde233657db668416ceaee8537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eb88f9f77aa29f1c85f8ccf8ad1d49"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ae7eb88f9f77aa29f1c85f8ccf8ad1d49">queryPolygons</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *polys, int *polyCount, const int maxPolys) const</td></tr>
<tr class="separator:ae7eb88f9f77aa29f1c85f8ccf8ad1d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864032da48ba6f1055deab90633ffd6"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a9864032da48ba6f1055deab90633ffd6">findLocalNeighbourhood</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:a9864032da48ba6f1055deab90633ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6d7c92a75c7773ababeb144206968"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a95f6d7c92a75c7773ababeb144206968">moveAlongSurface</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *resultPos, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *visited, int *visitedCount, const int maxVisitedSize) const</td></tr>
<tr class="separator:a95f6d7c92a75c7773ababeb144206968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7509a4bf31a215f20478c5050ef25913"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a7509a4bf31a215f20478c5050ef25913">raycast</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *t, float *hitNormal, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath) const</td></tr>
<tr class="separator:a7509a4bf31a215f20478c5050ef25913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd4282df1e863d1c813b2fe881a262"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a96bd4282df1e863d1c813b2fe881a262">raycast</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, const unsigned int options, <a class="el" href="structdtRaycastHit.html">dtRaycastHit</a> *hit, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> prevRef=0) const</td></tr>
<tr class="separator:a96bd4282df1e863d1c813b2fe881a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576a980ae29e44ad4809a25974fbd40"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a1576a980ae29e44ad4809a25974fbd40">findDistanceToWall</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *hitDist, float *hitPos, float *hitNormal) const</td></tr>
<tr class="separator:a1576a980ae29e44ad4809a25974fbd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c49662f07e52f1488622089952a154c"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a2c49662f07e52f1488622089952a154c">getPolyWallSegments</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *segmentVerts, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *segmentRefs, int *segmentCount, const int maxSegments) const</td></tr>
<tr class="separator:a2c49662f07e52f1488622089952a154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c392a14bd788b0caecf21d9fb4b3d"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#af86c392a14bd788b0caecf21d9fb4b3d">findRandomPoint</a> (const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const</td></tr>
<tr class="separator:af86c392a14bd788b0caecf21d9fb4b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb87531eb962cbd51c649469de2e4fa"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#abfb87531eb962cbd51c649469de2e4fa">findRandomPointAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const</td></tr>
<tr class="separator:abfb87531eb962cbd51c649469de2e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a90efe5d1a2b4b530aa236370574d9"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a07a90efe5d1a2b4b530aa236370574d9">closestPointOnPoly</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest, bool *posOverPoly) const</td></tr>
<tr class="separator:a07a90efe5d1a2b4b530aa236370574d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b9573e61eda951213ea9e4354e744"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa53b9573e61eda951213ea9e4354e744">closestPointOnPolyBoundary</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest) const</td></tr>
<tr class="separator:aa53b9573e61eda951213ea9e4354e744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8303a12749e252c6688c15c5c887b69"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#af8303a12749e252c6688c15c5c887b69">getPolyHeight</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *height) const</td></tr>
<tr class="separator:af8303a12749e252c6688c15c5c887b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1dfebde233657db668416ceaee8537"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aed1dfebde233657db668416ceaee8537">findNearestPoly</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *nearestRef, float *nearestPt) const</td></tr>
<tr class="separator:aed1dfebde233657db668416ceaee8537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eb88f9f77aa29f1c85f8ccf8ad1d49"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ae7eb88f9f77aa29f1c85f8ccf8ad1d49">queryPolygons</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *polys, int *polyCount, const int maxPolys) const</td></tr>
<tr class="separator:ae7eb88f9f77aa29f1c85f8ccf8ad1d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864032da48ba6f1055deab90633ffd6"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a9864032da48ba6f1055deab90633ffd6">findLocalNeighbourhood</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, int *resultCount, const int maxResult) const</td></tr>
<tr class="separator:a9864032da48ba6f1055deab90633ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6d7c92a75c7773ababeb144206968"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a95f6d7c92a75c7773ababeb144206968">moveAlongSurface</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *resultPos, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *visited, int *visitedCount, const int maxVisitedSize) const</td></tr>
<tr class="separator:a95f6d7c92a75c7773ababeb144206968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7509a4bf31a215f20478c5050ef25913"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a7509a4bf31a215f20478c5050ef25913">raycast</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *t, float *hitNormal, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath) const</td></tr>
<tr class="separator:a7509a4bf31a215f20478c5050ef25913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd4282df1e863d1c813b2fe881a262"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a96bd4282df1e863d1c813b2fe881a262">raycast</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, const unsigned int options, <a class="el" href="structdtRaycastHit.html">dtRaycastHit</a> *hit, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> prevRef=0) const</td></tr>
<tr class="separator:a96bd4282df1e863d1c813b2fe881a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576a980ae29e44ad4809a25974fbd40"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a1576a980ae29e44ad4809a25974fbd40">findDistanceToWall</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *hitDist, float *hitPos, float *hitNormal) const</td></tr>
<tr class="separator:a1576a980ae29e44ad4809a25974fbd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c49662f07e52f1488622089952a154c"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a2c49662f07e52f1488622089952a154c">getPolyWallSegments</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *segmentVerts, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *segmentRefs, int *segmentCount, const int maxSegments) const</td></tr>
<tr class="separator:a2c49662f07e52f1488622089952a154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c392a14bd788b0caecf21d9fb4b3d"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#af86c392a14bd788b0caecf21d9fb4b3d">findRandomPoint</a> (const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const</td></tr>
<tr class="separator:af86c392a14bd788b0caecf21d9fb4b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb87531eb962cbd51c649469de2e4fa"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#abfb87531eb962cbd51c649469de2e4fa">findRandomPointAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const</td></tr>
<tr class="separator:abfb87531eb962cbd51c649469de2e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a90efe5d1a2b4b530aa236370574d9"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a07a90efe5d1a2b4b530aa236370574d9">closestPointOnPoly</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest, bool *posOverPoly) const</td></tr>
<tr class="separator:a07a90efe5d1a2b4b530aa236370574d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b9573e61eda951213ea9e4354e744"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa53b9573e61eda951213ea9e4354e744">closestPointOnPolyBoundary</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest) const</td></tr>
<tr class="separator:aa53b9573e61eda951213ea9e4354e744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8303a12749e252c6688c15c5c887b69"><td class="memItemLeft" align="right" valign="top">dtStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#af8303a12749e252c6688c15c5c887b69">getPolyHeight</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *height) const</td></tr>
<tr class="separator:af8303a12749e252c6688c15c5c887b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Functions</div></td></tr>
<tr class="memitem:ac76164ed97fdedd9ea8abbe52f6c2c8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ac76164ed97fdedd9ea8abbe52f6c2c8a">isValidPolyRef</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter) const</td></tr>
<tr class="separator:ac76164ed97fdedd9ea8abbe52f6c2c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de0c0d7cc527905d3f83c613897eb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ad1de0c0d7cc527905d3f83c613897eb3">isInClosedList</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref) const</td></tr>
<tr class="separator:ad1de0c0d7cc527905d3f83c613897eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5baaa868aad36ba023ea81b10e70bd"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classdtNodePool.html">dtNodePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a5f5baaa868aad36ba023ea81b10e70bd">getNodePool</a> () const</td></tr>
<tr class="separator:a5f5baaa868aad36ba023ea81b10e70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ddaa41019804494be7da66207882de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a05ddaa41019804494be7da66207882de">getAttachedNavMesh</a> () const</td></tr>
<tr class="separator:a05ddaa41019804494be7da66207882de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76164ed97fdedd9ea8abbe52f6c2c8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ac76164ed97fdedd9ea8abbe52f6c2c8a">isValidPolyRef</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter) const</td></tr>
<tr class="separator:ac76164ed97fdedd9ea8abbe52f6c2c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de0c0d7cc527905d3f83c613897eb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ad1de0c0d7cc527905d3f83c613897eb3">isInClosedList</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref) const</td></tr>
<tr class="separator:ad1de0c0d7cc527905d3f83c613897eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5baaa868aad36ba023ea81b10e70bd"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classdtNodePool.html">dtNodePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a5f5baaa868aad36ba023ea81b10e70bd">getNodePool</a> () const</td></tr>
<tr class="separator:a5f5baaa868aad36ba023ea81b10e70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ddaa41019804494be7da66207882de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a05ddaa41019804494be7da66207882de">getAttachedNavMesh</a> () const</td></tr>
<tr class="separator:a05ddaa41019804494be7da66207882de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the ability to perform pathfinding related queries against a navigation mesh.</p>
<p>For methods that support undersized buffers, if the buffer is too small to hold the entire result set the return status of the method will include the #DT_BUFFER_TOO_SMALL flag.</p>
<p>Constant member functions can be used by multiple clients without side effects. (E.g. No change to the closed <a class="el" href="protocollist-p.html">list</a>. No impact on an in-progress sliced path query. Etc.)</p>
<p>Walls and portals: A <em>wall</em> is a polygon segment that is considered impassable. A <em>portal</em> is a passable segment between polygons. A portal may be treated as a wall based on the <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> used for a query.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdtNavMesh.html">dtNavMesh</a>, <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a>, <a class="el" href="group__detour.html#gae547f165feefc955136130c8e22f207a">dtAllocNavMeshQuery()</a>, <a class="el" href="group__detour.html#gae547f165feefc955136130c8e22f207a">dtAllocNavMeshQuery()</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a07a90efe5d1a2b4b530aa236370574d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a90efe5d1a2b4b530aa236370574d9">&#9670;&nbsp;</a></span>closestPointOnPoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::closestPointOnPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>posOverPoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the closest point on the specified polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posOverPoly</td><td>True of the position is over the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Uses the detail polygons to find the surface height. (Most accurate.)</p>
<p><code>pos</code> does not have to be within the bounds of the polygon or navigation mesh.</p>
<p>See <a class="el" href="classdtNavMeshQuery.html#aa53b9573e61eda951213ea9e4354e744">closestPointOnPolyBoundary()</a> for a limited but faster option. </p>

</div>
</div>
<a id="a07a90efe5d1a2b4b530aa236370574d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a90efe5d1a2b4b530aa236370574d9">&#9670;&nbsp;</a></span>closestPointOnPoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::closestPointOnPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>posOverPoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the closest point on the specified polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posOverPoly</td><td>True of the position is over the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="aa53b9573e61eda951213ea9e4354e744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53b9573e61eda951213ea9e4354e744">&#9670;&nbsp;</a></span>closestPointOnPolyBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::closestPointOnPolyBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a point on the boundary closest to the source point if the source point is outside the polygon's xz-bounds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id to the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Much faster than <a class="el" href="classdtNavMeshQuery.html#a07a90efe5d1a2b4b530aa236370574d9">closestPointOnPoly()</a>.</p>
<p>If the provided position lies within the polygon's xz-bounds (above or below), then <code>pos</code> and <code>closest</code> will be equal.</p>
<p>The height of <code>closest</code> will be the polygon boundary. The height detail is not used.</p>
<p><code>pos</code> does not have to be within the bounds of the polybon or the navigation mesh. </p>

</div>
</div>
<a id="aa53b9573e61eda951213ea9e4354e744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53b9573e61eda951213ea9e4354e744">&#9670;&nbsp;</a></span>closestPointOnPolyBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::closestPointOnPolyBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a point on the boundary closest to the source point if the source point is outside the polygon's xz-bounds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id to the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a98673bb238fbb139ec8407e266fa76fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98673bb238fbb139ec8407e266fa76fd">&#9670;&nbsp;</a></span>finalizeSlicedFindPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::finalizeSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes and returns the results of a sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the path array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a98673bb238fbb139ec8407e266fa76fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98673bb238fbb139ec8407e266fa76fd">&#9670;&nbsp;</a></span>finalizeSlicedFindPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::finalizeSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes and returns the results of a sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the path array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a01b18dcb5d25fc392b6030ae5d4f310e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b18dcb5d25fc392b6030ae5d4f310e">&#9670;&nbsp;</a></span>finalizeSlicedFindPathPartial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>existingSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest polygon on the existing path that was visited during the search. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">existing</td><td>An array of polygon references for the existing path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">existingSize</td><td>The number of polygon in the <code>existing</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a01b18dcb5d25fc392b6030ae5d4f310e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b18dcb5d25fc392b6030ae5d4f310e">&#9670;&nbsp;</a></span>finalizeSlicedFindPathPartial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>existingSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest polygon on the existing path that was visited during the search. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">existing</td><td>An array of polygon references for the existing path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">existingSize</td><td>The number of polygon in the <code>existing</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a1576a980ae29e44ad4809a25974fbd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576a980ae29e44ad4809a25974fbd40">&#9670;&nbsp;</a></span>findDistanceToWall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findDistanceToWall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the distance from the specified position to the nearest polygon wall. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon containing <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRadius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitDist</td><td>The distance to the nearest wall from <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitPos</td><td>The nearest position on the wall that was hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normalized ray formed from the wall point to the source point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p><code>hitPos</code> is not adjusted using the height detail data.</p>
<p><code>hitDist</code> will equal the search radius if there is no wall within the radius. In this case the values of <code>hitPos</code> and <code>hitNormal</code> are undefined.</p>
<p>The normal will become unpredicable if <code>hitDist</code> is a very small number. </p>

</div>
</div>
<a id="a1576a980ae29e44ad4809a25974fbd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576a980ae29e44ad4809a25974fbd40">&#9670;&nbsp;</a></span>findDistanceToWall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findDistanceToWall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the distance from the specified position to the nearest polygon wall. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon containing <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRadius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitDist</td><td>The distance to the nearest wall from <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitPos</td><td>The nearest position on the wall that was hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normalized ray formed from the wall point to the source point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a9864032da48ba6f1055deab90633ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864032da48ba6f1055deab90633ffd6">&#9670;&nbsp;</a></span>findLocalNeighbourhood() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findLocalNeighbourhood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the non-overlapping navigation polygons in the local neighbourhood around the center position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the query circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the query circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a9864032da48ba6f1055deab90633ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864032da48ba6f1055deab90633ffd6">&#9670;&nbsp;</a></span>findLocalNeighbourhood() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findLocalNeighbourhood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the non-overlapping navigation polygons in the local neighbourhood around the center position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the query circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the query circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is optimized for a small search radius and small number of result polygons.</p>
<p>Candidate polygons are found by searching the navigation graph beginning at the start polygon.</p>
<p>The same intersection test restrictions that apply to the findPolysAroundCircle mehtod applies to this method.</p>
<p>The value of the center point is used as the start point for cost calculations. It is not projected onto the surface of the mesh, so its y-value will effect the costs.</p>
<p>Intersection tests occur in 2D. All polygons and the search circle are projected onto the xz-plane. So the y-value of the center point does not effect intersection tests.</p>
<p>If the result arrays are is too small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a id="aed1dfebde233657db668416ceaee8537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1dfebde233657db668416ceaee8537">&#9670;&nbsp;</a></span>findNearestPoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findNearestPoly </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>nearestRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nearestPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygon nearest to the specified center point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestRef</td><td>The reference id of the nearest polygon. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestPt</td><td>The nearest point on the polygon. [opt] [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the search box does not intersect any polygons the search will return #DT_SUCCESS, but <code>nearestRef</code> will be zero. So if in doubt, check <code>nearestRef</code> before using <code>nearestPt</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not suitable for large area searches. If the search extents overlaps more than MAX_SEARCH (128) polygons it may return an invalid result. </dd></dl>

</div>
</div>
<a id="aed1dfebde233657db668416ceaee8537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1dfebde233657db668416ceaee8537">&#9670;&nbsp;</a></span>findNearestPoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findNearestPoly </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>nearestRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nearestPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygon nearest to the specified center point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestRef</td><td>The reference id of the nearest polygon. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestPt</td><td>The nearest point on the polygon. [opt] [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a9d86502949fcd4f96ffd350d4ef69e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d86502949fcd4f96ffd350d4ef69e3c">&#9670;&nbsp;</a></span>findPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a path from the start polygon to the end polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If the end polygon cannot be reached through the navigation graph, the last polygon in the path will be the nearest the end polygon.</p>
<p>If the path array is to small to hold the full result, it will be filled as far as possible from the start polygon toward the end polygon.</p>
<p>The start and end positions are used to calculate traversal costs. (The y-values impact the result.) </p>

</div>
</div>
<a id="a9d86502949fcd4f96ffd350d4ef69e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d86502949fcd4f96ffd350d4ef69e3c">&#9670;&nbsp;</a></span>findPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a path from the start polygon to the end polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered <a class="el" href="protocollist-p.html">list</a> of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1131b39f205440349e7efe7f2d9b0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1131b39f205440349e7efe7f2d9b0ef9">&#9670;&nbsp;</a></span>findPolysAroundCircle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPolysAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygons along the navigation graph that touch the specified circle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from <code>centerPos</code> to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a1131b39f205440349e7efe7f2d9b0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1131b39f205440349e7efe7f2d9b0ef9">&#9670;&nbsp;</a></span>findPolysAroundCircle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPolysAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygons along the navigation graph that touch the specified circle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from <code>centerPos</code> to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>At least one result array must be provided.</p>
<p>The order of the result set is from least to highest cost to reach the polygon.</p>
<p>A common use case for this method is to perform Dijkstra searches. Candidate polygons are found by searching the graph beginning at the start polygon.</p>
<p>If a polygon is not found via the graph search, even if it intersects the search circle, it will not be included in the result set. For example:</p>
<p>polyA is the start polygon. polyB shares an edge with polyA. (Is adjacent.) polyC shares an edge with polyB, but not with polyA Even if the search circle overlaps polyC, it will not be included in the result set unless polyB is also in the set.</p>
<p>The value of the center point is used as the start position for cost calculations. It is not projected onto the surface of the mesh, so its y-value will effect the costs.</p>
<p>Intersection tests occur in 2D. All polygons and the search circle are projected onto the xz-plane. So the y-value of the center point does not effect intersection tests.</p>
<p>If the result arrays are to small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a id="aa142b8c1e54bdefc39ab41507fe931d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142b8c1e54bdefc39ab41507fe931d1">&#9670;&nbsp;</a></span>findPolysAroundShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPolysAroundShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygons along the naviation graph that touch the specified convex polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verts</td><td>The vertices describing the convex polygon. (CCW) [(x, y, z) * <code>nverts</code>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nverts</td><td>The number of vertices in the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the search polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from the centroid point to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The order of the result set is from least to highest cost.</p>
<p>At least one result array must be provided.</p>
<p>A common use case for this method is to perform Dijkstra searches. Candidate polygons are found by searching the graph beginning at the start polygon.</p>
<p>The same intersection test restrictions that apply to <a class="el" href="classdtNavMeshQuery.html#a1131b39f205440349e7efe7f2d9b0ef9">findPolysAroundCircle()</a> method apply to this method.</p>
<p>The 3D centroid of the search polygon is used as the start position for cost calculations.</p>
<p>Intersection tests occur in 2D. All polygons are projected onto the xz-plane. So the y-values of the vertices do not effect intersection tests.</p>
<p>If the result arrays are is too small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a id="aa142b8c1e54bdefc39ab41507fe931d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142b8c1e54bdefc39ab41507fe931d1">&#9670;&nbsp;</a></span>findPolysAroundShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findPolysAroundShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the polygons along the naviation graph that touch the specified convex polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verts</td><td>The vertices describing the convex polygon. (CCW) [(x, y, z) * <code>nverts</code>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nverts</td><td>The number of vertices in the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the search polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from the centroid point to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="af86c392a14bd788b0caecf21d9fb4b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c392a14bd788b0caecf21d9fb4b3d">&#9670;&nbsp;</a></span>findRandomPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findRandomPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random location on navmesh. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="af86c392a14bd788b0caecf21d9fb4b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c392a14bd788b0caecf21d9fb4b3d">&#9670;&nbsp;</a></span>findRandomPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findRandomPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random location on navmesh. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="abfb87531eb962cbd51c649469de2e4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb87531eb962cbd51c649469de2e4fa">&#9670;&nbsp;</a></span>findRandomPointAroundCircle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findRandomPointAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random location on navmesh within the reach of specified location. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. The location is not exactly constrained by the circle, but it limits the visited polygons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="abfb87531eb962cbd51c649469de2e4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb87531eb962cbd51c649469de2e4fa">&#9670;&nbsp;</a></span>findRandomPointAroundCircle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findRandomPointAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random location on navmesh within the reach of specified location. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. The location is not exactly constrained by the circle, but it limits the visited polygons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="ac160434c85bdf9edec24fa621f120d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac160434c85bdf9edec24fa621f120d2d">&#9670;&nbsp;</a></span>findStraightPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findStraightPath </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>straightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>straightPathFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>straightPathRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>straightPathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxStraightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the straight path from the start to the end position within the polygon corridor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>Path start position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>Path end position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>An array of polygon references that represent the path corridor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>The number of polygons in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPath</td><td>Points describing the straight path. [(x, y, z) * <code>straightPathCount</code>]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathFlags</td><td>Flags describing each point. (See: #dtStraightPathFlags) [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathRefs</td><td>The reference id of the polygon that is being entered at each point. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathCount</td><td>The number of points in the straight path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxStraightPath</td><td>The maximum number of points the straight path arrays can hold. [Limit: &gt; 0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Query options. (see: #dtStraightPathOptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method peforms what is often called 'string pulling'.</p>
<p>The start position is clamped to the first polygon in the path, and the end position is clamped to the last. So the start and end positions should normally be within or very near the first and last polygons respectively.</p>
<p>The returned polygon references represent the reference id of the polygon that is entered at the associated path position. The reference id associated with the end point will always be zero. This allows, for example, matching off-mesh link points to their representative polygons.</p>
<p>If the provided result buffers are too small for the entire result set, they will be filled as far as possible from the start toward the end position. </p>

</div>
</div>
<a id="ac160434c85bdf9edec24fa621f120d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac160434c85bdf9edec24fa621f120d2d">&#9670;&nbsp;</a></span>findStraightPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::findStraightPath </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>straightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>straightPathFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>straightPathRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>straightPathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxStraightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the straight path from the start to the end position within the polygon corridor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>Path start position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>Path end position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>An array of polygon references that represent the path corridor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>The number of polygons in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPath</td><td>Points describing the straight path. [(x, y, z) * <code>straightPathCount</code>]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathFlags</td><td>Flags describing each point. (See: #dtStraightPathFlags) [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathRefs</td><td>The reference id of the polygon that is being entered at each point. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathCount</td><td>The number of points in the straight path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxStraightPath</td><td>The maximum number of points the straight path arrays can hold. [Limit: &gt; 0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Query options. (see: #dtStraightPathOptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a05ddaa41019804494be7da66207882de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ddaa41019804494be7da66207882de">&#9670;&nbsp;</a></span>getAttachedNavMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a>* dtNavMeshQuery::getAttachedNavMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the navigation mesh the query object is using. </p><dl class="section return"><dt>Returns</dt><dd>The navigation mesh the query object is using. </dd></dl>

</div>
</div>
<a id="a05ddaa41019804494be7da66207882de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ddaa41019804494be7da66207882de">&#9670;&nbsp;</a></span>getAttachedNavMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a>* dtNavMeshQuery::getAttachedNavMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the navigation mesh the query object is using. </p><dl class="section return"><dt>Returns</dt><dd>The navigation mesh the query object is using. </dd></dl>

</div>
</div>
<a id="a5f5baaa868aad36ba023ea81b10e70bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5baaa868aad36ba023ea81b10e70bd">&#9670;&nbsp;</a></span>getNodePool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classdtNodePool.html">dtNodePool</a>* dtNavMeshQuery::getNodePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the node pool. </p><dl class="section return"><dt>Returns</dt><dd>The node pool. </dd></dl>

</div>
</div>
<a id="a5f5baaa868aad36ba023ea81b10e70bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5baaa868aad36ba023ea81b10e70bd">&#9670;&nbsp;</a></span>getNodePool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classdtNodePool.html">dtNodePool</a>* dtNavMeshQuery::getNodePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the node pool. </p><dl class="section return"><dt>Returns</dt><dd>The node pool. </dd></dl>

</div>
</div>
<a id="af8303a12749e252c6688c15c5c887b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8303a12749e252c6688c15c5c887b69">&#9670;&nbsp;</a></span>getPolyHeight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::getPolyHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the height of the polygon at the provided position using the height detail. (Most accurate.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>A position within the xz-bounds of the polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>The height at the surface of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Will return #DT_FAILURE if the provided position is outside the xz-bounds of the polygon. </p>

</div>
</div>
<a id="af8303a12749e252c6688c15c5c887b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8303a12749e252c6688c15c5c887b69">&#9670;&nbsp;</a></span>getPolyHeight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::getPolyHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the height of the polygon at the provided position using the height detail. (Most accurate.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>A position within the xz-bounds of the polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>The height at the surface of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a2c49662f07e52f1488622089952a154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c49662f07e52f1488622089952a154c">&#9670;&nbsp;</a></span>getPolyWallSegments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::getPolyWallSegments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>segmentVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>segmentRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the segments for the specified polygon, optionally including portals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentVerts</td><td>The segments. [(ax, ay, az, bx, by, bz) * segmentCount] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentRefs</td><td>The reference ids of each segment's neighbor polygon. Or zero if the segment is a wall. [opt] [(parentRef) * <code>segmentCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentCount</td><td>The number of segments returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSegments</td><td>The maximum number of segments the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If the <code>segmentRefs</code> parameter is provided, then all polygon segments will be returned. Otherwise only the wall segments are returned.</p>
<p>A segment that is normally a portal will be included in the result set as a wall if the <code>filter</code> results in the neighbor polygon becoomming impassable.</p>
<p>The <code>segmentVerts</code> and <code>segmentRefs</code> buffers should normally be sized for the maximum segments per polygon of the source navigation mesh. </p>

</div>
</div>
<a id="a2c49662f07e52f1488622089952a154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c49662f07e52f1488622089952a154c">&#9670;&nbsp;</a></span>getPolyWallSegments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::getPolyWallSegments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>segmentVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>segmentRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the segments for the specified polygon, optionally including portals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentVerts</td><td>The segments. [(ax, ay, az, bx, by, bz) * segmentCount] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentRefs</td><td>The reference ids of each segment's neighbor polygon. Or zero if the segment is a wall. [opt] [(parentRef) * <code>segmentCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentCount</td><td>The number of segments returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSegments</td><td>The maximum number of segments the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="acb51d0d2798d0bc7c669ac38c25d4116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb51d0d2798d0bc7c669ac38c25d4116">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td>
          <td class="paramname"><em>nav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the query object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nav</td><td>Pointer to the <a class="el" href="classdtNavMesh.html">dtNavMesh</a> object to use for all queries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNodes</td><td>Maximum number of search nodes. [Limits: 0 &lt; value &lt;= 65536] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Must be the first function called after construction, before other functions are used.</p>
<p>This function can be used multiple times. </p>

</div>
</div>
<a id="acb51d0d2798d0bc7c669ac38c25d4116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb51d0d2798d0bc7c669ac38c25d4116">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td>
          <td class="paramname"><em>nav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the query object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nav</td><td>Pointer to the <a class="el" href="classdtNavMesh.html">dtNavMesh</a> object to use for all queries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNodes</td><td>Maximum number of search nodes. [Limits: 0 &lt; value &lt;= 65536] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="ae9a478194f14f1a4591f8b6528007d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a478194f14f1a4591f8b6528007d82">&#9670;&nbsp;</a></span>initSlicedFindPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::initSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intializes a sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>query options (see: #dtFindPathOptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling any non-slice methods before calling <a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd">finalizeSlicedFindPath()</a> or <a class="el" href="classdtNavMeshQuery.html#a01b18dcb5d25fc392b6030ae5d4f310e">finalizeSlicedFindPathPartial()</a> may result in corrupted data!</dd></dl>
<p>The <code>filter</code> pointer is stored and used for the duration of the sliced path query. </p>

</div>
</div>
<a id="ae9a478194f14f1a4591f8b6528007d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a478194f14f1a4591f8b6528007d82">&#9670;&nbsp;</a></span>initSlicedFindPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::initSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intializes a sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>query options (see: #dtFindPathOptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="ad1de0c0d7cc527905d3f83c613897eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1de0c0d7cc527905d3f83c613897eb3">&#9670;&nbsp;</a></span>isInClosedList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isInClosedList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the polygon reference is in the closed <a class="el" href="protocollist-p.html">list</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is in closed <a class="el" href="protocollist-p.html">list</a>. </dd></dl>

</div>
</div>
<a id="ad1de0c0d7cc527905d3f83c613897eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1de0c0d7cc527905d3f83c613897eb3">&#9670;&nbsp;</a></span>isInClosedList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isInClosedList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the polygon reference is in the closed <a class="el" href="protocollist-p.html">list</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is in closed <a class="el" href="protocollist-p.html">list</a>.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The closed <a class="el" href="protocollist-p.html">list</a> is the <a class="el" href="protocollist-p.html">list</a> of polygons that were fully evaluated during the last navigation graph search. (A* or Dijkstra) </p>

</div>
</div>
<a id="ac76164ed97fdedd9ea8abbe52f6c2c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76164ed97fdedd9ea8abbe52f6c2c8a">&#9670;&nbsp;</a></span>isValidPolyRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isValidPolyRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the polygon reference is valid and passes the filter restrictions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The polygon reference to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac76164ed97fdedd9ea8abbe52f6c2c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76164ed97fdedd9ea8abbe52f6c2c8a">&#9670;&nbsp;</a></span>isValidPolyRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isValidPolyRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the polygon reference is valid and passes the filter restrictions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The polygon reference to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f6d7c92a75c7773ababeb144206968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6d7c92a75c7773ababeb144206968">&#9670;&nbsp;</a></span>moveAlongSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::moveAlongSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>visitedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxVisitedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves from the start to the end position constrained to the navigation mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position of the mover within the start polygon. [(x, y, x)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The desired end position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPos</td><td>The result position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visited</td><td>The reference ids of the polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visitedCount</td><td>The number of polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxVisitedSize</td><td>The maximum number of polygons the <code>visited</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is optimized for small delta movement and a small number of polygons. If used for too great a distance, the result set will form an incomplete path.</p>
<p><code>resultPos</code> will equal the <code>endPos</code> if the end is reached. Otherwise the closest reachable position will be returned.</p>
<p><code>resultPos</code> is not projected onto the surface of the navigation mesh. Use <a class="el" href="classdtNavMeshQuery.html#af8303a12749e252c6688c15c5c887b69">getPolyHeight</a> if this is needed.</p>
<p>This method treats the end position in the same manner as the <a class="el" href="classdtNavMeshQuery.html#a7509a4bf31a215f20478c5050ef25913">raycast</a> method. (As a 2D point.) See that method's documentation for details.</p>
<p>If the <code>visited</code> array is too small to hold the entire result set, it will be filled as far as possible from the start position toward the end position. </p>

</div>
</div>
<a id="a95f6d7c92a75c7773ababeb144206968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6d7c92a75c7773ababeb144206968">&#9670;&nbsp;</a></span>moveAlongSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::moveAlongSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>visitedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxVisitedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves from the start to the end position constrained to the navigation mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position of the mover within the start polygon. [(x, y, x)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The desired end position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPos</td><td>The result position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visited</td><td>The reference ids of the polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visitedCount</td><td>The number of polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxVisitedSize</td><td>The maximum number of polygons the <code>visited</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="ae7eb88f9f77aa29f1c85f8ccf8ad1d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eb88f9f77aa29f1c85f8ccf8ad1d49">&#9670;&nbsp;</a></span>queryPolygons() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::queryPolygons </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>polyCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPolys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds polygons that overlap the search box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polys</td><td>The reference ids of the polygons that overlap the query box. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polyCount</td><td>The number of polygons in the search result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPolys</td><td>The maximum number of polygons the search result can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If no polygons are found, the function will return #DT_SUCCESS with a <code>polyCount</code> of zero.</p>
<p>If <code>polys</code> is too small to hold the entire result set, then the array will be filled to capacity. The method of choosing which polygons from the full set are included in the partial result set is undefined. </p>

</div>
</div>
<a id="ae7eb88f9f77aa29f1c85f8ccf8ad1d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eb88f9f77aa29f1c85f8ccf8ad1d49">&#9670;&nbsp;</a></span>queryPolygons() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::queryPolygons </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>polyCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPolys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds polygons that overlap the search box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polys</td><td>The reference ids of the polygons that overlap the query box. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polyCount</td><td>The number of polygons in the search result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPolys</td><td>The maximum number of polygons the search result can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a7509a4bf31a215f20478c5050ef25913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7509a4bf31a215f20478c5050ef25913">&#9670;&nbsp;</a></span>raycast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. </p><dl class="section note"><dt>Note</dt><dd>A wrapper around raycast(..., RaycastHit*). Retained for backward compatibility. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon representing the start of the ray. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The position to cast the ray toward. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>The hit parameter. (FLT_MAX if no wall hit.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normal of the nearest wall hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>The reference ids of the visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is meant to be used for quick, short distance checks.</p>
<p>If the path array is too small to hold the result, it will be filled as far as possible from the start postion toward the end position.</p>
<p><b>Using the Hit <a class="el" href="structParameter.html">Parameter</a> (t)</b></p>
<p>If the hit parameter is a very high value (FLT_MAX), then the ray has hit the end position. In this case the path represents a valid corridor to the end position and the value of <code>hitNormal</code> is undefined.</p>
<p>If the hit parameter is zero, then the start position is on the wall that was hit and the value of <code>hitNormal</code> is undefined.</p>
<p>If 0 &lt; t &lt; 1.0 then the following applies:</p>
<div class="fragment"><div class="line">distanceToHitBorder = distanceToEndPosition * t</div><div class="line">hitPoint = startPos + (endPos - startPos) * t</div></div><!-- fragment --><p><b>Use Case Restriction</b></p>
<p>The raycast ignores the y-value of the end position. (2D check.) This places significant limits on how it can be used. For example:</p>
<p>Consider a scene where there is a main floor with a second floor balcony that hangs over the main floor. So the first floor mesh extends below the balcony mesh. The start position is somewhere on the first floor. The end position is on the balcony.</p>
<p>The raycast will search toward the end position along the first floor mesh. If it reaches the end position's xz-coordinates it will indicate FLT_MAX (no wall hit), meaning it reached the end position. This is one example of why this method is meant for short distance checks. </p>

</div>
</div>
<a id="a7509a4bf31a215f20478c5050ef25913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7509a4bf31a215f20478c5050ef25913">&#9670;&nbsp;</a></span>raycast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. </p><dl class="section note"><dt>Note</dt><dd>A wrapper around raycast(..., RaycastHit*). Retained for backward compatibility. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon representing the start of the ray. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The position to cast the ray toward. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>The hit parameter. (FLT_MAX if no wall hit.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normal of the nearest wall hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>The reference ids of the visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="a96bd4282df1e863d1c813b2fe881a262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd4282df1e863d1c813b2fe881a262">&#9670;&nbsp;</a></span>raycast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtRaycastHit.html">dtRaycastHit</a> *&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>prevRef</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon representing the start of the ray. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The position to cast the ray toward. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>govern how the raycast behaves. See dtRaycastOptions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Pointer to a raycast hit structure which will be filled by the results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevRef</td><td>parent of start ref. Used during for cost calculation [opt] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is meant to be used for quick, short distance checks.</p>
<p>If the path array is too small to hold the result, it will be filled as far as possible from the start postion toward the end position.</p>
<p><b>Using the Hit <a class="el" href="structParameter.html">Parameter</a> t of RaycastHit</b></p>
<p>If the hit parameter is a very high value (FLT_MAX), then the ray has hit the end position. In this case the path represents a valid corridor to the end position and the value of <code>hitNormal</code> is undefined.</p>
<p>If the hit parameter is zero, then the start position is on the wall that was hit and the value of <code>hitNormal</code> is undefined.</p>
<p>If 0 &lt; t &lt; 1.0 then the following applies:</p>
<div class="fragment"><div class="line">distanceToHitBorder = distanceToEndPosition * t</div><div class="line">hitPoint = startPos + (endPos - startPos) * t</div></div><!-- fragment --><p><b>Use Case Restriction</b></p>
<p>The raycast ignores the y-value of the end position. (2D check.) This places significant limits on how it can be used. For example:</p>
<p>Consider a scene where there is a main floor with a second floor balcony that hangs over the main floor. So the first floor mesh extends below the balcony mesh. The start position is somewhere on the first floor. The end position is on the balcony.</p>
<p>The raycast will search toward the end position along the first floor mesh. If it reaches the end position's xz-coordinates it will indicate FLT_MAX (no wall hit), meaning it reached the end position. This is one example of why this method is meant for short distance checks. </p>

</div>
</div>
<a id="a96bd4282df1e863d1c813b2fe881a262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd4282df1e863d1c813b2fe881a262">&#9670;&nbsp;</a></span>raycast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtRaycastHit.html">dtRaycastHit</a> *&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>prevRef</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon representing the start of the ray. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The position to cast the ray toward. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>govern how the raycast behaves. See dtRaycastOptions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Pointer to a raycast hit structure which will be filled by the results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevRef</td><td>parent of start ref. Used during for cost calculation [opt] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="aa0c147e3da7fd0b59342da0fc456afc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c147e3da7fd0b59342da0fc456afc7">&#9670;&nbsp;</a></span>updateSlicedFindPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::updateSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>doneIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates an in-progress sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIter</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">doneIters</td><td>The actual number of iterations completed. [opt] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a id="aa0c147e3da7fd0b59342da0fc456afc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c147e3da7fd0b59342da0fc456afc7">&#9670;&nbsp;</a></span>updateSlicedFindPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtStatus dtNavMeshQuery::updateSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>doneIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates an in-progress sliced path query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIter</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">doneIters</td><td>The actual number of iterations completed. [opt] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/external/recast/Detour/<a class="el" href="cocos2d_2external_2recast_2Detour_2DetourNavMeshQuery_8h_source.html">DetourNavMeshQuery.h</a></li>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/external/recast/Detour/DetourNavMeshQuery.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
