<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: lws_context_creation_info Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structlws__context__creation__info-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lws_context_creation_info Struct Reference<div class="ingroups"><a class="el" href="group__context-and-vhost.html">context and vhost related functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cocos2d_2external_2websockets_2include_2android_2libwebsockets_8h_source.html">libwebsockets.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for lws_context_creation_info:</div>
<div class="dyncontent">
<div class="center"><img src="structlws__context__creation__info__coll__graph.png" border="0" usemap="#lws__context__creation__info_coll__map" alt="Collaboration graph"/></div>
<map name="lws__context__creation__info_coll__map" id="lws__context__creation__info_coll__map">
<area shape="rect" id="node2" href="structlws__protocol__vhost__options.html" title="lws_protocol_vhost\l_options" alt="" coords="1456,347,1591,389"/>
<area shape="rect" id="node49" href="structlws__http__mount.html" title="lws_http_mount" alt="" coords="1793,431,1908,457"/>
<area shape="rect" id="node3" href="structlws__plat__file__ops.html" title="lws_plat_file_ops" alt="" coords="1789,44,1912,71"/>
<area shape="rect" id="node5" href="structlws__fop__fd.html" title="lws_fop_fd" alt="" coords="2168,21,2253,48"/>
<area shape="rect" id="node4" href="structlws__fops__index.html" title="lws_fops_index" alt="" coords="1467,44,1579,71"/>
<area shape="rect" id="node6" href="structssl__ctx__st.html" title="ssl_ctx_st" alt="" coords="1809,1424,1892,1451"/>
<area shape="rect" id="node7" href="structssl__st.html" title="ssl_st" alt="" coords="2182,1069,2239,1096"/>
<area shape="rect" id="node8" href="structkssl__ctx__st.html" title="kssl_ctx_st" alt="" coords="1806,1100,1895,1127"/>
<area shape="rect" id="node9" href="structdtls1__state__st.html" title="dtls1_state_st" alt="" coords="1799,1972,1903,1999"/>
<area shape="rect" id="node10" href="structdtls1__bitmap__st.html" title="dtls1_bitmap_st" alt="" coords="1466,2104,1581,2131"/>
<area shape="rect" id="node11" href="structhm__header__st.html" title="hm_header_st" alt="" coords="1471,1927,1575,1953"/>
<area shape="rect" id="node12" href="structdtls1__timeout__st.html" title="dtls1_timeout_st" alt="" coords="1464,1977,1583,2004"/>
<area shape="rect" id="node13" href="structrecord__pqueue__st.html" title="record_pqueue_st" alt="" coords="1461,2047,1586,2073"/>
<area shape="rect" id="node14" href="structsrp__ctx__st.html" title="srp_ctx_st" alt="" coords="1482,1149,1565,1176"/>
<area shape="rect" id="node15" href="structbignum__st.html" title="bignum_st" alt="" coords="794,1159,877,1185"/>
<area shape="rect" id="node41" href="structdh__st.html" title="dh_st" alt="" coords="1177,948,1231,975"/>
<area shape="rect" id="node16" href="structssl__session__st.html" title="ssl_session_st" alt="" coords="1469,1405,1578,1432"/>
<area shape="rect" id="node17" href="structssl__cipher__st.html" title="ssl_cipher_st" alt="" coords="1155,1319,1253,1345"/>
<area shape="rect" id="node36" href="structssl__method__st.html" title="ssl_method_st" alt="" coords="1470,1301,1577,1328"/>
<area shape="rect" id="node39" href="structssl3__state__st.html" title="ssl3_state_st" alt="" coords="1473,897,1573,924"/>
<area shape="rect" id="node18" href="structx509__st.html" title="x509_st" alt="" coords="1170,1545,1238,1572"/>
<area shape="rect" id="node19" href="structASIdentifiers__st.html" title="ASIdentifiers_st" alt="" coords="778,1696,893,1723"/>
<area shape="rect" id="node20" href="structasn1__string__st.html" title="asn1_string_st" alt="" coords="441,1423,548,1449"/>
<area shape="rect" id="node21" href="structx509__cinf__st.html" title="x509_cinf_st" alt="" coords="787,1583,883,1609"/>
<area shape="rect" id="node27" href="structAUTHORITY__KEYID__st.html" title="AUTHORITY_KEYID_st" alt="" coords="752,1344,919,1371"/>
<area shape="rect" id="node28" href="structx509__cert__aux__st.html" title="x509_cert_aux_st" alt="" coords="773,1401,898,1428"/>
<area shape="rect" id="node22" href="structX509__name__st.html" title="X509_name_st" alt="" coords="440,1583,549,1609"/>
<area shape="rect" id="node46" href="structx509__store__st.html" title="x509_store_st" alt="" coords="1471,1657,1575,1684"/>
<area shape="rect" id="node23" href="structbuf__mem__st.html" title="buf_mem_st" alt="" coords="172,836,267,863"/>
<area shape="rect" id="node40" href="structssl3__buffer__st.html" title="ssl3_buffer_st" alt="" coords="312,789,416,816"/>
<area shape="rect" id="node48" href="structlws__protocols.html" title="lws_protocols" alt="" coords="595,217,698,244"/>
<area shape="rect" id="node25" href="structX509__algor__st.html" title="X509_algor_st" alt="" coords="442,1653,547,1680"/>
<area shape="rect" id="node26" href="structNAME__CONSTRAINTS__st.html" title="NAME_CONSTRAINTS_st" alt="" coords="744,1532,927,1559"/>
<area shape="rect" id="node29" href="structcrypto__ex__data__st.html" title="crypto_ex_data_st" alt="" coords="771,1279,900,1305"/>
<area shape="rect" id="node31" href="structbio__st.html" title="bio_st" alt="" coords="1175,1052,1233,1079"/>
<area shape="rect" id="node33" href="structcomp__ctx__st.html" title="comp_ctx_st" alt="" coords="1155,644,1253,671"/>
<area shape="rect" id="node30" href="structsrtp__protection__profile__st.html" title="srtp_protection_profile_st" alt="" coords="1767,481,1935,508"/>
<area shape="rect" id="node32" href="structbio__method__st.html" title="bio_method_st" alt="" coords="782,937,889,964"/>
<area shape="rect" id="node34" href="structcomp__method__st.html" title="comp_method_st" alt="" coords="774,695,897,721"/>
<area shape="rect" id="node43" href="structssl__comp__st.html" title="ssl_comp_st" alt="" coords="1156,745,1252,772"/>
<area shape="rect" id="node35" href="structX509__VERIFY__PARAM__st.html" title="X509_VERIFY_PARAM_st" alt="" coords="1113,1899,1295,1925"/>
<area shape="rect" id="node37" href="structevp__cipher__ctx__st.html" title="evp_cipher_ctx_st" alt="" coords="1615,723,1743,749"/>
<area shape="rect" id="node38" href="structevp__cipher__st.html" title="evp_cipher_st" alt="" coords="1153,695,1255,721"/>
<area shape="rect" id="node42" href="structssl3__record__st.html" title="ssl3_record_st" alt="" coords="1151,847,1257,873"/>
<area shape="rect" id="node44" href="structssl2__state__st.html" title="ssl2_state_st" alt="" coords="1801,1252,1901,1279"/>
<area shape="rect" id="node45" href="structtls__session__ticket__ext__st.html" title="tls_session_ticket\l_ext_st" alt="" coords="1787,634,1914,675"/>
<area shape="rect" id="node47" href="structlws__extension.html" title="lws_extension" alt="" coords="1798,341,1903,368"/>
<area shape="rect" id="node50" href="structlws__token__limits.html" title="lws_token_limits" alt="" coords="1791,184,1910,211"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a424a5ce268d6903e42243be94487ab85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a424a5ce268d6903e42243be94487ab85">port</a></td></tr>
<tr class="separator:a424a5ce268d6903e42243be94487ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360147555be7a3a904be1b9cd97266d6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a360147555be7a3a904be1b9cd97266d6">iface</a></td></tr>
<tr class="separator:a360147555be7a3a904be1b9cd97266d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b38d90864e3cdea64b5ebc7ecba8d"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a2f2b38d90864e3cdea64b5ebc7ecba8d">protocols</a></td></tr>
<tr class="separator:a2f2b38d90864e3cdea64b5ebc7ecba8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441e436acc5a816ab38a705ca9d11b72"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__extension.html">lws_extension</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a441e436acc5a816ab38a705ca9d11b72">extensions</a></td></tr>
<tr class="separator:a441e436acc5a816ab38a705ca9d11b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86e64146c2003f3d551da22b369d0bf"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad86e64146c2003f3d551da22b369d0bf">token_limits</a></td></tr>
<tr class="separator:ad86e64146c2003f3d551da22b369d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae534add81f6d3086310cfeb2d2a1f266"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae534add81f6d3086310cfeb2d2a1f266">ssl_private_key_password</a></td></tr>
<tr class="separator:ae534add81f6d3086310cfeb2d2a1f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebe001c71365426d112977874bfded1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0ebe001c71365426d112977874bfded1">ssl_cert_filepath</a></td></tr>
<tr class="separator:a0ebe001c71365426d112977874bfded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3413d0c73946f35c162d4a56ba7d09"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a2e3413d0c73946f35c162d4a56ba7d09">ssl_private_key_filepath</a></td></tr>
<tr class="separator:a2e3413d0c73946f35c162d4a56ba7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e6833230eca2ff8b108563303c70c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a83e6833230eca2ff8b108563303c70c6">ssl_ca_filepath</a></td></tr>
<tr class="separator:a83e6833230eca2ff8b108563303c70c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae5fe9ccc9b0ec6313a4bbf371f302a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aeae5fe9ccc9b0ec6313a4bbf371f302a">ssl_cipher_list</a></td></tr>
<tr class="separator:aeae5fe9ccc9b0ec6313a4bbf371f302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc0e5d17c33f3a4a75df446b46a548b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aafc0e5d17c33f3a4a75df446b46a548b">http_proxy_address</a></td></tr>
<tr class="separator:aafc0e5d17c33f3a4a75df446b46a548b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a7b59f2bdc869871e7bde232db94f5ca6">http_proxy_port</a></td></tr>
<tr class="separator:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9d22437de92c197f3cee52912b2c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9c9d22437de92c197f3cee52912b2c03">gid</a></td></tr>
<tr class="separator:a9c9d22437de92c197f3cee52912b2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105b4180008cb3e672d57beead8382e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac105b4180008cb3e672d57beead8382e">uid</a></td></tr>
<tr class="separator:ac105b4180008cb3e672d57beead8382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9d3b17a25e1fbc772f21eb4959a82724">options</a></td></tr>
<tr class="separator:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f30f5ed4ae114f75bd976c21630c032"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a1f30f5ed4ae114f75bd976c21630c032">user</a></td></tr>
<tr class="separator:a1f30f5ed4ae114f75bd976c21630c032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac583ce92b8e1c949cb6fef6bfe713d56">ka_time</a></td></tr>
<tr class="separator:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baab4285c679fbe027c2504621d7410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3baab4285c679fbe027c2504621d7410">ka_probes</a></td></tr>
<tr class="separator:a3baab4285c679fbe027c2504621d7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381342a398883d6204955ff3c1849ddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a381342a398883d6204955ff3c1849ddd">ka_interval</a></td></tr>
<tr class="separator:a381342a398883d6204955ff3c1849ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eb10f9029ecf72498d267ee7fc6ebb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a36eb10f9029ecf72498d267ee7fc6ebb">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a36eb10f9029ecf72498d267ee7fc6ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0cdfd3c484689ba6f0f2cc91b38ce948">max_http_header_data</a></td></tr>
<tr class="separator:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b154e79abc1167ba4ac3539f4af6720"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0b154e79abc1167ba4ac3539f4af6720">max_http_header_pool</a></td></tr>
<tr class="separator:a0b154e79abc1167ba4ac3539f4af6720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1af38a410556cc5db05e4973e8d27"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aaae1af38a410556cc5db05e4973e8d27">_unused</a> [8]</td></tr>
<tr class="separator:aaae1af38a410556cc5db05e4973e8d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structssl__ctx__st.html">SSL_CTX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a1654d41bea6fb2f619b57e6a264b26a4">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae52f3237e144e9ddcab5e2cf91d1e419">count_threads</a></td></tr>
<tr class="separator:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e63e24c88289e0c8352377ef4d3646"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a45e63e24c88289e0c8352377ef4d3646">fd_limit_per_thread</a></td></tr>
<tr class="separator:a45e63e24c88289e0c8352377ef4d3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a6cfa3d51df2def3349a5cbf0d712822d">timeout_secs</a></td></tr>
<tr class="separator:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad166109b7e704c8276756b2ce60d2d77"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad166109b7e704c8276756b2ce60d2d77">ecdh_curve</a></td></tr>
<tr class="separator:ad166109b7e704c8276756b2ce60d2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d7895c929bd30d1136c9d8d790897f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a82d7895c929bd30d1136c9d8d790897f">vhost_name</a></td></tr>
<tr class="separator:a82d7895c929bd30d1136c9d8d790897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf320db7f27298ac7e80bded9316ba12"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#acf320db7f27298ac7e80bded9316ba12">plugin_dirs</a></td></tr>
<tr class="separator:acf320db7f27298ac7e80bded9316ba12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b00b2b00fa958ad93285cacd668732"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a05b00b2b00fa958ad93285cacd668732">pvo</a></td></tr>
<tr class="separator:a05b00b2b00fa958ad93285cacd668732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a81697c6b763b5ef3ee52862bc70b07d6">keepalive_timeout</a></td></tr>
<tr class="separator:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a445e8e76edab8f54c0b0aa026c28c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a30a445e8e76edab8f54c0b0aa026c28c">log_filepath</a></td></tr>
<tr class="separator:a30a445e8e76edab8f54c0b0aa026c28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d0df372d4609de6de6902f4017dbc3"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a29d0df372d4609de6de6902f4017dbc3">mounts</a></td></tr>
<tr class="separator:a29d0df372d4609de6de6902f4017dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4179745f15085a70e36b633997b94b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a7c4179745f15085a70e36b633997b94b">server_string</a></td></tr>
<tr class="separator:a7c4179745f15085a70e36b633997b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f88c0745adbd1d6b9b619b8de30209"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a57f88c0745adbd1d6b9b619b8de30209">pt_serv_buf_size</a></td></tr>
<tr class="separator:a57f88c0745adbd1d6b9b619b8de30209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aa8d9e85e137f35fb006f2e4a53f0887a">max_http_header_data2</a></td></tr>
<tr class="separator:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704940261951ced6b5d8191bd8b9bb2d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a704940261951ced6b5d8191bd8b9bb2d">ssl_options_set</a></td></tr>
<tr class="separator:a704940261951ced6b5d8191bd8b9bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#adb0bc0b28cd7d90ab306723d8ffa96fa">ssl_options_clear</a></td></tr>
<tr class="separator:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1a25a7df3793f59047e20dd580078"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a33a1a25a7df3793f59047e20dd580078">ws_ping_pong_interval</a></td></tr>
<tr class="separator:a33a1a25a7df3793f59047e20dd580078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b9d4df584baf136bdcb36e5af6dfbf"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#af8b9d4df584baf136bdcb36e5af6dfbf">headers</a></td></tr>
<tr class="separator:af8b9d4df584baf136bdcb36e5af6dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f9df91de3153e7dce270e0ef1abce3"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a64f9df91de3153e7dce270e0ef1abce3">reject_service_keywords</a></td></tr>
<tr class="separator:a64f9df91de3153e7dce270e0ef1abce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050e82073957b8a89e24ddb84aaba14"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad050e82073957b8a89e24ddb84aaba14">external_baggage_free_on_destroy</a></td></tr>
<tr class="separator:ad050e82073957b8a89e24ddb84aaba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c709d5dcde2e57b82794b0125208a7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a83c709d5dcde2e57b82794b0125208a7">client_ssl_private_key_password</a></td></tr>
<tr class="separator:a83c709d5dcde2e57b82794b0125208a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3455d3866b9f9f40752ebad440382f50"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3455d3866b9f9f40752ebad440382f50">client_ssl_cert_filepath</a></td></tr>
<tr class="separator:a3455d3866b9f9f40752ebad440382f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7940d8355c16a937d50d271226c3401f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a7940d8355c16a937d50d271226c3401f">client_ssl_private_key_filepath</a></td></tr>
<tr class="separator:a7940d8355c16a937d50d271226c3401f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2de485060968e7be1a6f1238d69521"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a8e2de485060968e7be1a6f1238d69521">client_ssl_ca_filepath</a></td></tr>
<tr class="separator:a8e2de485060968e7be1a6f1238d69521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302cd766811c49855768c0faf564383"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9302cd766811c49855768c0faf564383">client_ssl_cipher_list</a></td></tr>
<tr class="separator:a9302cd766811c49855768c0faf564383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b535fcf5f638383183e1919969f7c"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__plat__file__ops.html">lws_plat_file_ops</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#acf4b535fcf5f638383183e1919969f7c">fops</a></td></tr>
<tr class="separator:acf4b535fcf5f638383183e1919969f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f4d57af65c2eea7947d518ba8782e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a15f4d57af65c2eea7947d518ba8782e2">simultaneous_ssl_restriction</a></td></tr>
<tr class="separator:a15f4d57af65c2eea7947d518ba8782e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515032e62576494a69f41971885449cc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a515032e62576494a69f41971885449cc">socks_proxy_address</a></td></tr>
<tr class="separator:a515032e62576494a69f41971885449cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f1e3d6c50337d2d93bfbf58c04c934"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae0f1e3d6c50337d2d93bfbf58c04c934">socks_proxy_port</a></td></tr>
<tr class="separator:ae0f1e3d6c50337d2d93bfbf58c04c934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b0f0e624463ec02492b009dea7a216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a12b0f0e624463ec02492b009dea7a216">bind_iface</a></td></tr>
<tr class="separator:a12b0f0e624463ec02492b009dea7a216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d80e89f41b3e195ad36dd1f6fafcb59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a2d80e89f41b3e195ad36dd1f6fafcb59">ssl_info_event_mask</a></td></tr>
<tr class="separator:a2d80e89f41b3e195ad36dd1f6fafcb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5400952fc021de4d5c02a5193b1705f1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a5400952fc021de4d5c02a5193b1705f1">timeout_secs_ah_idle</a></td></tr>
<tr class="separator:a5400952fc021de4d5c02a5193b1705f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c403fd540fcf8554be6ca1396905a"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac34c403fd540fcf8554be6ca1396905a">ip_limit_ah</a></td></tr>
<tr class="separator:ac34c403fd540fcf8554be6ca1396905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3336f5097e8206ea21eaa37242c3c41"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae3336f5097e8206ea21eaa37242c3c41">ip_limit_wsi</a></td></tr>
<tr class="separator:ae3336f5097e8206ea21eaa37242c3c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763a5795958204e570e8d8a848ad0feb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a763a5795958204e570e8d8a848ad0feb">http2_settings</a> [7]</td></tr>
<tr class="separator:a763a5795958204e570e8d8a848ad0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> - parameters to create context with</p>
<p>: Port to listen on... you can use CONTEXT_PORT_NO_LISTEN to suppress listening on any port, that's what you want if you are not running a websocket server at all but just using it as a client : NULL to bind the listen socket to all interfaces, or the interface name, eg, "eth2" : Array of structures listing supported protocols and a protocol- specific callback for each one. The <a class="el" href="protocollist-p.html">list</a> is ended with an entry that has a NULL callback pointer. It's not const because we write the owning_server member : NULL or array of <a class="el" href="structlws__extension.html">lws_extension</a> structs listing the extensions this context supports. If you configured with &ndash;without-extensions, you should give NULL here. : NULL or struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> pointer which is initialized with a token length limit for each possible WSI_TOKEN_*** : If libwebsockets was compiled to use ssl, and you want to listen using SSL, set to the filepath to fetch the server cert from, otherwise NULL for unencrypted : filepath to private key if wanting SSL mode; if this is set to NULL but sll_cert_filepath is set, the OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called to allow setting of the private key directly via openSSL library calls : CA certificate filepath or NULL : List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" : If non-NULL, attempts to proxy via the given address. If proxy auth is required, use format "username:password@server:port" : If http_proxy_address was non-NULL, uses this port at the address : group id to change to after setting listen socket, or -1. : user id to change to after setting listen socket, or -1. : 0, or LWS_SERVER_OPTION_... bitfields : optional user pointer that can be recovered via the context pointer using lws_context_user : 0 for no keepalive, otherwise apply this keepalive timeout to all libwebsocket sockets, client or server : if ka_time was nonzero, after the timeout expires how many times to try to get a response from the peer before giving up and killing the connection : if ka_time was nonzero, how long to wait before each ka_probes attempt : If non-null, swap out libwebsockets ssl implementation for the one provided by provided_ssl_ctx. Libwebsockets no longer is responsible for freeing the context if this option is selected. : The max amount of header payload that can be handled in an http request (unrecognized header payload is dropped) : The max number of connections with http headers that can be processed simultaneously (the corresponding memory is allocated for the lifetime of the context). If the pool is busy new incoming connections must wait for accept until one becomes free.</p>
<p>struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> - parameters to create context and /or vhost with</p>
<p>This is also used to create vhosts.... if LWS_SERVER_OPTION_EXPLICIT_VHOSTS is not given, then for backwards compatibility one vhost is created at context-creation time using the info from this struct.</p>
<p>If LWS_SERVER_OPTION_EXPLICIT_VHOSTS is given, then no vhosts are created at the same time as the context, they are expected to be created afterwards. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="aaae1af38a410556cc5db05e4973e8d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae1af38a410556cc5db05e4973e8d27">&#9670;&nbsp;</a></span>_unused</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lws_context_creation_info::_unused</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy </p>

</div>
</div>
<a id="a12b0f0e624463ec02492b009dea7a216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b0f0e624463ec02492b009dea7a216">&#9670;&nbsp;</a></span>bind_iface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::bind_iface</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: nonzero to strictly bind sockets to the interface name in .iface (eg, "eth2"), using SO_BIND_TO_DEVICE.</p>
<p>Requires SO_BINDTODEVICE support from your OS and CAP_NET_RAW capability.</p>
<p>Notice that common things like access network interface IP from your local machine use your lo / loopback interface and will be disallowed by this. </p>

</div>
</div>
<a id="a8e2de485060968e7be1a6f1238d69521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2de485060968e7be1a6f1238d69521">&#9670;&nbsp;</a></span>client_ssl_ca_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::client_ssl_ca_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Client SSL context init: CA certificate filepath or NULL </p>

</div>
</div>
<a id="a3455d3866b9f9f40752ebad440382f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3455d3866b9f9f40752ebad440382f50">&#9670;&nbsp;</a></span>client_ssl_cert_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::client_ssl_cert_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Client SSL context init:T he certificate the client should present to the peer on connection </p>

</div>
</div>
<a id="a9302cd766811c49855768c0faf564383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9302cd766811c49855768c0faf564383">&#9670;&nbsp;</a></span>client_ssl_cipher_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::client_ssl_cipher_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Client SSL context init: List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" </p>

</div>
</div>
<a id="a7940d8355c16a937d50d271226c3401f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7940d8355c16a937d50d271226c3401f">&#9670;&nbsp;</a></span>client_ssl_private_key_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::client_ssl_private_key_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Client SSL context init: filepath to client private key if this is set to NULL but client_ssl_cert_filepath is set, you can handle the LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS callback of protocols[0] to allow setting of the private key directly via openSSL library calls </p>

</div>
</div>
<a id="a83c709d5dcde2e57b82794b0125208a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c709d5dcde2e57b82794b0125208a7">&#9670;&nbsp;</a></span>client_ssl_private_key_password</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::client_ssl_private_key_password</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Client SSL context init: NULL or the passphrase needed for the private key </p>

</div>
</div>
<a id="ae52f3237e144e9ddcab5e2cf91d1e419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52f3237e144e9ddcab5e2cf91d1e419">&#9670;&nbsp;</a></span>count_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::count_threads</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: how many contexts to create in an array, 0 = 1 </p>

</div>
</div>
<a id="ad166109b7e704c8276756b2ce60d2d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad166109b7e704c8276756b2ce60d2d77">&#9670;&nbsp;</a></span>ecdh_curve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ecdh_curve</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: if NULL, defaults to initializing server with "prime256v1" </p>

</div>
</div>
<a id="a441e436acc5a816ab38a705ca9d11b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441e436acc5a816ab38a705ca9d11b72">&#9670;&nbsp;</a></span>extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__extension.html">lws_extension</a> * lws_context_creation_info::extensions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or array of <a class="el" href="structlws__extension.html">lws_extension</a> structs listing the extensions this context supports. </p>

</div>
</div>
<a id="ad050e82073957b8a89e24ddb84aaba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad050e82073957b8a89e24ddb84aaba14">&#9670;&nbsp;</a></span>external_baggage_free_on_destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lws_context_creation_info::external_baggage_free_on_destroy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or pointer to something externally malloc'd, that should be freed when the context is destroyed. This allows you to automatically sync the freeing action to the context destruction action, so there is no need for an external free() if the context succeeded to create. </p>

</div>
</div>
<a id="a45e63e24c88289e0c8352377ef4d3646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e63e24c88289e0c8352377ef4d3646">&#9670;&nbsp;</a></span>fd_limit_per_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::fd_limit_per_thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: nonzero means restrict each service thread to this many fds, 0 means the default which is divide the process fd limit by the number of threads. </p>

</div>
</div>
<a id="acf4b535fcf5f638383183e1919969f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4b535fcf5f638383183e1919969f7c">&#9670;&nbsp;</a></span>fops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__plat__file__ops.html">lws_plat_file_ops</a> * lws_context_creation_info::fops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or pointer to an array of fops structs, terminated by a sentinel with NULL .open.</p>
<p>If NULL, lws provides just the platform file operations struct for backwards compatibility. </p>

</div>
</div>
<a id="a9c9d22437de92c197f3cee52912b2c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9d22437de92c197f3cee52912b2c03">&#9670;&nbsp;</a></span>gid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::gid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: group id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a id="af8b9d4df584baf136bdcb36e5af6dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b9d4df584baf136bdcb36e5af6dfbf">&#9670;&nbsp;</a></span>headers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> * lws_context_creation_info::headers</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked <a class="el" href="protocollist-p.html">list</a> of per-vhost canned headers that are added to server responses </p>

</div>
</div>
<a id="a763a5795958204e570e8d8a848ad0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763a5795958204e570e8d8a848ad0feb">&#9670;&nbsp;</a></span>http2_settings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lws_context_creation_info::http2_settings</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: after context creation http2_settings[1] thru [6] have been set to the lws platform default values. VHOST: if http2_settings[0] is nonzero, the values given in http2_settings[1]..[6] are used instead of the lws platform default values. Just leave all at 0 if you don't care. </p>

</div>
</div>
<a id="aafc0e5d17c33f3a4a75df446b46a548b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc0e5d17c33f3a4a75df446b46a548b">&#9670;&nbsp;</a></span>http_proxy_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::http_proxy_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If non-NULL, attempts to proxy via the given address. If proxy auth is required, use format "username:password\@server:port" </p>

</div>
</div>
<a id="a7b59f2bdc869871e7bde232db94f5ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b59f2bdc869871e7bde232db94f5ca6">&#9670;&nbsp;</a></span>http_proxy_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::http_proxy_port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If http_proxy_address was non-NULL, uses this port </p>

</div>
</div>
<a id="a360147555be7a3a904be1b9cd97266d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360147555be7a3a904be1b9cd97266d6">&#9670;&nbsp;</a></span>iface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::iface</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL to bind the listen socket to all interfaces, or the interface name, eg, "eth2" If options specifies LWS_SERVER_OPTION_UNIX_SOCK, this member is the pathname of a UNIX domain socket. you can use the UNIX domain sockets in abstract namespace, by prepending an at symbol to the socket name. </p>

</div>
</div>
<a id="ac34c403fd540fcf8554be6ca1396905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34c403fd540fcf8554be6ca1396905a">&#9670;&nbsp;</a></span>ip_limit_ah</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short lws_context_creation_info::ip_limit_ah</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: max number of ah a single IP may use simultaneously 0 is no limit. This is a soft limit: if the limit is reached, connections from that IP will wait in the ah waiting <a class="el" href="protocollist-p.html">list</a> and not be able to acquire an ah until a connection belonging to the IP relinquishes one it already has. </p>

</div>
</div>
<a id="ae3336f5097e8206ea21eaa37242c3c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3336f5097e8206ea21eaa37242c3c41">&#9670;&nbsp;</a></span>ip_limit_wsi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short lws_context_creation_info::ip_limit_wsi</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: max number of wsi a single IP may use simultaneously. 0 is no limit. This is a hard limit, connections from the same IP will simply be dropped once it acquires the amount of simultaneous wsi / accepted connections given here. </p>

</div>
</div>
<a id="a381342a398883d6204955ff3c1849ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381342a398883d6204955ff3c1849ddd">&#9670;&nbsp;</a></span>ka_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, how long to wait before each ka_probes attempt </p>

</div>
</div>
<a id="a3baab4285c679fbe027c2504621d7410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baab4285c679fbe027c2504621d7410">&#9670;&nbsp;</a></span>ka_probes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_probes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, after the timeout expires how many times to try to get a response from the peer before giving up and killing the connection </p>

</div>
</div>
<a id="ac583ce92b8e1c949cb6fef6bfe713d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac583ce92b8e1c949cb6fef6bfe713d56">&#9670;&nbsp;</a></span>ka_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for no TCP keepalive, otherwise apply this keepalive timeout to all libwebsocket sockets, client or server </p>

</div>
</div>
<a id="a81697c6b763b5ef3ee52862bc70b07d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81697c6b763b5ef3ee52862bc70b07d6">&#9670;&nbsp;</a></span>keepalive_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::keepalive_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: (default = 0 = 60s) seconds to allow remote client to hold on to an idle HTTP/1.1 connection </p>

</div>
</div>
<a id="a30a445e8e76edab8f54c0b0aa026c28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a445e8e76edab8f54c0b0aa026c28c">&#9670;&nbsp;</a></span>log_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::log_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to append logs to... this is opened before any dropping of initial privileges </p>

</div>
</div>
<a id="a0cdfd3c484689ba6f0f2cc91b38ce948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdfd3c484689ba6f0f2cc91b38ce948">&#9670;&nbsp;</a></span>max_http_header_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max amount of header payload that can be handled in an http request (unrecognized header payload is dropped) </p>

</div>
</div>
<a id="aa8d9e85e137f35fb006f2e4a53f0887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d9e85e137f35fb006f2e4a53f0887a">&#9670;&nbsp;</a></span>max_http_header_data2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::max_http_header_data2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if max_http_header_data is 0 and this is nonzero, this will be used in place of the default. It's like this for compatibility with the original short version, this is unsigned int length. </p>

</div>
</div>
<a id="a0b154e79abc1167ba4ac3539f4af6720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b154e79abc1167ba4ac3539f4af6720">&#9670;&nbsp;</a></span>max_http_header_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max number of connections with http headers that can be processed simultaneously (the corresponding memory is allocated for the lifetime of the context). If the pool is busy new incoming connections must wait for accept until one becomes free. </p>

</div>
</div>
<a id="a29d0df372d4609de6de6902f4017dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d0df372d4609de6de6902f4017dbc3">&#9670;&nbsp;</a></span>mounts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a> * lws_context_creation_info::mounts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: optional linked <a class="el" href="protocollist-p.html">list</a> of mounts for this vhost </p>

</div>
</div>
<a id="a9d3b17a25e1fbc772f21eb4959a82724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3b17a25e1fbc772f21eb4959a82724">&#9670;&nbsp;</a></span>options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::options</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST + CONTEXT: 0, or LWS_SERVER_OPTION_... bitfields </p>

</div>
</div>
<a id="acf320db7f27298ac7e80bded9316ba12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf320db7f27298ac7e80bded9316ba12">&#9670;&nbsp;</a></span>plugin_dirs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *const  * lws_context_creation_info::plugin_dirs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or NULL-terminated array of directories to scan for lws protocol plugins at context creation time </p>

</div>
</div>
<a id="a424a5ce268d6903e42243be94487ab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424a5ce268d6903e42243be94487ab85">&#9670;&nbsp;</a></span>port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Port to listen on. Use CONTEXT_PORT_NO_LISTEN to suppress listening for a client. Use CONTEXT_PORT_NO_LISTEN_SERVER if you are writing a server but you are using <a class="el" href="group__sock-adopt.html">Socket adoption helpers</a> instead of the built-in listener</p>
<p>VHOST: Port to listen on... you can use CONTEXT_PORT_NO_LISTEN to suppress listening on any port, that's what you want if you are not running a websocket server at all but just using it as a client </p>

</div>
</div>
<a id="a2f2b38d90864e3cdea64b5ebc7ecba8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b38d90864e3cdea64b5ebc7ecba8d">&#9670;&nbsp;</a></span>protocols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> * lws_context_creation_info::protocols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Array of structures listing supported protocols and a protocol- specific callback for each one. The <a class="el" href="protocollist-p.html">list</a> is ended with an entry that has a NULL callback pointer. </p>

</div>
</div>
<a id="a36eb10f9029ecf72498d267ee7fc6ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eb10f9029ecf72498d267ee7fc6ebb">&#9670;&nbsp;</a></span>provided_client_ssl_ctx <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structssl__ctx__st.html">SSL_CTX</a> * lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: If non-null, swap out libwebsockets ssl implementation for the one provided by provided_ssl_ctx. Libwebsockets no longer is responsible for freeing the context if this option is selected. </p>

</div>
</div>
<a id="a1654d41bea6fb2f619b57e6a264b26a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1654d41bea6fb2f619b57e6a264b26a4">&#9670;&nbsp;</a></span>provided_client_ssl_ctx <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structssl__ctx__st.html">SSL_CTX</a>* lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: If non-null, swap out libwebsockets ssl implementation for the one provided by provided_ssl_ctx. Libwebsockets no longer is responsible for freeing the context if this option is selected. </p>

</div>
</div>
<a id="a57f88c0745adbd1d6b9b619b8de30209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f88c0745adbd1d6b9b619b8de30209">&#9670;&nbsp;</a></span>pt_serv_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::pt_serv_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 = default of 4096. This buffer is used by various service related features including file serving, it defines the max chunk of file that can be sent at once. At the risk of lws having to buffer failed large sends, it can be increased to, eg, 128KiB to improve throughput. </p>

</div>
</div>
<a id="a05b00b2b00fa958ad93285cacd668732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b00b2b00fa958ad93285cacd668732">&#9670;&nbsp;</a></span>pvo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> * lws_context_creation_info::pvo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked <a class="el" href="protocollist-p.html">list</a> of per-vhost options made accessible to protocols </p>

</div>
</div>
<a id="a64f9df91de3153e7dce270e0ef1abce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f9df91de3153e7dce270e0ef1abce3">&#9670;&nbsp;</a></span>reject_service_keywords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> * lws_context_creation_info::reject_service_keywords</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: Optional <a class="el" href="protocollist-p.html">list</a> of keywords and rejection codes + text.</p>
<p>The keywords are checked for existing in the user agent string.</p>
<p>Eg, "badrobot" "404 Not Found" </p>

</div>
</div>
<a id="a7c4179745f15085a70e36b633997b94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4179745f15085a70e36b633997b94b">&#9670;&nbsp;</a></span>server_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::server_string</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: string used in HTTP headers to identify server software, if NULL, "libwebsockets". </p>

</div>
</div>
<a id="a15f4d57af65c2eea7947d518ba8782e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f4d57af65c2eea7947d518ba8782e2">&#9670;&nbsp;</a></span>simultaneous_ssl_restriction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::simultaneous_ssl_restriction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 (no limit) or limit of simultaneous SSL sessions possible. </p>

</div>
</div>
<a id="a515032e62576494a69f41971885449cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515032e62576494a69f41971885449cc">&#9670;&nbsp;</a></span>socks_proxy_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::socks_proxy_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If non-NULL, attempts to proxy via the given address. If proxy auth is required, use format "username:password\@server:port" </p>

</div>
</div>
<a id="ae0f1e3d6c50337d2d93bfbf58c04c934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f1e3d6c50337d2d93bfbf58c04c934">&#9670;&nbsp;</a></span>socks_proxy_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::socks_proxy_port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If socks_proxy_address was non-NULL, uses this port </p>

</div>
</div>
<a id="a83e6833230eca2ff8b108563303c70c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e6833230eca2ff8b108563303c70c6">&#9670;&nbsp;</a></span>ssl_ca_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ssl_ca_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: CA certificate filepath or NULL. (For backwards compatibility, this can also be used to pass the client CA filepath when setting up a vhost client SSL context, but it is preferred to use .client_ssl_ca_filepath for that.)</p>
<p>VHOST: CA certificate filepath or NULL </p>

</div>
</div>
<a id="a0ebe001c71365426d112977874bfded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebe001c71365426d112977874bfded1">&#9670;&nbsp;</a></span>ssl_cert_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ssl_cert_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If libwebsockets was compiled to use ssl, and you want to listen using SSL, set to the filepath to fetch the server cert from, otherwise NULL for unencrypted. (For backwards compatibility, this can also be used to pass the client certificate when setting up a vhost client SSL context, but it is preferred to use .client_ssl_cert_filepath for that.)</p>
<p>VHOST: If libwebsockets was compiled to use ssl, and you want to listen using SSL, set to the filepath to fetch the server cert from, otherwise NULL for unencrypted </p>

</div>
</div>
<a id="aeae5fe9ccc9b0ec6313a4bbf371f302a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae5fe9ccc9b0ec6313a4bbf371f302a">&#9670;&nbsp;</a></span>ssl_cipher_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ssl_cipher_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" (For backwards compatibility, this can also be used to pass the client cipher <a class="el" href="protocollist-p.html">list</a> when setting up a vhost client SSL context, but it is preferred to use .client_ssl_cipher_list for that.)</p>
<p>VHOST: List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" </p>

</div>
</div>
<a id="a2d80e89f41b3e195ad36dd1f6fafcb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d80e89f41b3e195ad36dd1f6fafcb59">&#9670;&nbsp;</a></span>ssl_info_event_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ssl_info_event_mask</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: mask of ssl events to be reported on LWS_CALLBACK_SSL_INFO callback for connections on this vhost. The mask values are of the form SSL_CB_ALERT, defined in openssl/ssl.h. The default of 0 means no info events will be reported. </p>

</div>
</div>
<a id="adb0bc0b28cd7d90ab306723d8ffa96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bc0b28cd7d90ab306723d8ffa96fa">&#9670;&nbsp;</a></span>ssl_options_clear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be cleared as SSL options </p>

</div>
</div>
<a id="a704940261951ced6b5d8191bd8b9bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704940261951ced6b5d8191bd8b9bb2d">&#9670;&nbsp;</a></span>ssl_options_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be set as SSL options </p>

</div>
</div>
<a id="a2e3413d0c73946f35c162d4a56ba7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3413d0c73946f35c162d4a56ba7d09">&#9670;&nbsp;</a></span>ssl_private_key_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ssl_private_key_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to private key if wanting SSL mode; if this is set to NULL but ssl_cert_filepath is set, the OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called to allow setting of the private key directly via openSSL library calls. (For backwards compatibility, this can also be used to pass the client cert private key filepath when setting up a vhost client SSL context, but it is preferred to use .client_ssl_private_key_filepath for that.)</p>
<p>VHOST: filepath to private key if wanting SSL mode; if this is set to NULL but sll_cert_filepath is set, the OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called to allow setting of the private key directly via openSSL library calls </p>

</div>
</div>
<a id="ae534add81f6d3086310cfeb2d2a1f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae534add81f6d3086310cfeb2d2a1f266">&#9670;&nbsp;</a></span>ssl_private_key_password</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::ssl_private_key_password</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or the passphrase needed for the private key. (For backwards compatibility, this can also be used to pass the client cert passphrase when setting up a vhost client SSL context, but it is preferred to use .client_ssl_private_key_password for that.)</p>
<p>VHOST: NULL or the passphrase needed for the private key </p>

</div>
</div>
<a id="a6cfa3d51df2def3349a5cbf0d712822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfa3d51df2def3349a5cbf0d712822d">&#9670;&nbsp;</a></span>timeout_secs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::timeout_secs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: various processes involving network roundtrips in the library are protected from hanging forever by timeouts. If nonzero, this member lets you set the timeout used in seconds. Otherwise a default timeout is used. </p>

</div>
</div>
<a id="a5400952fc021de4d5c02a5193b1705f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5400952fc021de4d5c02a5193b1705f1">&#9670;&nbsp;</a></span>timeout_secs_ah_idle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::timeout_secs_ah_idle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: seconds to allow a client to hold an ah without using it. 0 defaults to 10s. </p>

</div>
</div>
<a id="ad86e64146c2003f3d551da22b369d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86e64146c2003f3d551da22b369d0bf">&#9670;&nbsp;</a></span>token_limits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> * lws_context_creation_info::token_limits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL or struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> pointer which is initialized with a token length limit for each possible WSI_TOKEN_ </p>

</div>
</div>
<a id="ac105b4180008cb3e672d57beead8382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105b4180008cb3e672d57beead8382e">&#9670;&nbsp;</a></span>uid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::uid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: user id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a id="a1f30f5ed4ae114f75bd976c21630c032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f30f5ed4ae114f75bd976c21630c032">&#9670;&nbsp;</a></span>user</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lws_context_creation_info::user</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST + CONTEXT: optional user pointer that will be associated with the context when creating the context (and can be retrieved by lws_context_user(context), or with the vhost when creating the vhost (and can be retrieved by lws_vhost_user(vhost)). You will need to use LWS_SERVER_OPTION_EXPLICIT_VHOSTS and create the vhost separately if you care about giving the context and vhost different user pointer values.</p>
<p>CONTEXT: optional user pointer that can be recovered via the context pointer using lws_context_user </p>

</div>
</div>
<a id="a82d7895c929bd30d1136c9d8d790897f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d7895c929bd30d1136c9d8d790897f">&#9670;&nbsp;</a></span>vhost_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lws_context_creation_info::vhost_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: name of vhost, must match external DNS name used to access the site, like "warmcat.com" as it's used to match Host: header and / or SNI name for SSL. </p>

</div>
</div>
<a id="a33a1a25a7df3793f59047e20dd580078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a1a25a7df3793f59047e20dd580078">&#9670;&nbsp;</a></span>ws_ping_pong_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short lws_context_creation_info::ws_ping_pong_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for none, else interval in seconds between sending PINGs on idle websocket connections. When the PING is sent, the PONG must come within the normal timeout_secs timeout period or the connection will be dropped. Any RX or TX traffic on the connection restarts the interval timer, so a connection which always sends or receives something at intervals less than the interval given here will never send PINGs / expect PONGs. Conversely as soon as the ws connection is established, an idle connection will do the PING / PONG roundtrip as soon as ws_ping_pong_interval seconds has passed without traffic </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/external/websockets/include/android/<a class="el" href="cocos2d_2external_2websockets_2include_2android_2libwebsockets_8h_source.html">libwebsockets.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
