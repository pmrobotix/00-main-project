<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: btAlignedObjectArray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classbtAlignedObjectArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">btAlignedObjectArray&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cocos2d_2external_2bullet_2LinearMath_2btAlignedObjectArray_8h_source.html">btAlignedObjectArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray_1_1less.html">less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6ea335622f18386671194eb6bd6a41b"><td class="memItemLeft" align="right" valign="top"><a id="ab6ea335622f18386671194eb6bd6a41b"></a>
SIMD_FORCE_INLINE <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:ab6ea335622f18386671194eb6bd6a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91d1383db8069a02d23caf915bc2ce3"><td class="memItemLeft" align="right" valign="top"><a id="ae91d1383db8069a02d23caf915bc2ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#ae91d1383db8069a02d23caf915bc2ce3">btAlignedObjectArray</a> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a> &amp;otherArray)</td></tr>
<tr class="memdesc:ae91d1383db8069a02d23caf915bc2ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generally it is best to avoid using the copy constructor of an <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>, and use a (const) reference to the array instead. <br /></td></tr>
<tr class="separator:ae91d1383db8069a02d23caf915bc2ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de8d83d29c6edd1493fc583091194c"><td class="memItemLeft" align="right" valign="top"><a id="a31de8d83d29c6edd1493fc583091194c"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a> () const</td></tr>
<tr class="memdesc:a31de8d83d29c6edd1493fc583091194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the array <br /></td></tr>
<tr class="separator:a31de8d83d29c6edd1493fc583091194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ccc5e9cd7412de584785d219bafff6"><td class="memItemLeft" align="right" valign="top"><a id="a26ccc5e9cd7412de584785d219bafff6"></a>
SIMD_FORCE_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int n) const</td></tr>
<tr class="separator:a26ccc5e9cd7412de584785d219bafff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792644f8e758fae5b4613fbcd1fd30f"><td class="memItemLeft" align="right" valign="top"><a id="a3792644f8e758fae5b4613fbcd1fd30f"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int n)</td></tr>
<tr class="separator:a3792644f8e758fae5b4613fbcd1fd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eda69c4274d87170a6bd2d9ea97054"><td class="memItemLeft" align="right" valign="top"><a id="a20eda69c4274d87170a6bd2d9ea97054"></a>
SIMD_FORCE_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int n) const</td></tr>
<tr class="separator:a20eda69c4274d87170a6bd2d9ea97054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29680dc26edbd4691d7b6a43d5a60840"><td class="memItemLeft" align="right" valign="top"><a id="a29680dc26edbd4691d7b6a43d5a60840"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int n)</td></tr>
<tr class="separator:a29680dc26edbd4691d7b6a43d5a60840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12123db01dda7758f0df5e3bba10cc0a"><td class="memItemLeft" align="right" valign="top"><a id="a12123db01dda7758f0df5e3bba10cc0a"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a12123db01dda7758f0df5e3bba10cc0a">clear</a> ()</td></tr>
<tr class="memdesc:a12123db01dda7758f0df5e3bba10cc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations. <br /></td></tr>
<tr class="separator:a12123db01dda7758f0df5e3bba10cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6169be905e03b84ea3bc8d8f7c7fc39d"><td class="memItemLeft" align="right" valign="top"><a id="a6169be905e03b84ea3bc8d8f7c7fc39d"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a6169be905e03b84ea3bc8d8f7c7fc39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc58c74534181a7a10e5c6ab8b21227"><td class="memItemLeft" align="right" valign="top">SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a2cc58c74534181a7a10e5c6ab8b21227">resizeNoInitialize</a> (int newsize)</td></tr>
<tr class="separator:a2cc58c74534181a7a10e5c6ab8b21227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48cd9cb91d0cfa50ee1c70ef485190"><td class="memItemLeft" align="right" valign="top"><a id="a6a48cd9cb91d0cfa50ee1c70ef485190"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int newsize, const T &amp;fillData=T())</td></tr>
<tr class="separator:a6a48cd9cb91d0cfa50ee1c70ef485190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f99f070780c42619386fd2a4336bec"><td class="memItemLeft" align="right" valign="top"><a id="ad1f99f070780c42619386fd2a4336bec"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>expandNonInitializing</b> ()</td></tr>
<tr class="separator:ad1f99f070780c42619386fd2a4336bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64affb4ed3f9db81f832cbac6b62527"><td class="memItemLeft" align="right" valign="top"><a id="ad64affb4ed3f9db81f832cbac6b62527"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>expand</b> (const T &amp;fillValue=T())</td></tr>
<tr class="separator:ad64affb4ed3f9db81f832cbac6b62527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e10166e2c00f487095d3482b9edd1"><td class="memItemLeft" align="right" valign="top"><a id="ad61e10166e2c00f487095d3482b9edd1"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;_Val)</td></tr>
<tr class="separator:ad61e10166e2c00f487095d3482b9edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baf76f9f52df3c2d742194ba33e8788"><td class="memItemLeft" align="right" valign="top"><a id="a1baf76f9f52df3c2d742194ba33e8788"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a1baf76f9f52df3c2d742194ba33e8788">capacity</a> () const</td></tr>
<tr class="memdesc:a1baf76f9f52df3c2d742194ba33e8788"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c" title="return the number of elements in the array ">size()</a> and reserve() <br /></td></tr>
<tr class="separator:a1baf76f9f52df3c2d742194ba33e8788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcdc850355c6742c66d50b16b102d9d"><td class="memItemLeft" align="right" valign="top"><a id="a0bcdc850355c6742c66d50b16b102d9d"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (int _Count)</td></tr>
<tr class="separator:a0bcdc850355c6742c66d50b16b102d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02193777d3644c1202bd430cd47ec3"><td class="memTemplParams" colspan="2"><a id="afd02193777d3644c1202bd430cd47ec3"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:afd02193777d3644c1202bd430cd47ec3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickSortInternal</b> (const L &amp;CompareFunc, int lo, int hi)</td></tr>
<tr class="separator:afd02193777d3644c1202bd430cd47ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memTemplParams" colspan="2"><a id="a96e9890d9c406d43b53b0e5ff0723b2f"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickSort</b> (const L &amp;CompareFunc)</td></tr>
<tr class="separator:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af763a60de2f11089bb10ebff2c062642"><td class="memTemplParams" colspan="2"><a id="af763a60de2f11089bb10ebff2c062642"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:af763a60de2f11089bb10ebff2c062642"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#af763a60de2f11089bb10ebff2c062642">downHeap</a> (T *pArr, int k, int n, const L &amp;CompareFunc)</td></tr>
<tr class="memdesc:af763a60de2f11089bb10ebff2c062642"><td class="mdescLeft">&#160;</td><td class="mdescRight">heap sort from <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/">http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/</a> <br /></td></tr>
<tr class="separator:af763a60de2f11089bb10ebff2c062642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeacaa461686c9394aabd3c139179b4"><td class="memItemLeft" align="right" valign="top"><a id="a4aeacaa461686c9394aabd3c139179b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (int index0, int index1)</td></tr>
<tr class="separator:a4aeacaa461686c9394aabd3c139179b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memTemplParams" colspan="2"><a id="aa0979d77c9b1e397d656a0b1ef88b4e6"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>heapSort</b> (const L &amp;CompareFunc)</td></tr>
<tr class="separator:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="memItemLeft" align="right" valign="top"><a id="ac63dc886b2cb46a2e1084b0d9d0dbdb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#ac63dc886b2cb46a2e1084b0d9d0dbdb3">findBinarySearch</a> (const T &amp;key) const</td></tr>
<tr class="memdesc:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-recursive binary search, assumes sorted array <br /></td></tr>
<tr class="separator:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643f69d951072a370493392f9d13e5b"><td class="memItemLeft" align="right" valign="top"><a id="a2643f69d951072a370493392f9d13e5b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>findLinearSearch</b> (const T &amp;key) const</td></tr>
<tr class="separator:a2643f69d951072a370493392f9d13e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6782242f06df5bab0cffbd23195cd9cd"><td class="memItemLeft" align="right" valign="top"><a id="a6782242f06df5bab0cffbd23195cd9cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (const T &amp;key)</td></tr>
<tr class="separator:a6782242f06df5bab0cffbd23195cd9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d21bd5fe47cfe0216990b78fef665e"><td class="memItemLeft" align="right" valign="top"><a id="aa8d21bd5fe47cfe0216990b78fef665e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initializeFromBuffer</b> (void *buffer, int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>, int <a class="el" href="classbtAlignedObjectArray.html#a1baf76f9f52df3c2d742194ba33e8788">capacity</a>)</td></tr>
<tr class="separator:aa8d21bd5fe47cfe0216990b78fef665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1464bd66b0e5e3880b4c7aa4a2ce13a1"><td class="memItemLeft" align="right" valign="top"><a id="a1464bd66b0e5e3880b4c7aa4a2ce13a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyFromArray</b> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a> &amp;otherArray)</td></tr>
<tr class="separator:a1464bd66b0e5e3880b4c7aa4a2ce13a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ea335622f18386671194eb6bd6a41b"><td class="memItemLeft" align="right" valign="top"><a id="ab6ea335622f18386671194eb6bd6a41b"></a>
SIMD_FORCE_INLINE <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:ab6ea335622f18386671194eb6bd6a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91d1383db8069a02d23caf915bc2ce3"><td class="memItemLeft" align="right" valign="top"><a id="ae91d1383db8069a02d23caf915bc2ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#ae91d1383db8069a02d23caf915bc2ce3">btAlignedObjectArray</a> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a> &amp;otherArray)</td></tr>
<tr class="memdesc:ae91d1383db8069a02d23caf915bc2ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generally it is best to avoid using the copy constructor of an <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>, and use a (const) reference to the array instead. <br /></td></tr>
<tr class="separator:ae91d1383db8069a02d23caf915bc2ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de8d83d29c6edd1493fc583091194c"><td class="memItemLeft" align="right" valign="top"><a id="a31de8d83d29c6edd1493fc583091194c"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a> () const</td></tr>
<tr class="memdesc:a31de8d83d29c6edd1493fc583091194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the array <br /></td></tr>
<tr class="separator:a31de8d83d29c6edd1493fc583091194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ccc5e9cd7412de584785d219bafff6"><td class="memItemLeft" align="right" valign="top"><a id="a26ccc5e9cd7412de584785d219bafff6"></a>
SIMD_FORCE_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int n) const</td></tr>
<tr class="separator:a26ccc5e9cd7412de584785d219bafff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792644f8e758fae5b4613fbcd1fd30f"><td class="memItemLeft" align="right" valign="top"><a id="a3792644f8e758fae5b4613fbcd1fd30f"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int n)</td></tr>
<tr class="separator:a3792644f8e758fae5b4613fbcd1fd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eda69c4274d87170a6bd2d9ea97054"><td class="memItemLeft" align="right" valign="top"><a id="a20eda69c4274d87170a6bd2d9ea97054"></a>
SIMD_FORCE_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int n) const</td></tr>
<tr class="separator:a20eda69c4274d87170a6bd2d9ea97054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29680dc26edbd4691d7b6a43d5a60840"><td class="memItemLeft" align="right" valign="top"><a id="a29680dc26edbd4691d7b6a43d5a60840"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int n)</td></tr>
<tr class="separator:a29680dc26edbd4691d7b6a43d5a60840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12123db01dda7758f0df5e3bba10cc0a"><td class="memItemLeft" align="right" valign="top"><a id="a12123db01dda7758f0df5e3bba10cc0a"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a12123db01dda7758f0df5e3bba10cc0a">clear</a> ()</td></tr>
<tr class="memdesc:a12123db01dda7758f0df5e3bba10cc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations. <br /></td></tr>
<tr class="separator:a12123db01dda7758f0df5e3bba10cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6169be905e03b84ea3bc8d8f7c7fc39d"><td class="memItemLeft" align="right" valign="top"><a id="a6169be905e03b84ea3bc8d8f7c7fc39d"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a6169be905e03b84ea3bc8d8f7c7fc39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc58c74534181a7a10e5c6ab8b21227"><td class="memItemLeft" align="right" valign="top">SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a2cc58c74534181a7a10e5c6ab8b21227">resizeNoInitialize</a> (int newsize)</td></tr>
<tr class="separator:a2cc58c74534181a7a10e5c6ab8b21227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48cd9cb91d0cfa50ee1c70ef485190"><td class="memItemLeft" align="right" valign="top"><a id="a6a48cd9cb91d0cfa50ee1c70ef485190"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int newsize, const T &amp;fillData=T())</td></tr>
<tr class="separator:a6a48cd9cb91d0cfa50ee1c70ef485190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f99f070780c42619386fd2a4336bec"><td class="memItemLeft" align="right" valign="top"><a id="ad1f99f070780c42619386fd2a4336bec"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>expandNonInitializing</b> ()</td></tr>
<tr class="separator:ad1f99f070780c42619386fd2a4336bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64affb4ed3f9db81f832cbac6b62527"><td class="memItemLeft" align="right" valign="top"><a id="ad64affb4ed3f9db81f832cbac6b62527"></a>
SIMD_FORCE_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>expand</b> (const T &amp;fillValue=T())</td></tr>
<tr class="separator:ad64affb4ed3f9db81f832cbac6b62527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e10166e2c00f487095d3482b9edd1"><td class="memItemLeft" align="right" valign="top"><a id="ad61e10166e2c00f487095d3482b9edd1"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;_Val)</td></tr>
<tr class="separator:ad61e10166e2c00f487095d3482b9edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baf76f9f52df3c2d742194ba33e8788"><td class="memItemLeft" align="right" valign="top"><a id="a1baf76f9f52df3c2d742194ba33e8788"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#a1baf76f9f52df3c2d742194ba33e8788">capacity</a> () const</td></tr>
<tr class="memdesc:a1baf76f9f52df3c2d742194ba33e8788"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c" title="return the number of elements in the array ">size()</a> and reserve() <br /></td></tr>
<tr class="separator:a1baf76f9f52df3c2d742194ba33e8788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcdc850355c6742c66d50b16b102d9d"><td class="memItemLeft" align="right" valign="top"><a id="a0bcdc850355c6742c66d50b16b102d9d"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (int _Count)</td></tr>
<tr class="separator:a0bcdc850355c6742c66d50b16b102d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02193777d3644c1202bd430cd47ec3"><td class="memTemplParams" colspan="2"><a id="afd02193777d3644c1202bd430cd47ec3"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:afd02193777d3644c1202bd430cd47ec3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickSortInternal</b> (const L &amp;CompareFunc, int lo, int hi)</td></tr>
<tr class="separator:afd02193777d3644c1202bd430cd47ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memTemplParams" colspan="2"><a id="a96e9890d9c406d43b53b0e5ff0723b2f"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickSort</b> (const L &amp;CompareFunc)</td></tr>
<tr class="separator:a96e9890d9c406d43b53b0e5ff0723b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af763a60de2f11089bb10ebff2c062642"><td class="memTemplParams" colspan="2"><a id="af763a60de2f11089bb10ebff2c062642"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:af763a60de2f11089bb10ebff2c062642"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#af763a60de2f11089bb10ebff2c062642">downHeap</a> (T *pArr, int k, int n, const L &amp;CompareFunc)</td></tr>
<tr class="memdesc:af763a60de2f11089bb10ebff2c062642"><td class="mdescLeft">&#160;</td><td class="mdescRight">heap sort from <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/">http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/</a> <br /></td></tr>
<tr class="separator:af763a60de2f11089bb10ebff2c062642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeacaa461686c9394aabd3c139179b4"><td class="memItemLeft" align="right" valign="top"><a id="a4aeacaa461686c9394aabd3c139179b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (int index0, int index1)</td></tr>
<tr class="separator:a4aeacaa461686c9394aabd3c139179b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memTemplParams" colspan="2"><a id="aa0979d77c9b1e397d656a0b1ef88b4e6"></a>
template&lt;typename L &gt; </td></tr>
<tr class="memitem:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>heapSort</b> (const L &amp;CompareFunc)</td></tr>
<tr class="separator:aa0979d77c9b1e397d656a0b1ef88b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="memItemLeft" align="right" valign="top"><a id="ac63dc886b2cb46a2e1084b0d9d0dbdb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtAlignedObjectArray.html#ac63dc886b2cb46a2e1084b0d9d0dbdb3">findBinarySearch</a> (const T &amp;key) const</td></tr>
<tr class="memdesc:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-recursive binary search, assumes sorted array <br /></td></tr>
<tr class="separator:ac63dc886b2cb46a2e1084b0d9d0dbdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643f69d951072a370493392f9d13e5b"><td class="memItemLeft" align="right" valign="top"><a id="a2643f69d951072a370493392f9d13e5b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>findLinearSearch</b> (const T &amp;key) const</td></tr>
<tr class="separator:a2643f69d951072a370493392f9d13e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6782242f06df5bab0cffbd23195cd9cd"><td class="memItemLeft" align="right" valign="top"><a id="a6782242f06df5bab0cffbd23195cd9cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (const T &amp;key)</td></tr>
<tr class="separator:a6782242f06df5bab0cffbd23195cd9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d21bd5fe47cfe0216990b78fef665e"><td class="memItemLeft" align="right" valign="top"><a id="aa8d21bd5fe47cfe0216990b78fef665e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initializeFromBuffer</b> (void *buffer, int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>, int <a class="el" href="classbtAlignedObjectArray.html#a1baf76f9f52df3c2d742194ba33e8788">capacity</a>)</td></tr>
<tr class="separator:aa8d21bd5fe47cfe0216990b78fef665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1464bd66b0e5e3880b4c7aa4a2ce13a1"><td class="memItemLeft" align="right" valign="top"><a id="a1464bd66b0e5e3880b4c7aa4a2ce13a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyFromArray</b> (const <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a> &amp;otherArray)</td></tr>
<tr class="separator:a1464bd66b0e5e3880b4c7aa4a2ce13a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aedd4d8b9a38019cb1f98f794a6bb503d"><td class="memItemLeft" align="right" valign="top"><a id="aedd4d8b9a38019cb1f98f794a6bb503d"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>allocSize</b> (int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>)</td></tr>
<tr class="separator:aedd4d8b9a38019cb1f98f794a6bb503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd4754717ca52e5def692d42e5274c5"><td class="memItemLeft" align="right" valign="top"><a id="aebd4754717ca52e5def692d42e5274c5"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (int start, int end, T *dest) const</td></tr>
<tr class="separator:aebd4754717ca52e5def692d42e5274c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336631607f9f5f08001866ed11b5fd64"><td class="memItemLeft" align="right" valign="top"><a id="a336631607f9f5f08001866ed11b5fd64"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:a336631607f9f5f08001866ed11b5fd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc404237b049258d12fb2ca62b934f7"><td class="memItemLeft" align="right" valign="top"><a id="a6dc404237b049258d12fb2ca62b934f7"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (int first, int last)</td></tr>
<tr class="separator:a6dc404237b049258d12fb2ca62b934f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8943d09db3d72365b8c3ac6046225858"><td class="memItemLeft" align="right" valign="top"><a id="a8943d09db3d72365b8c3ac6046225858"></a>
SIMD_FORCE_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>)</td></tr>
<tr class="separator:a8943d09db3d72365b8c3ac6046225858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebca91940aecdb1c11718bc08b511c9"><td class="memItemLeft" align="right" valign="top"><a id="acebca91940aecdb1c11718bc08b511c9"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate</b> ()</td></tr>
<tr class="separator:acebca91940aecdb1c11718bc08b511c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd4d8b9a38019cb1f98f794a6bb503d"><td class="memItemLeft" align="right" valign="top"><a id="aedd4d8b9a38019cb1f98f794a6bb503d"></a>
SIMD_FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>allocSize</b> (int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>)</td></tr>
<tr class="separator:aedd4d8b9a38019cb1f98f794a6bb503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd4754717ca52e5def692d42e5274c5"><td class="memItemLeft" align="right" valign="top"><a id="aebd4754717ca52e5def692d42e5274c5"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (int start, int end, T *dest) const</td></tr>
<tr class="separator:aebd4754717ca52e5def692d42e5274c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336631607f9f5f08001866ed11b5fd64"><td class="memItemLeft" align="right" valign="top"><a id="a336631607f9f5f08001866ed11b5fd64"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:a336631607f9f5f08001866ed11b5fd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc404237b049258d12fb2ca62b934f7"><td class="memItemLeft" align="right" valign="top"><a id="a6dc404237b049258d12fb2ca62b934f7"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (int first, int last)</td></tr>
<tr class="separator:a6dc404237b049258d12fb2ca62b934f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8943d09db3d72365b8c3ac6046225858"><td class="memItemLeft" align="right" valign="top"><a id="a8943d09db3d72365b8c3ac6046225858"></a>
SIMD_FORCE_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (int <a class="el" href="classbtAlignedObjectArray.html#a31de8d83d29c6edd1493fc583091194c">size</a>)</td></tr>
<tr class="separator:a8943d09db3d72365b8c3ac6046225858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebca91940aecdb1c11718bc08b511c9"><td class="memItemLeft" align="right" valign="top"><a id="acebca91940aecdb1c11718bc08b511c9"></a>
SIMD_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate</b> ()</td></tr>
<tr class="separator:acebca91940aecdb1c11718bc08b511c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class btAlignedObjectArray&lt; T &gt;</h3>

<p>The <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a> template class uses a subset of the stl::vector interface for its methods It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2cc58c74534181a7a10e5c6ab8b21227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc58c74534181a7a10e5c6ab8b21227">&#9670;&nbsp;</a></span>resizeNoInitialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SIMD_FORCE_INLINE void <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt;::resizeNoInitialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument. when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations. </p>

</div>
</div>
<a id="a2cc58c74534181a7a10e5c6ab8b21227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc58c74534181a7a10e5c6ab8b21227">&#9670;&nbsp;</a></span>resizeNoInitialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SIMD_FORCE_INLINE void <a class="el" href="classbtAlignedObjectArray.html">btAlignedObjectArray</a>&lt; T &gt;::resizeNoInitialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument. when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/external/bullet/LinearMath/<a class="el" href="cocos2d_2external_2bullet_2LinearMath_2btAlignedObjectArray_8h_source.html">btAlignedObjectArray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
