<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: Built-in service loop entry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Built-in service loop entry</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5876f3c73bf201b250d041805b706"><td class="memItemLeft" align="right" valign="top"><a id="ga6ea5876f3c73bf201b250d041805b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_plat_service_tsi</b>&#160;&#160;&#160;<a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a></td></tr>
<tr class="separator:ga6ea5876f3c73bf201b250d041805b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf95bd0c663d6516a0c80047d9b1167a8"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, int timeout_ms)</td></tr>
<tr class="separator:gaf95bd0c663d6516a0c80047d9b1167a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3cc4473fd8848e5bbee7f310712939"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, int timeout_ms, int tsi)</td></tr>
<tr class="separator:ga9b3cc4473fd8848e5bbee7f310712939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c246707997ab7a466aa709aecd2d7b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#ga29c246707997ab7a466aa709aecd2d7b">lws_cancel_service_pt</a> (struct <a class="el" href="structlws.html">lws</a> *wsi)</td></tr>
<tr class="separator:ga29c246707997ab7a466aa709aecd2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e3d0801dfda7960a7249dd559e68a2"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#ga53e3d0801dfda7960a7249dd559e68a2">lws_cancel_service</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context)</td></tr>
<tr class="separator:ga53e3d0801dfda7960a7249dd559e68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82efa5466d14a9f05aa06416375b28d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, struct lws_pollfd *pollfd)</td></tr>
<tr class="separator:gad82efa5466d14a9f05aa06416375b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf426eda371ba23642fc11d8e0ace6b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#gaebf426eda371ba23642fc11d8e0ace6b">lws_service_fd_tsi</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, struct lws_pollfd *pollfd, int tsi)</td></tr>
<tr class="separator:gaebf426eda371ba23642fc11d8e0ace6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd9d714434ca499e2b3f7dbba86f241"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#ga4fd9d714434ca499e2b3f7dbba86f241">lws_service_adjust_timeout</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, int timeout_ms, int tsi)</td></tr>
<tr class="separator:ga4fd9d714434ca499e2b3f7dbba86f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14937ff6dd3e2b0104c2fe60c0a41e46"><td class="memItemLeft" align="right" valign="top"><a id="ga14937ff6dd3e2b0104c2fe60c0a41e46"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_handle_POLLOUT_event</b> (struct <a class="el" href="structlws.html">lws</a> *wsi, struct lws_pollfd *pollfd)</td></tr>
<tr class="separator:ga14937ff6dd3e2b0104c2fe60c0a41e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ff2c19455268fa0d5b617d8057fbfc"><td class="memItemLeft" align="right" valign="top">LWS_EXTERN LWS_VISIBLE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__service.html#gab1ff2c19455268fa0d5b617d8057fbfc">lws_plat_service_tsi</a> (struct <a class="el" href="structlws__context.html">lws_context</a> *context, int timeout_ms, int tsi)</td></tr>
<tr class="separator:gab1ff2c19455268fa0d5b617d8057fbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lws_client_http_body_pending() - control if client connection neeeds to send body</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>client connection </td></tr>
    <tr><td class="paramname">something_left_to_send</td><td>nonzero if need to send more body, 0 (default) if nothing more to send</td></tr>
  </table>
  </dd>
</dl>
<p>If you will send payload data with your HTTP client connection, eg, for POST, when you set the related http headers in LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER callback you should also call this API with something_left_to_send nonzero, and call lws_callback_on_writable(wsi);</p>
<p>After sending the headers, lws will call your callback with LWS_CALLBACK_CLIENT_HTTP_WRITEABLE reason when writable. You can send the next part of the http body payload, calling lws_callback_on_writable(wsi); if there is more to come, or lws_client_http_body_pending(wsi, 0); to let lws know the last part is sent and the connection can move on.</p>
<h2>Built-in service loop entry</h2>
<p>If you're not using libev / libuv, these apis are needed to enter the poll() wait in lws and service any connections with pending events. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga53e3d0801dfda7960a7249dd559e68a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e3d0801dfda7960a7249dd559e68a2">&#9670;&nbsp;</a></span>lws_cancel_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_cancel_service </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#ga53e3d0801dfda7960a7249dd559e68a2">lws_cancel_service()</a> - Cancel wait for new pending socket activity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context</td></tr>
  </table>
  </dd>
</dl>
<p>This function let a call to <a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a> waiting for a timeout immediately return.</p>
<p>What it basically does is provide a fake event that will be swallowed, so the wait in poll() is ended. That's useful because poll() doesn't attend to changes in POLLIN/OUT/ERR until it re-enters the wait. </p>

</div>
</div>
<a id="ga29c246707997ab7a466aa709aecd2d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c246707997ab7a466aa709aecd2d7b">&#9670;&nbsp;</a></span>lws_cancel_service_pt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_cancel_service_pt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws.html">lws</a> *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#ga29c246707997ab7a466aa709aecd2d7b">lws_cancel_service_pt()</a> - Cancel servicing of pending socket activity on one thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Cancel service on the thread this wsi is serviced by</td></tr>
  </table>
  </dd>
</dl>
<p>This function lets a call to <a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a> waiting for a timeout immediately return.</p>
<p>It works by creating a phony event and then swallowing it silently.</p>
<p>The reason it may be needed is when waiting in poll(), changes to the event masks are ignored by the OS until poll() is reentered. This lets you halt the poll() wait and make the reentry happen immediately instead of having the wait out the rest of the poll timeout. </p>

</div>
</div>
<a id="gab1ff2c19455268fa0d5b617d8057fbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ff2c19455268fa0d5b617d8057fbfc">&#9670;&nbsp;</a></span>lws_plat_service_tsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_EXTERN LWS_VISIBLE int lws_plat_service_tsi </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#gab1ff2c19455268fa0d5b617d8057fbfc">lws_plat_service_tsi()</a> - Lowlevel platform-specific service api </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The original poll timeout value. You can just set this to 1 if you don't really have a poll timeout. </td></tr>
    <tr><td class="paramname">tsi</td><td>thread service index</td></tr>
  </table>
  </dd>
</dl>
<p>For default poll() and libuv/ev, lws takes care of using this for you. and you can ignore it.</p>
<p>But for external poll() integration, you need access to this api to service connections that need to be serviced but have no pending network activity.</p>
<p>See <a class="el" href="group__service.html#ga4fd9d714434ca499e2b3f7dbba86f241">lws_service_adjust_timeout()</a> for more info. </p>

</div>
</div>
<a id="gaf95bd0c663d6516a0c80047d9b1167a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95bd0c663d6516a0c80047d9b1167a8">&#9670;&nbsp;</a></span>lws_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a> - Service any pending websocket activity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout for poll; 0 means return immediately if nothing needed service otherwise block and service immediately, returning after the timeout if nothing needed service.</td></tr>
  </table>
  </dd>
</dl>
<p>This function deals with any pending websocket traffic, for three kinds of event. It handles these events on both server and client types of connection the same.</p>
<p>1) Accept new connections to our context's server</p>
<p>2) Call the receive callback for incoming frame data received by server or client connections.</p>
<p>You need to call this service function periodically to all the above functions to happen; if your application is single-threaded you can just call it in your main event loop.</p>
<p>Alternatively you can fork a new process that asynchronously handles calling this service in a loop. In that case you are happy if this call blocks your thread until it needs to take care of something and would call it with a large nonzero timeout. Your loop then takes no CPU while there is nothing happening.</p>
<p>If you are calling it in a single-threaded app, you don't want it to wait around blocking other things in your loop from happening, so you would call it with a timeout_ms of 0, so it returns immediately if nothing is pending, or as soon as it services whatever was pending. </p>

</div>
</div>
<a id="ga4fd9d714434ca499e2b3f7dbba86f241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd9d714434ca499e2b3f7dbba86f241">&#9670;&nbsp;</a></span>lws_service_adjust_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service_adjust_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#ga4fd9d714434ca499e2b3f7dbba86f241">lws_service_adjust_timeout()</a> - Check for any connection needing forced service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The original poll timeout value. You can just set this to 1 if you don't really have a poll timeout. </td></tr>
    <tr><td class="paramname">tsi</td><td>thread service index</td></tr>
  </table>
  </dd>
</dl>
<p>Under some conditions connections may need service even though there is no pending network action on them, this is "forced service". For default poll() and libuv / libev, the library takes care of calling this and dealing with it for you. But for external poll() integration, you need access to the apis.</p>
<p>If anybody needs "forced service", returned timeout is zero. In that case, you can call <a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi()</a> with a timeout of -1 to only service guys who need forced service.</p>
<p><a class="el" href="group__service.html#ga4fd9d714434ca499e2b3f7dbba86f241">lws_service_adjust_timeout()</a> - Check for any connection needing forced service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The original poll timeout value. You can just set this to 1 if you don't really have a poll timeout. </td></tr>
    <tr><td class="paramname">tsi</td><td>thread service index</td></tr>
  </table>
  </dd>
</dl>
<p>Under some conditions connections may need service even though there is no pending network action on them, this is "forced service". For default poll() and libuv / libev, the library takes care of calling this and dealing with it for you. But for external poll() integration, you need access to the apis.</p>
<p>If anybody needs "forced service", returned timeout is zero. In that case, you can call <a class="el" href="group__service.html#gab1ff2c19455268fa0d5b617d8057fbfc">lws_plat_service_tsi()</a> with a timeout of -1 to only service guys who need forced service. </p>

</div>
</div>
<a id="gad82efa5466d14a9f05aa06416375b28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82efa5466d14a9f05aa06416375b28d">&#9670;&nbsp;</a></span>lws_service_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lws_pollfd *&#160;</td>
          <td class="paramname"><em>pollfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> - Service polled socket with something waiting </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">pollfd</td><td>The pollfd entry describing the socket fd and which events happened, or NULL to tell lws to do only timeout servicing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function takes a pollfd that has POLLIN or POLLOUT activity and services it according to the state of the associated struct lws.</p>
<p>The one call deals with all "service" that might happen on a socket including listen accepts, http files as well as websocket protocol.</p>
<p>If a pollfd says it has something, you can just pass it to <a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> whether it is a socket handled by lws or not. If it sees it is a lws socket, the traffic will be handled and pollfd-&gt;revents will be zeroed now.</p>
<p>If the socket is foreign to lws, it leaves revents alone. So you can see if you should service yourself by checking the pollfd revents after letting lws try to service it.</p>
<p>You should also call this with pollfd = NULL to just allow the once-per-second global timeout checks; if less than a second since the last check it returns immediately then.</p>
<p><a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> - Service polled socket with something waiting </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">pollfd</td><td>The pollfd entry describing the socket fd and which events happened.</td></tr>
  </table>
  </dd>
</dl>
<p>This function takes a pollfd that has POLLIN or POLLOUT activity and services it according to the state of the associated struct lws.</p>
<p>The one call deals with all "service" that might happen on a socket including listen accepts, http files as well as websocket protocol.</p>
<p>If a pollfd says it has something, you can just pass it to <a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> whether it is a socket handled by lws or not. If it sees it is a lws socket, the traffic will be handled and pollfd-&gt;revents will be zeroed now.</p>
<p>If the socket is foreign to lws, it leaves revents alone. So you can see if you should service yourself by checking the pollfd revents after letting lws try to service it. </p>

</div>
</div>
<a id="gaebf426eda371ba23642fc11d8e0ace6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebf426eda371ba23642fc11d8e0ace6b">&#9670;&nbsp;</a></span>lws_service_fd_tsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service_fd_tsi </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lws_pollfd *&#160;</td>
          <td class="paramname"><em>pollfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#gaebf426eda371ba23642fc11d8e0ace6b">lws_service_fd_tsi()</a> - Service polled socket in specific service thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">pollfd</td><td>The pollfd entry describing the socket fd and which events happened. </td></tr>
    <tr><td class="paramname">tsi</td><td>thread service index</td></tr>
  </table>
  </dd>
</dl>
<p>Same as <a class="el" href="group__service.html#gad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> but used with multiple service threads </p>

</div>
</div>
<a id="ga9b3cc4473fd8848e5bbee7f310712939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b3cc4473fd8848e5bbee7f310712939">&#9670;&nbsp;</a></span>lws_service_tsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service_tsi </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__context.html">lws_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__service.html#ga9b3cc4473fd8848e5bbee7f310712939">lws_service_tsi()</a> - Service any pending websocket activity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout for poll; 0 means return immediately if nothing needed service otherwise block and service immediately, returning after the timeout if nothing needed service. </td></tr>
    <tr><td class="paramname">tsi</td><td>Thread service index, starting at 0</td></tr>
  </table>
  </dd>
</dl>
<p>Same as <a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a>, but for a specific thread service index. Only needed if you are spawning multiple service threads.</p>
<p><a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a> - Service any pending websocket activity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout for poll; 0 means return immediately if nothing needed service otherwise block and service immediately, returning after the timeout if nothing needed service.</td></tr>
  </table>
  </dd>
</dl>
<p>Same as <a class="el" href="group__service.html#gaf95bd0c663d6516a0c80047d9b1167a8">lws_service()</a>, but for a specific thread service index. Only needed if you are spawning multiple service threads. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
