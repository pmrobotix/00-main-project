<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: cpArbiter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpArbiter</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpContactPointSet.html">cpContactPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that wraps up the important collision data for an arbiter.  <a href="structcpContactPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga47cf449fcf6338737bc070f29bd286b5"><td class="memItemLeft" align="right" valign="top"><a id="ga47cf449fcf6338737bc070f29bd286b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_MAX_CONTACTS_PER_ARBITER</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga47cf449fcf6338737bc070f29bd286b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cd3e6766178e14b1204774890518c7"><td class="memItemLeft" align="right" valign="top"><a id="gaf6cd3e6766178e14b1204774890518c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gaf6cd3e6766178e14b1204774890518c7">CP_ARBITER_GET_SHAPES</a>(__arb__,  __a__,  __b__)&#160;&#160;&#160;<a class="el" href="structcpShape.html">cpShape</a> *__a__, *__b__; <a class="el" href="group__cpArbiter.html#ga521ac495c53bf25ab061a79643bb195a">cpArbiterGetShapes</a>(__arb__, &amp;__a__, &amp;__b__);</td></tr>
<tr class="memdesc:gaf6cd3e6766178e14b1204774890518c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro shortcut for defining and retrieving the shapes from an arbiter. <br /></td></tr>
<tr class="separator:gaf6cd3e6766178e14b1204774890518c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="memItemLeft" align="right" valign="top"><a id="ga57ae85df3f77d0fb62fe5b5c77b3a28f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga57ae85df3f77d0fb62fe5b5c77b3a28f">CP_ARBITER_GET_BODIES</a>(__arb__,  __a__,  __b__)&#160;&#160;&#160;<a class="el" href="structcpBody.html">cpBody</a> *__a__, *__b__; <a class="el" href="group__cpArbiter.html#gac5371d101c55a8a9c5b471e12010a8b3">cpArbiterGetBodies</a>(__arb__, &amp;__a__, &amp;__b__);</td></tr>
<tr class="memdesc:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro shortcut for defining and retrieving the bodies from an arbiter. <br /></td></tr>
<tr class="separator:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cf449fcf6338737bc070f29bd286b5"><td class="memItemLeft" align="right" valign="top"><a id="ga47cf449fcf6338737bc070f29bd286b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_MAX_CONTACTS_PER_ARBITER</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga47cf449fcf6338737bc070f29bd286b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cd3e6766178e14b1204774890518c7"><td class="memItemLeft" align="right" valign="top"><a id="gaf6cd3e6766178e14b1204774890518c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gaf6cd3e6766178e14b1204774890518c7">CP_ARBITER_GET_SHAPES</a>(__arb__,  __a__,  __b__)&#160;&#160;&#160;<a class="el" href="structcpShape.html">cpShape</a> *__a__, *__b__; <a class="el" href="group__cpArbiter.html#ga521ac495c53bf25ab061a79643bb195a">cpArbiterGetShapes</a>(__arb__, &amp;__a__, &amp;__b__);</td></tr>
<tr class="memdesc:gaf6cd3e6766178e14b1204774890518c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro shortcut for defining and retrieving the shapes from an arbiter. <br /></td></tr>
<tr class="separator:gaf6cd3e6766178e14b1204774890518c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="memItemLeft" align="right" valign="top"><a id="ga57ae85df3f77d0fb62fe5b5c77b3a28f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga57ae85df3f77d0fb62fe5b5c77b3a28f">CP_ARBITER_GET_BODIES</a>(__arb__,  __a__,  __b__)&#160;&#160;&#160;<a class="el" href="structcpBody.html">cpBody</a> *__a__, *__b__; <a class="el" href="group__cpArbiter.html#gac5371d101c55a8a9c5b471e12010a8b3">cpArbiterGetBodies</a>(__arb__, &amp;__a__, &amp;__b__);</td></tr>
<tr class="memdesc:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro shortcut for defining and retrieving the bodies from an arbiter. <br /></td></tr>
<tr class="separator:ga57ae85df3f77d0fb62fe5b5c77b3a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6c9e28294c87dc6a5777b0f0c24fda83"><td class="memItemLeft" align="right" valign="top"><a id="ga6c9e28294c87dc6a5777b0f0c24fda83"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga6c9e28294c87dc6a5777b0f0c24fda83">cpArbiterGetRestitution</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:ga6c9e28294c87dc6a5777b0f0c24fda83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the restitution (elasticity) that will be applied to the pair of colliding objects. <br /></td></tr>
<tr class="separator:ga6c9e28294c87dc6a5777b0f0c24fda83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa04fa347992f1e5903c89e480325ee"><td class="memItemLeft" align="right" valign="top"><a id="gaefa04fa347992f1e5903c89e480325ee"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gaefa04fa347992f1e5903c89e480325ee">cpArbiterSetRestitution</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, cpFloat restitution)</td></tr>
<tr class="memdesc:gaefa04fa347992f1e5903c89e480325ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the restitution (elasticity) that will be applied to the pair of colliding objects. <br /></td></tr>
<tr class="separator:gaefa04fa347992f1e5903c89e480325ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367b1ad68643be3f0a5f979ddf27b575"><td class="memItemLeft" align="right" valign="top"><a id="ga367b1ad68643be3f0a5f979ddf27b575"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga367b1ad68643be3f0a5f979ddf27b575">cpArbiterGetFriction</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:ga367b1ad68643be3f0a5f979ddf27b575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the friction coefficient that will be applied to the pair of colliding objects. <br /></td></tr>
<tr class="separator:ga367b1ad68643be3f0a5f979ddf27b575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab049136b2e62e92adfde8f6422664f71"><td class="memItemLeft" align="right" valign="top"><a id="gab049136b2e62e92adfde8f6422664f71"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gab049136b2e62e92adfde8f6422664f71">cpArbiterSetFriction</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, cpFloat friction)</td></tr>
<tr class="memdesc:gab049136b2e62e92adfde8f6422664f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the friction coefficient that will be applied to the pair of colliding objects. <br /></td></tr>
<tr class="separator:gab049136b2e62e92adfde8f6422664f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede8b70f4bb8e5f1e74eaffa210f3824"><td class="memItemLeft" align="right" valign="top"><a id="gaede8b70f4bb8e5f1e74eaffa210f3824"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cpArbiterGetSurfaceVelocity</b> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="separator:gaede8b70f4bb8e5f1e74eaffa210f3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e72c2b8ec0770a2cb2c8d423fce42b"><td class="memItemLeft" align="right" valign="top"><a id="ga71e72c2b8ec0770a2cb2c8d423fce42b"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpArbiterSetSurfaceVelocity</b> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpVect.html">cpVect</a> vr)</td></tr>
<tr class="separator:ga71e72c2b8ec0770a2cb2c8d423fce42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ebdb266ac42a9d10169374c233865d"><td class="memItemLeft" align="right" valign="top"><a id="ga97ebdb266ac42a9d10169374c233865d"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga97ebdb266ac42a9d10169374c233865d">cpArbiterGetUserData</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:ga97ebdb266ac42a9d10169374c233865d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user data pointer associated with this pair of colliding objects. <br /></td></tr>
<tr class="separator:ga97ebdb266ac42a9d10169374c233865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb92e7ea05fb11021ce3f01ff4baa067"><td class="memItemLeft" align="right" valign="top">CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gafb92e7ea05fb11021ce3f01ff4baa067">cpArbiterSetUserData</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:gafb92e7ea05fb11021ce3f01ff4baa067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dcf707be34b3ecddba4d61ff9d11415"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga7dcf707be34b3ecddba4d61ff9d11415">cpArbiterTotalImpulse</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="separator:ga7dcf707be34b3ecddba4d61ff9d11415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9918019bc0e4af5a2618e0ddeec4d64c"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga9918019bc0e4af5a2618e0ddeec4d64c">cpArbiterTotalKE</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="separator:ga9918019bc0e4af5a2618e0ddeec4d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a643cd465bdb61b2f686fdf3558b263"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga7a643cd465bdb61b2f686fdf3558b263">cpArbiterIgnore</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="separator:ga7a643cd465bdb61b2f686fdf3558b263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521ac495c53bf25ab061a79643bb195a"><td class="memItemLeft" align="right" valign="top">CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga521ac495c53bf25ab061a79643bb195a">cpArbiterGetShapes</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpShape.html">cpShape</a> **a, <a class="el" href="structcpShape.html">cpShape</a> **b)</td></tr>
<tr class="separator:ga521ac495c53bf25ab061a79643bb195a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5371d101c55a8a9c5b471e12010a8b3"><td class="memItemLeft" align="right" valign="top">CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gac5371d101c55a8a9c5b471e12010a8b3">cpArbiterGetBodies</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpBody.html">cpBody</a> **a, <a class="el" href="structcpBody.html">cpBody</a> **b)</td></tr>
<tr class="separator:gac5371d101c55a8a9c5b471e12010a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd7be89287b9955f650f3d9a01eae40"><td class="memItemLeft" align="right" valign="top"><a id="ga3bd7be89287b9955f650f3d9a01eae40"></a>
CP_EXPORT <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga3bd7be89287b9955f650f3d9a01eae40">cpArbiterGetContactPointSet</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:ga3bd7be89287b9955f650f3d9a01eae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a contact set from an arbiter. <br /></td></tr>
<tr class="separator:ga3bd7be89287b9955f650f3d9a01eae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a68f589f58dbae29de18cebee3de02d"><td class="memItemLeft" align="right" valign="top">CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga2a68f589f58dbae29de18cebee3de02d">cpArbiterSetContactPointSet</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a> *set)</td></tr>
<tr class="separator:ga2a68f589f58dbae29de18cebee3de02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd696398cfa9cfea7a9050119b4c9c4b"><td class="memItemLeft" align="right" valign="top"><a id="gabd696398cfa9cfea7a9050119b4c9c4b"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gabd696398cfa9cfea7a9050119b4c9c4b">cpArbiterIsFirstContact</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:gabd696398cfa9cfea7a9050119b4c9c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the first step a pair of objects started colliding. <br /></td></tr>
<tr class="separator:gabd696398cfa9cfea7a9050119b4c9c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e123894234c06d2aa1b06072803d99"><td class="memItemLeft" align="right" valign="top"><a id="gab8e123894234c06d2aa1b06072803d99"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gab8e123894234c06d2aa1b06072803d99">cpArbiterIsRemoval</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:gab8e123894234c06d2aa1b06072803d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the separate callback is due to a shape being removed from the space. <br /></td></tr>
<tr class="separator:gab8e123894234c06d2aa1b06072803d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166184f2b2ce68a734e380e702763404"><td class="memItemLeft" align="right" valign="top"><a id="ga166184f2b2ce68a734e380e702763404"></a>
CP_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga166184f2b2ce68a734e380e702763404">cpArbiterGetCount</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:ga166184f2b2ce68a734e380e702763404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of contact points for this arbiter. <br /></td></tr>
<tr class="separator:ga166184f2b2ce68a734e380e702763404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf433a0a6809f8366530adfb6538a1a1b"><td class="memItemLeft" align="right" valign="top"><a id="gaf433a0a6809f8366530adfb6538a1a1b"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gaf433a0a6809f8366530adfb6538a1a1b">cpArbiterGetNormal</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb)</td></tr>
<tr class="memdesc:gaf433a0a6809f8366530adfb6538a1a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal of the collision. <br /></td></tr>
<tr class="separator:gaf433a0a6809f8366530adfb6538a1a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c822e1157a0b5e3e95d3de5866f5af1"><td class="memItemLeft" align="right" valign="top"><a id="ga0c822e1157a0b5e3e95d3de5866f5af1"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga0c822e1157a0b5e3e95d3de5866f5af1">cpArbiterGetPointA</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, int i)</td></tr>
<tr class="memdesc:ga0c822e1157a0b5e3e95d3de5866f5af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the <code>ith</code> contact point on the surface of the first shape. <br /></td></tr>
<tr class="separator:ga0c822e1157a0b5e3e95d3de5866f5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f52d875b680592bc657c4ef4608a3c4"><td class="memItemLeft" align="right" valign="top"><a id="ga5f52d875b680592bc657c4ef4608a3c4"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga5f52d875b680592bc657c4ef4608a3c4">cpArbiterGetPointB</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, int i)</td></tr>
<tr class="memdesc:ga5f52d875b680592bc657c4ef4608a3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the <code>ith</code> contact point on the surface of the second shape. <br /></td></tr>
<tr class="separator:ga5f52d875b680592bc657c4ef4608a3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7946b026663db9e03cacefb655369cd8"><td class="memItemLeft" align="right" valign="top"><a id="ga7946b026663db9e03cacefb655369cd8"></a>
CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga7946b026663db9e03cacefb655369cd8">cpArbiterGetDepth</a> (const <a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, int i)</td></tr>
<tr class="memdesc:ga7946b026663db9e03cacefb655369cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of the <code>ith</code> contact point. <br /></td></tr>
<tr class="separator:ga7946b026663db9e03cacefb655369cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820d3549634a11d573eaa97923d59597"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga820d3549634a11d573eaa97923d59597">cpArbiterCallWildcardBeginA</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga820d3549634a11d573eaa97923d59597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a1ad2040728e877d72ff16868fcef"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga7a0a1ad2040728e877d72ff16868fcef">cpArbiterCallWildcardBeginB</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga7a0a1ad2040728e877d72ff16868fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e69fd89f304026f6f5248bc49fd6bba"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga3e69fd89f304026f6f5248bc49fd6bba">cpArbiterCallWildcardPreSolveA</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga3e69fd89f304026f6f5248bc49fd6bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61954fc86039826a56e504f483ebe8a6"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#ga61954fc86039826a56e504f483ebe8a6">cpArbiterCallWildcardPreSolveB</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga61954fc86039826a56e504f483ebe8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5cc72090ced7919e12768dcee35e046"><td class="memItemLeft" align="right" valign="top"><a id="gab5cc72090ced7919e12768dcee35e046"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gab5cc72090ced7919e12768dcee35e046">cpArbiterCallWildcardPostSolveA</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gab5cc72090ced7919e12768dcee35e046"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. <br /></td></tr>
<tr class="separator:gab5cc72090ced7919e12768dcee35e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32bdc2f19665e8eaff4323381a07ab3"><td class="memItemLeft" align="right" valign="top"><a id="gad32bdc2f19665e8eaff4323381a07ab3"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gad32bdc2f19665e8eaff4323381a07ab3">cpArbiterCallWildcardPostSolveB</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gad32bdc2f19665e8eaff4323381a07ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. <br /></td></tr>
<tr class="separator:gad32bdc2f19665e8eaff4323381a07ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49f69b06593a6fb3b50929bb6ba9cb7"><td class="memItemLeft" align="right" valign="top"><a id="gae49f69b06593a6fb3b50929bb6ba9cb7"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gae49f69b06593a6fb3b50929bb6ba9cb7">cpArbiterCallWildcardSeparateA</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gae49f69b06593a6fb3b50929bb6ba9cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. <br /></td></tr>
<tr class="separator:gae49f69b06593a6fb3b50929bb6ba9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf221f38af85d95f38ee9a15bcf15724a"><td class="memItemLeft" align="right" valign="top"><a id="gaf221f38af85d95f38ee9a15bcf15724a"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpArbiter.html#gaf221f38af85d95f38ee9a15bcf15724a">cpArbiterCallWildcardSeparateB</a> (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gaf221f38af85d95f38ee9a15bcf15724a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. <br /></td></tr>
<tr class="separator:gaf221f38af85d95f38ee9a15bcf15724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <a class="el" href="structcpArbiter.html">cpArbiter</a> struct tracks pairs of colliding shapes. They are also used in conjuction with collision handler callbacks allowing you to retrieve information on the collision or change it. A unique arbiter value is used for each pair of colliding objects. It persists until the shapes separate. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga820d3549634a11d573eaa97923d59597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga820d3549634a11d573eaa97923d59597">&#9670;&nbsp;</a></span>cpArbiterCallWildcardBeginA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpArbiterCallWildcardBeginA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. </p>

</div>
</div>
<a id="ga7a0a1ad2040728e877d72ff16868fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0a1ad2040728e877d72ff16868fcef">&#9670;&nbsp;</a></span>cpArbiterCallWildcardBeginB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpArbiterCallWildcardBeginB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. </p>

</div>
</div>
<a id="ga3e69fd89f304026f6f5248bc49fd6bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e69fd89f304026f6f5248bc49fd6bba">&#9670;&nbsp;</a></span>cpArbiterCallWildcardPreSolveA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpArbiterCallWildcardPreSolveA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. </p>

</div>
</div>
<a id="ga61954fc86039826a56e504f483ebe8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61954fc86039826a56e504f483ebe8a6">&#9670;&nbsp;</a></span>cpArbiterCallWildcardPreSolveB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpArbiterCallWildcardPreSolveB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. </p>

</div>
</div>
<a id="gac5371d101c55a8a9c5b471e12010a8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5371d101c55a8a9c5b471e12010a8b3">&#9670;&nbsp;</a></span>cpArbiterGetBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT void cpArbiterGetBodies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpBody.html">cpBody</a> **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpBody.html">cpBody</a> **&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the colliding bodies involved for this arbiter. The order of the cpSpace.collision_type the bodies are associated with values will match the order set when the collision handler was registered. </p>

</div>
</div>
<a id="ga521ac495c53bf25ab061a79643bb195a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga521ac495c53bf25ab061a79643bb195a">&#9670;&nbsp;</a></span>cpArbiterGetShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT void cpArbiterGetShapes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpShape.html">cpShape</a> **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpShape.html">cpShape</a> **&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the colliding shapes involved for this arbiter. The order of their cpSpace.collision_type values will match the order set when the collision handler was registered. </p>

</div>
</div>
<a id="ga7a643cd465bdb61b2f686fdf3558b263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a643cd465bdb61b2f686fdf3558b263">&#9670;&nbsp;</a></span>cpArbiterIgnore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpArbiterIgnore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a collision pair to be ignored until the two objects separate. Pre-solve and post-solve callbacks will not be called, but the separate callback will be called. </p>

</div>
</div>
<a id="ga2a68f589f58dbae29de18cebee3de02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a68f589f58dbae29de18cebee3de02d">&#9670;&nbsp;</a></span>cpArbiterSetContactPointSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT void cpArbiterSetContactPointSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpContactPointSet.html">cpContactPointSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the contact point set for an arbiter. This can be a very powerful feature, but use it with caution! </p>

</div>
</div>
<a id="gafb92e7ea05fb11021ce3f01ff4baa067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb92e7ea05fb11021ce3f01ff4baa067">&#9670;&nbsp;</a></span>cpArbiterSetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT void cpArbiterSetUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a>&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a user data point associated with this pair of colliding objects. If you need to perform any cleanup for this pointer, you must do it yourself, in the separate callback for instance. </p>

</div>
</div>
<a id="ga7dcf707be34b3ecddba4d61ff9d11415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dcf707be34b3ecddba4d61ff9d11415">&#9670;&nbsp;</a></span>cpArbiterTotalImpulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a> cpArbiterTotalImpulse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the total impulse including the friction that was applied by this arbiter. This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback. </p>

</div>
</div>
<a id="ga9918019bc0e4af5a2618e0ddeec4d64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9918019bc0e4af5a2618e0ddeec4d64c">&#9670;&nbsp;</a></span>cpArbiterTotalKE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpArbiterTotalKE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpArbiter.html">cpArbiter</a> *&#160;</td>
          <td class="paramname"><em>arb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the amount of energy lost in a collision including static, but not dynamic friction. This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
