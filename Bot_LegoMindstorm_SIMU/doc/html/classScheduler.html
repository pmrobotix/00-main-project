<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: Scheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classScheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scheduler Class Reference<div class="ingroups"><a class="el" href="group__base.html">Base</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> is responsible for triggering the scheduled callbacks. You should not use system timer for your game logic. Instead, use this class.  
 <a href="classScheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cocos2d_2cocos_2base_2CCScheduler_8h_source.html">CCScheduler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scheduler:</div>
<div class="dyncontent">
<div class="center"><img src="classScheduler__inherit__graph.png" border="0" usemap="#Scheduler_inherit__map" alt="Inheritance graph"/></div>
<map name="Scheduler_inherit__map" id="Scheduler_inherit__map">
<area shape="rect" id="node2" href="classRef.html" title="Ref" alt="" coords="24,5,67,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Scheduler:</div>
<div class="dyncontent">
<div class="center"><img src="classScheduler__coll__graph.png" border="0" usemap="#Scheduler_coll__map" alt="Collaboration graph"/></div>
<map name="Scheduler_coll__map" id="Scheduler_coll__map">
<area shape="rect" id="node2" href="classRef.html" title="Ref" alt="" coords="320,99,363,125"/>
<area shape="rect" id="node3" href="struct__hashSelectorEntry.html" title="_hashSelectorEntry" alt="" coords="5,99,141,125"/>
<area shape="rect" id="node4" href="structUT__hash__handle.html" title="UT_hash_handle" alt="" coords="543,7,663,33"/>
<area shape="rect" id="node5" href="structUT__hash__table.html" title="UT_hash_table" alt="" coords="657,219,767,245"/>
<area shape="rect" id="node6" href="structUT__hash__bucket.html" title="UT_hash_bucket" alt="" coords="542,99,663,125"/>
<area shape="rect" id="node8" href="struct__hashUpdateEntry.html" title="_hashUpdateEntry" alt="" coords="165,99,296,125"/>
<area shape="rect" id="node7" href="struct__listEntry.html" title="_listEntry" alt="" coords="387,99,464,125"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b61aac11466cd45ae42ab8c2b0013f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a3b61aac11466cd45ae42ab8c2b0013f6">Scheduler</a> ()</td></tr>
<tr class="separator:a3b61aac11466cd45ae42ab8c2b0013f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8187779b46f64039d3ffa58f0dbe51"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#afc8187779b46f64039d3ffa58f0dbe51">~Scheduler</a> ()</td></tr>
<tr class="separator:afc8187779b46f64039d3ffa58f0dbe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec13a52fa6a75450f17f122444069a9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a2ec13a52fa6a75450f17f122444069a9">getTimeScale</a> ()</td></tr>
<tr class="separator:a2ec13a52fa6a75450f17f122444069a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeaef587604d3a1f20ebac7a12b1d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a7aeaef587604d3a1f20ebac7a12b1d77">setTimeScale</a> (float timeScale)</td></tr>
<tr class="separator:a7aeaef587604d3a1f20ebac7a12b1d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533ad6047192a10444e2f4d386f3766a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a533ad6047192a10444e2f4d386f3766a">update</a> (float dt)</td></tr>
<tr class="separator:a533ad6047192a10444e2f4d386f3766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52145629a67e888cf1b25fd01f668b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, unsigned int repeat, float delay, bool paused, const std::string &amp;key)</td></tr>
<tr class="separator:a0d52145629a67e888cf1b25fd01f668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895a2f8f8eb3fc23b869cd1221660dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a895a2f8f8eb3fc23b869cd1221660dcd">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, bool paused, const std::string &amp;key)</td></tr>
<tr class="separator:a895a2f8f8eb3fc23b869cd1221660dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d34a2cf35f2af15f3377ee8b2e88a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5d34a2cf35f2af15f3377ee8b2e88a38">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, unsigned int repeat, float delay, bool paused)</td></tr>
<tr class="separator:a5d34a2cf35f2af15f3377ee8b2e88a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7946e2043d6e49f2a0a460740d8ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aef7946e2043d6e49f2a0a460740d8ae5">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, bool paused)</td></tr>
<tr class="separator:aef7946e2043d6e49f2a0a460740d8ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad566d55a4941459c185e6faeddc3a70f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad566d55a4941459c185e6faeddc3a70f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScheduler.html#ad566d55a4941459c185e6faeddc3a70f">scheduleUpdate</a> (T *target, int priority, bool paused)</td></tr>
<tr class="separator:ad566d55a4941459c185e6faeddc3a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca194b9ca146d9c522cc2c54a6d4ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a3ca194b9ca146d9c522cc2c54a6d4ede">unschedule</a> (const std::string &amp;key, void *target)</td></tr>
<tr class="separator:a3ca194b9ca146d9c522cc2c54a6d4ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d354b587d5f12df2e6094116fd65c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a6d354b587d5f12df2e6094116fd65c71">unschedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:a6d354b587d5f12df2e6094116fd65c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7bc87cc441a0f826c2a6758a9adcad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#acc7bc87cc441a0f826c2a6758a9adcad">unscheduleUpdate</a> (void *target)</td></tr>
<tr class="separator:acc7bc87cc441a0f826c2a6758a9adcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39199385fc1ab4f74c5665beaa2738b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a39199385fc1ab4f74c5665beaa2738b6">unscheduleAllForTarget</a> (void *target)</td></tr>
<tr class="separator:a39199385fc1ab4f74c5665beaa2738b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0746c417a3cf7c794d1ee32969994e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a0746c417a3cf7c794d1ee32969994e6a">unscheduleAll</a> ()</td></tr>
<tr class="separator:a0746c417a3cf7c794d1ee32969994e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa846e95ed320bdac9ca2c91a0d7e79db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aa846e95ed320bdac9ca2c91a0d7e79db">unscheduleAllWithMinPriority</a> (int minPriority)</td></tr>
<tr class="separator:aa846e95ed320bdac9ca2c91a0d7e79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b534eae62394806603e522ab4191d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5b534eae62394806603e522ab4191d3b">isScheduled</a> (const std::string &amp;key, void *target)</td></tr>
<tr class="separator:a5b534eae62394806603e522ab4191d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ed753a2875e2635b5120cee5c3e432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a95ed753a2875e2635b5120cee5c3e432">isScheduled</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:a95ed753a2875e2635b5120cee5c3e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409cb6f82cffd7d779154d9d813664af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a409cb6f82cffd7d779154d9d813664af">pauseTarget</a> (void *target)</td></tr>
<tr class="separator:a409cb6f82cffd7d779154d9d813664af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdab814dbc692356f813d335c3b92af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aebdab814dbc692356f813d335c3b92af">resumeTarget</a> (void *target)</td></tr>
<tr class="separator:aebdab814dbc692356f813d335c3b92af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef17d4d358516d712c32ac421202198c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aef17d4d358516d712c32ac421202198c">isTargetPaused</a> (void *target)</td></tr>
<tr class="separator:aef17d4d358516d712c32ac421202198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a624f0bf247439e11f45388dce5d465"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5a624f0bf247439e11f45388dce5d465">pauseAllTargets</a> ()</td></tr>
<tr class="separator:a5a624f0bf247439e11f45388dce5d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981921d200acdeedffa17c5e0c06f77"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ac981921d200acdeedffa17c5e0c06f77">pauseAllTargetsWithMinPriority</a> (int minPriority)</td></tr>
<tr class="separator:ac981921d200acdeedffa17c5e0c06f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b568bffe196f3a5cefe0739354dc900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5b568bffe196f3a5cefe0739354dc900">resumeTargets</a> (const std::set&lt; void *&gt; &amp;targetsToResume)</td></tr>
<tr class="separator:a5b568bffe196f3a5cefe0739354dc900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6da28a03a7f8b9df377f1e05e7883f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#acd6da28a03a7f8b9df377f1e05e7883f">performFunctionInCocosThread</a> (const std::function&lt; void()&gt; &amp;function)</td></tr>
<tr class="separator:acd6da28a03a7f8b9df377f1e05e7883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8df7fdf2f74a90cdb37bc334a550360"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ae8df7fdf2f74a90cdb37bc334a550360">scheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, unsigned int repeat, float delay, bool paused)</td></tr>
<tr class="separator:ae8df7fdf2f74a90cdb37bc334a550360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41f346fb140ff11ebc2b0736bc7b58a"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ab41f346fb140ff11ebc2b0736bc7b58a">scheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, bool paused)</td></tr>
<tr class="separator:ab41f346fb140ff11ebc2b0736bc7b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memTemplItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScheduler.html#a87a354dc2bcf3a750ed66f8d67ed0b70">scheduleUpdateForTarget</a> (T *target, int priority, bool paused)</td></tr>
<tr class="separator:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e540092eabffd80c97fe2af4faf7d5"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a25e540092eabffd80c97fe2af4faf7d5">unscheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:a25e540092eabffd80c97fe2af4faf7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdd2ece7f43eaca5662d12ae0b95a87"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a9cdd2ece7f43eaca5662d12ae0b95a87">isScheduledForTarget</a> (<a class="el" href="classRef.html">Ref</a> *target, SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a9cdd2ece7f43eaca5662d12ae0b95a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba32d69e94ebe72d58cbd661782ca6"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ac5ba32d69e94ebe72d58cbd661782ca6">unscheduleUpdateForTarget</a> (<a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:ac5ba32d69e94ebe72d58cbd661782ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b61aac11466cd45ae42ab8c2b0013f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a3b61aac11466cd45ae42ab8c2b0013f6">Scheduler</a> ()</td></tr>
<tr class="separator:a3b61aac11466cd45ae42ab8c2b0013f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900bd7768c2580dbc3a08c2873aa6086"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a900bd7768c2580dbc3a08c2873aa6086">~Scheduler</a> ()</td></tr>
<tr class="separator:a900bd7768c2580dbc3a08c2873aa6086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec13a52fa6a75450f17f122444069a9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a2ec13a52fa6a75450f17f122444069a9">getTimeScale</a> ()</td></tr>
<tr class="separator:a2ec13a52fa6a75450f17f122444069a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeaef587604d3a1f20ebac7a12b1d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a7aeaef587604d3a1f20ebac7a12b1d77">setTimeScale</a> (float timeScale)</td></tr>
<tr class="separator:a7aeaef587604d3a1f20ebac7a12b1d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533ad6047192a10444e2f4d386f3766a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a533ad6047192a10444e2f4d386f3766a">update</a> (float dt)</td></tr>
<tr class="separator:a533ad6047192a10444e2f4d386f3766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52145629a67e888cf1b25fd01f668b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, unsigned int repeat, float delay, bool paused, const std::string &amp;key)</td></tr>
<tr class="separator:a0d52145629a67e888cf1b25fd01f668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895a2f8f8eb3fc23b869cd1221660dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a895a2f8f8eb3fc23b869cd1221660dcd">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, bool paused, const std::string &amp;key)</td></tr>
<tr class="separator:a895a2f8f8eb3fc23b869cd1221660dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d34a2cf35f2af15f3377ee8b2e88a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5d34a2cf35f2af15f3377ee8b2e88a38">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, unsigned int repeat, float delay, bool paused)</td></tr>
<tr class="separator:a5d34a2cf35f2af15f3377ee8b2e88a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7946e2043d6e49f2a0a460740d8ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aef7946e2043d6e49f2a0a460740d8ae5">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, bool paused)</td></tr>
<tr class="separator:aef7946e2043d6e49f2a0a460740d8ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad566d55a4941459c185e6faeddc3a70f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad566d55a4941459c185e6faeddc3a70f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScheduler.html#ad566d55a4941459c185e6faeddc3a70f">scheduleUpdate</a> (T *target, int priority, bool paused)</td></tr>
<tr class="separator:ad566d55a4941459c185e6faeddc3a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca194b9ca146d9c522cc2c54a6d4ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a3ca194b9ca146d9c522cc2c54a6d4ede">unschedule</a> (const std::string &amp;key, void *target)</td></tr>
<tr class="separator:a3ca194b9ca146d9c522cc2c54a6d4ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d354b587d5f12df2e6094116fd65c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a6d354b587d5f12df2e6094116fd65c71">unschedule</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:a6d354b587d5f12df2e6094116fd65c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7bc87cc441a0f826c2a6758a9adcad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#acc7bc87cc441a0f826c2a6758a9adcad">unscheduleUpdate</a> (void *target)</td></tr>
<tr class="separator:acc7bc87cc441a0f826c2a6758a9adcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39199385fc1ab4f74c5665beaa2738b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a39199385fc1ab4f74c5665beaa2738b6">unscheduleAllForTarget</a> (void *target)</td></tr>
<tr class="separator:a39199385fc1ab4f74c5665beaa2738b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0746c417a3cf7c794d1ee32969994e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a0746c417a3cf7c794d1ee32969994e6a">unscheduleAll</a> ()</td></tr>
<tr class="separator:a0746c417a3cf7c794d1ee32969994e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa846e95ed320bdac9ca2c91a0d7e79db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aa846e95ed320bdac9ca2c91a0d7e79db">unscheduleAllWithMinPriority</a> (int minPriority)</td></tr>
<tr class="separator:aa846e95ed320bdac9ca2c91a0d7e79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e1ce8ec29f360c27d82d91028b23a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a57e1ce8ec29f360c27d82d91028b23a5">isScheduled</a> (const std::string &amp;key, const void *target) const</td></tr>
<tr class="separator:a57e1ce8ec29f360c27d82d91028b23a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43205eb0e74dd43834705a45e4fbdf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aa43205eb0e74dd43834705a45e4fbdf1">isScheduled</a> (SEL_SCHEDULE selector, const <a class="el" href="classRef.html">Ref</a> *target) const</td></tr>
<tr class="separator:aa43205eb0e74dd43834705a45e4fbdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409cb6f82cffd7d779154d9d813664af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a409cb6f82cffd7d779154d9d813664af">pauseTarget</a> (void *target)</td></tr>
<tr class="separator:a409cb6f82cffd7d779154d9d813664af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdab814dbc692356f813d335c3b92af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aebdab814dbc692356f813d335c3b92af">resumeTarget</a> (void *target)</td></tr>
<tr class="separator:aebdab814dbc692356f813d335c3b92af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef17d4d358516d712c32ac421202198c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aef17d4d358516d712c32ac421202198c">isTargetPaused</a> (void *target)</td></tr>
<tr class="separator:aef17d4d358516d712c32ac421202198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c551579277e1746f260d8397b4ac6ee"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a3c551579277e1746f260d8397b4ac6ee">pauseAllTargets</a> ()</td></tr>
<tr class="separator:a3c551579277e1746f260d8397b4ac6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306504d4f42cbe75cbe948b0d64d2750"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a306504d4f42cbe75cbe948b0d64d2750">pauseAllTargetsWithMinPriority</a> (int minPriority)</td></tr>
<tr class="separator:a306504d4f42cbe75cbe948b0d64d2750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b568bffe196f3a5cefe0739354dc900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a5b568bffe196f3a5cefe0739354dc900">resumeTargets</a> (const std::set&lt; void *&gt; &amp;targetsToResume)</td></tr>
<tr class="separator:a5b568bffe196f3a5cefe0739354dc900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dcb12852832912c43298288c03895f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a24dcb12852832912c43298288c03895f">performFunctionInCocosThread</a> (std::function&lt; void()&gt; function)</td></tr>
<tr class="separator:a24dcb12852832912c43298288c03895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8872d90ed82fdb19f93f9bd30e2837aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a8872d90ed82fdb19f93f9bd30e2837aa">removeAllFunctionsToBePerformedInCocosThread</a> ()</td></tr>
<tr class="separator:a8872d90ed82fdb19f93f9bd30e2837aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8df7fdf2f74a90cdb37bc334a550360"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ae8df7fdf2f74a90cdb37bc334a550360">scheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, unsigned int repeat, float delay, bool paused)</td></tr>
<tr class="separator:ae8df7fdf2f74a90cdb37bc334a550360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41f346fb140ff11ebc2b0736bc7b58a"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ab41f346fb140ff11ebc2b0736bc7b58a">scheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target, float interval, bool paused)</td></tr>
<tr class="separator:ab41f346fb140ff11ebc2b0736bc7b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memTemplItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScheduler.html#a87a354dc2bcf3a750ed66f8d67ed0b70">scheduleUpdateForTarget</a> (T *target, int priority, bool paused)</td></tr>
<tr class="separator:a87a354dc2bcf3a750ed66f8d67ed0b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e540092eabffd80c97fe2af4faf7d5"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a25e540092eabffd80c97fe2af4faf7d5">unscheduleSelector</a> (SEL_SCHEDULE selector, <a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:a25e540092eabffd80c97fe2af4faf7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdd2ece7f43eaca5662d12ae0b95a87"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a9cdd2ece7f43eaca5662d12ae0b95a87">isScheduledForTarget</a> (<a class="el" href="classRef.html">Ref</a> *target, SEL_SCHEDULE selector)</td></tr>
<tr class="separator:a9cdd2ece7f43eaca5662d12ae0b95a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba32d69e94ebe72d58cbd661782ca6"><td class="memItemLeft" align="right" valign="top">CC_DEPRECATED_ATTRIBUTE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ac5ba32d69e94ebe72d58cbd661782ca6">unscheduleUpdateForTarget</a> (<a class="el" href="classRef.html">Ref</a> *target)</td></tr>
<tr class="separator:ac5ba32d69e94ebe72d58cbd661782ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a065f6972ebb82de3e2143cbf10a7ac2d">autorelease</a> ()</td></tr>
<tr class="separator:a065f6972ebb82de3e2143cbf10a7ac2d inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a1c3c3986014151251b39041e2556d2e3">~Ref</a> ()</td></tr>
<tr class="separator:a1c3c3986014151251b39041e2556d2e3 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a7d182cae1be1e80a9884cacd6ff9cb01">retain</a> ()</td></tr>
<tr class="separator:a7d182cae1be1e80a9884cacd6ff9cb01 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a6c8528cd8731765688943496c2eb3907">release</a> ()</td></tr>
<tr class="separator:a6c8528cd8731765688943496c2eb3907 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRef.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a544b29e4e4b0c7fb32ccb6bf92d28da9">autorelease</a> ()</td></tr>
<tr class="separator:a544b29e4e4b0c7fb32ccb6bf92d28da9 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a27b894ccc4c74b0c52f3fa2993f04ba0">getReferenceCount</a> () const</td></tr>
<tr class="separator:a27b894ccc4c74b0c52f3fa2993f04ba0 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a97a445f43f3935f3ee6f34ebdec55d12">~Ref</a> ()</td></tr>
<tr class="separator:a97a445f43f3935f3ee6f34ebdec55d12 inherit pub_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab81137eee61d428046a59dd036a9bf33"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#ab81137eee61d428046a59dd036a9bf33">PRIORITY_SYSTEM</a> = INT_MIN</td></tr>
<tr class="separator:ab81137eee61d428046a59dd036a9bf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5f555d99f98484e7b7f46450089460"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#aff5f555d99f98484e7b7f46450089460">PRIORITY_NON_SYSTEM_MIN</a> = <a class="el" href="classScheduler.html#ab81137eee61d428046a59dd036a9bf33">PRIORITY_SYSTEM</a> + 1</td></tr>
<tr class="separator:aff5f555d99f98484e7b7f46450089460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9910c07a3c437d44478004a5c407834a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a9910c07a3c437d44478004a5c407834a">schedulePerFrame</a> (const ccSchedulerFunc &amp;callback, void *target, int priority, bool paused)</td></tr>
<tr class="separator:a9910c07a3c437d44478004a5c407834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d620448fd72d27c419ee44e9306534d"><td class="memItemLeft" align="right" valign="top"><a id="a0d620448fd72d27c419ee44e9306534d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeHashElement</b> (struct <a class="el" href="struct__hashSelectorEntry.html">_hashSelectorEntry</a> *element)</td></tr>
<tr class="separator:a0d620448fd72d27c419ee44e9306534d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737ffcc95536a8627da93228c55520b"><td class="memItemLeft" align="right" valign="top"><a id="a8737ffcc95536a8627da93228c55520b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeUpdateFromHash</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> *entry)</td></tr>
<tr class="separator:a8737ffcc95536a8627da93228c55520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a8ac12f4f63a635143e835d975d6f1"><td class="memItemLeft" align="right" valign="top"><a id="ac8a8ac12f4f63a635143e835d975d6f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>priorityIn</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> **<a class="el" href="protocollist-p.html">list</a>, const ccSchedulerFunc &amp;callback, void *target, int priority, bool paused)</td></tr>
<tr class="separator:ac8a8ac12f4f63a635143e835d975d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a45f15eee06968c40c59a4614797c2"><td class="memItemLeft" align="right" valign="top"><a id="af5a45f15eee06968c40c59a4614797c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendIn</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> **<a class="el" href="protocollist-p.html">list</a>, const ccSchedulerFunc &amp;callback, void *target, bool paused)</td></tr>
<tr class="separator:af5a45f15eee06968c40c59a4614797c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9910c07a3c437d44478004a5c407834a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScheduler.html#a9910c07a3c437d44478004a5c407834a">schedulePerFrame</a> (const ccSchedulerFunc &amp;callback, void *target, int priority, bool paused)</td></tr>
<tr class="separator:a9910c07a3c437d44478004a5c407834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d620448fd72d27c419ee44e9306534d"><td class="memItemLeft" align="right" valign="top"><a id="a0d620448fd72d27c419ee44e9306534d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeHashElement</b> (struct <a class="el" href="struct__hashSelectorEntry.html">_hashSelectorEntry</a> *element)</td></tr>
<tr class="separator:a0d620448fd72d27c419ee44e9306534d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737ffcc95536a8627da93228c55520b"><td class="memItemLeft" align="right" valign="top"><a id="a8737ffcc95536a8627da93228c55520b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeUpdateFromHash</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> *entry)</td></tr>
<tr class="separator:a8737ffcc95536a8627da93228c55520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a8ac12f4f63a635143e835d975d6f1"><td class="memItemLeft" align="right" valign="top"><a id="ac8a8ac12f4f63a635143e835d975d6f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>priorityIn</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> **<a class="el" href="protocollist-p.html">list</a>, const ccSchedulerFunc &amp;callback, void *target, int priority, bool paused)</td></tr>
<tr class="separator:ac8a8ac12f4f63a635143e835d975d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a45f15eee06968c40c59a4614797c2"><td class="memItemLeft" align="right" valign="top"><a id="af5a45f15eee06968c40c59a4614797c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendIn</b> (struct <a class="el" href="struct__listEntry.html">_listEntry</a> **<a class="el" href="protocollist-p.html">list</a>, const ccSchedulerFunc &amp;callback, void *target, bool paused)</td></tr>
<tr class="separator:af5a45f15eee06968c40c59a4614797c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab9cf238c39cc7fc6ffde82c8d94c465e">Ref</a> ()</td></tr>
<tr class="separator:ab9cf238c39cc7fc6ffde82c8d94c465e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#a63f1608b3c105a76e3d0ff1b77d2ae8e">Ref</a> ()</td></tr>
<tr class="separator:a63f1608b3c105a76e3d0ff1b77d2ae8e inherit pro_methods_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8dde95d0e29d1638cc3d121830a12b83"><td class="memItemLeft" align="right" valign="top"><a id="a8dde95d0e29d1638cc3d121830a12b83"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>_timeScale</b></td></tr>
<tr class="separator:a8dde95d0e29d1638cc3d121830a12b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8887ae5d78aba7c6254815b724ec2e0e"><td class="memItemLeft" align="right" valign="top"><a id="a8887ae5d78aba7c6254815b724ec2e0e"></a>
struct <a class="el" href="struct__listEntry.html">_listEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_updatesNegList</b></td></tr>
<tr class="separator:a8887ae5d78aba7c6254815b724ec2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6e922997d57ecd58ced1b467c65f52"><td class="memItemLeft" align="right" valign="top"><a id="a5f6e922997d57ecd58ced1b467c65f52"></a>
struct <a class="el" href="struct__listEntry.html">_listEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_updates0List</b></td></tr>
<tr class="separator:a5f6e922997d57ecd58ced1b467c65f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba8963695f6b09483f58b46b4b84f57"><td class="memItemLeft" align="right" valign="top"><a id="a6ba8963695f6b09483f58b46b4b84f57"></a>
struct <a class="el" href="struct__listEntry.html">_listEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_updatesPosList</b></td></tr>
<tr class="separator:a6ba8963695f6b09483f58b46b4b84f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad610866d540c40d6f0a15ec2f55c4b"><td class="memItemLeft" align="right" valign="top"><a id="a3ad610866d540c40d6f0a15ec2f55c4b"></a>
struct <a class="el" href="struct__hashUpdateEntry.html">_hashUpdateEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_hashForUpdates</b></td></tr>
<tr class="separator:a3ad610866d540c40d6f0a15ec2f55c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc79758f16e4124d0b66f2adb5827e4c"><td class="memItemLeft" align="right" valign="top"><a id="abc79758f16e4124d0b66f2adb5827e4c"></a>
struct <a class="el" href="struct__hashSelectorEntry.html">_hashSelectorEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_hashForTimers</b></td></tr>
<tr class="separator:abc79758f16e4124d0b66f2adb5827e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf55db11c1ca73c7085605692021ef"><td class="memItemLeft" align="right" valign="top"><a id="a7baf55db11c1ca73c7085605692021ef"></a>
struct <a class="el" href="struct__hashSelectorEntry.html">_hashSelectorEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_currentTarget</b></td></tr>
<tr class="separator:a7baf55db11c1ca73c7085605692021ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3217f15a9dbe25d98d53607b2f7643"><td class="memItemLeft" align="right" valign="top"><a id="aee3217f15a9dbe25d98d53607b2f7643"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_currentTargetSalvaged</b></td></tr>
<tr class="separator:aee3217f15a9dbe25d98d53607b2f7643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9971f6f49f84fc8111fa0e7d56ed057"><td class="memItemLeft" align="right" valign="top"><a id="ad9971f6f49f84fc8111fa0e7d56ed057"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_updateHashLocked</b></td></tr>
<tr class="separator:ad9971f6f49f84fc8111fa0e7d56ed057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024850bf53629336393fccf31d333606"><td class="memItemLeft" align="right" valign="top"><a id="a024850bf53629336393fccf31d333606"></a>
std::vector&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_functionsToPerform</b></td></tr>
<tr class="separator:a024850bf53629336393fccf31d333606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed63ec9d9751e86abc953ea06ee58388"><td class="memItemLeft" align="right" valign="top"><a id="aed63ec9d9751e86abc953ea06ee58388"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_performMutex</b></td></tr>
<tr class="separator:aed63ec9d9751e86abc953ea06ee58388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e5bcc3383dd13d978d37c0e597975a"><td class="memItemLeft" align="right" valign="top"><a id="a91e5bcc3383dd13d978d37c0e597975a"></a>
std::vector&lt; struct <a class="el" href="struct__listEntry.html">_listEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_updateDeleteVector</b></td></tr>
<tr class="separator:a91e5bcc3383dd13d978d37c0e597975a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRef.html">Ref</a></td></tr>
<tr class="memitem:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memItemLeft" align="right" valign="top"><a id="ab05a4c4ef09ecbaffc7c7c7f57d34bf6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRef.html#ab05a4c4ef09ecbaffc7c7c7f57d34bf6">_referenceCount</a></td></tr>
<tr class="memdesc:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">count of references <br /></td></tr>
<tr class="separator:ab05a4c4ef09ecbaffc7c7c7f57d34bf6 inherit pro_attribs_classRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classScheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks. You should not use system timer for ...">Scheduler</a> is responsible for triggering the scheduled callbacks. You should not use system timer for your game logic. Instead, use this class. </p>
<p>There are 2 different types of callbacks (selectors):</p>
<ul>
<li>update selector: the 'update' selector will be called every frame. You can customize the priority.</li>
<li>custom selector: A custom selector will be called every frame, or with a custom interval of time</li>
</ul>
<p>The 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b61aac11466cd45ae42ab8c2b0013f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b61aac11466cd45ae42ab8c2b0013f6">&#9670;&nbsp;</a></span>Scheduler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scheduler::Scheduler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>ctor </p>

</div>
</div>
<a id="afc8187779b46f64039d3ffa58f0dbe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8187779b46f64039d3ffa58f0dbe51">&#9670;&nbsp;</a></span>~Scheduler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scheduler::~Scheduler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>NA  NA </p>

</div>
</div>
<a id="a3b61aac11466cd45ae42ab8c2b0013f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b61aac11466cd45ae42ab8c2b0013f6">&#9670;&nbsp;</a></span>Scheduler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scheduler::Scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>ctor </p>

</div>
</div>
<a id="a900bd7768c2580dbc3a08c2873aa6086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900bd7768c2580dbc3a08c2873aa6086">&#9670;&nbsp;</a></span>~Scheduler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Scheduler::~Scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>NA  NA </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ec13a52fa6a75450f17f122444069a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec13a52fa6a75450f17f122444069a9">&#9670;&nbsp;</a></span>getTimeScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Scheduler::getTimeScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the time scale of schedule callbacks. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classScheduler.html#a7aeaef587604d3a1f20ebac7a12b1d77">Scheduler::setTimeScale()</a> </dd></dl>

</div>
</div>
<a id="a2ec13a52fa6a75450f17f122444069a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec13a52fa6a75450f17f122444069a9">&#9670;&nbsp;</a></span>getTimeScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Scheduler::getTimeScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the time scale of schedule callbacks. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classScheduler.html#a7aeaef587604d3a1f20ebac7a12b1d77">Scheduler::setTimeScale()</a> </dd></dl>

</div>
</div>
<a id="a57e1ce8ec29f360c27d82d91028b23a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e1ce8ec29f360c27d82d91028b23a5">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a callback associated with 'key' and 'target' is scheduled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified callback is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0.0 </dd></dl>

</div>
</div>
<a id="a5b534eae62394806603e522ab4191d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b534eae62394806603e522ab4191d3b">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a callback associated with 'key' and 'target' is scheduled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified callback is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0.0 </dd></dl>

</div>
</div>
<a id="aa43205eb0e74dd43834705a45e4fbdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43205eb0e74dd43834705a45e4fbdf1">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isScheduled </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a selector for a given target is scheduled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector to be checked. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified selector is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a95ed753a2875e2635b5120cee5c3e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ed753a2875e2635b5120cee5c3e432">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isScheduled </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a selector for a given target is scheduled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector to be checked. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified selector is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a9cdd2ece7f43eaca5662d12ae0b95a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdd2ece7f43eaca5662d12ae0b95a87">&#9670;&nbsp;</a></span>isScheduledForTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE bool Scheduler::isScheduledForTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether a selector for a given target is scheduled. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#a5b534eae62394806603e522ab4191d3b">Scheduler::isScheduled</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="a9cdd2ece7f43eaca5662d12ae0b95a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdd2ece7f43eaca5662d12ae0b95a87">&#9670;&nbsp;</a></span>isScheduledForTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE bool Scheduler::isScheduledForTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether a selector for a given target is scheduled. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000293">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#a5b534eae62394806603e522ab4191d3b">Scheduler::isScheduled</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="aef17d4d358516d712c32ac421202198c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef17d4d358516d712c32ac421202198c">&#9670;&nbsp;</a></span>isTargetPaused() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isTargetPaused </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the target is paused. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the target is paused, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v1.0.0  NA </dd></dl>

</div>
</div>
<a id="aef17d4d358516d712c32ac421202198c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef17d4d358516d712c32ac421202198c">&#9670;&nbsp;</a></span>isTargetPaused() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scheduler::isTargetPaused </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the target is paused. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the target is paused, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v1.0.0  NA </dd></dl>

</div>
</div>
<a id="a3c551579277e1746f260d8397b4ac6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c551579277e1746f260d8397b4ac6ee">&#9670;&nbsp;</a></span>pauseAllTargets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;void*&gt; Scheduler::pauseAllTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pause all selectors from all targets. You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a5a624f0bf247439e11f45388dce5d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a624f0bf247439e11f45388dce5d465">&#9670;&nbsp;</a></span>pauseAllTargets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; void * &gt; Scheduler::pauseAllTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pause all selectors from all targets. You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a306504d4f42cbe75cbe948b0d64d2750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306504d4f42cbe75cbe948b0d64d2750">&#9670;&nbsp;</a></span>pauseAllTargetsWithMinPriority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;void*&gt; Scheduler::pauseAllTargetsWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pause all selectors from all targets with a minimum priority. You should only call this with PRIORITY_NON_SYSTEM_MIN or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be paused. Which means, all selectors which priority is higher than minPriority will be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="ac981921d200acdeedffa17c5e0c06f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981921d200acdeedffa17c5e0c06f77">&#9670;&nbsp;</a></span>pauseAllTargetsWithMinPriority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; void * &gt; Scheduler::pauseAllTargetsWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pause all selectors from all targets with a minimum priority. You should only call this with PRIORITY_NON_SYSTEM_MIN or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be paused. Which means, all selectors which priority is higher than minPriority will be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a409cb6f82cffd7d779154d9d813664af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409cb6f82cffd7d779154d9d813664af">&#9670;&nbsp;</a></span>pauseTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::pauseTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the target. All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a409cb6f82cffd7d779154d9d813664af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409cb6f82cffd7d779154d9d813664af">&#9670;&nbsp;</a></span>pauseTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::pauseTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the target. All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a24dcb12852832912c43298288c03895f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dcb12852832912c43298288c03895f">&#9670;&nbsp;</a></span>performFunctionInCocosThread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::performFunctionInCocosThread </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a function on the cocos2d thread. Useful when you need to call a cocos2d function from another thread. This function is thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to be run in cocos2d thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0  NA </dd></dl>

</div>
</div>
<a id="acd6da28a03a7f8b9df377f1e05e7883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6da28a03a7f8b9df377f1e05e7883f">&#9670;&nbsp;</a></span>performFunctionInCocosThread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::performFunctionInCocosThread </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a function on the cocos2d thread. Useful when you need to call a cocos2d function from another thread. This function is thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to be run in cocos2d thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0  NA </dd></dl>

</div>
</div>
<a id="a8872d90ed82fdb19f93f9bd30e2837aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8872d90ed82fdb19f93f9bd30e2837aa">&#9670;&nbsp;</a></span>removeAllFunctionsToBePerformedInCocosThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::removeAllFunctionsToBePerformedInCocosThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all pending functions queued to be performed with <a class="el" href="classScheduler.html#acd6da28a03a7f8b9df377f1e05e7883f">Scheduler::performFunctionInCocosThread</a> Functions unscheduled in this manner will not be executed This function is thread safe </p><dl class="section since"><dt>Since</dt><dd>v3.14  NA </dd></dl>

</div>
</div>
<a id="aebdab814dbc692356f813d335c3b92af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdab814dbc692356f813d335c3b92af">&#9670;&nbsp;</a></span>resumeTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::resumeTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes the target. The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="aebdab814dbc692356f813d335c3b92af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdab814dbc692356f813d335c3b92af">&#9670;&nbsp;</a></span>resumeTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::resumeTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes the target. The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a5b568bffe196f3a5cefe0739354dc900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b568bffe196f3a5cefe0739354dc900">&#9670;&nbsp;</a></span>resumeTargets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::resumeTargets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>targetsToResume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume selectors on a set of targets. This can be useful for undoing a call to pauseAllSelectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetsToResume</td><td>The set of targets to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a5b568bffe196f3a5cefe0739354dc900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b568bffe196f3a5cefe0739354dc900">&#9670;&nbsp;</a></span>resumeTargets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::resumeTargets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>targetsToResume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume selectors on a set of targets. This can be useful for undoing a call to pauseAllSelectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetsToResume</td><td>The set of targets to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a0d52145629a67e888cf1b25fd01f668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d52145629a67e888cf1b25fd01f668b">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the 'callback' is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a0d52145629a67e888cf1b25fd01f668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d52145629a67e888cf1b25fd01f668b">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the 'callback' is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a895a2f8f8eb3fc23b869cd1221660dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895a2f8f8eb3fc23b869cd1221660dcd">&#9670;&nbsp;</a></span>schedule() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds for ever. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a895a2f8f8eb3fc23b869cd1221660dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895a2f8f8eb3fc23b869cd1221660dcd">&#9670;&nbsp;</a></span>schedule() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds for ever. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a5d34a2cf35f2af15f3377ee8b2e88a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d34a2cf35f2af15f3377ee8b2e88a38">&#9670;&nbsp;</a></span>schedule() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every <code>interval</code> seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a5d34a2cf35f2af15f3377ee8b2e88a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d34a2cf35f2af15f3377ee8b2e88a38">&#9670;&nbsp;</a></span>schedule() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every <code>interval</code> seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="aef7946e2043d6e49f2a0a460740d8ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7946e2043d6e49f2a0a460740d8ae5">&#9670;&nbsp;</a></span>schedule() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every <code>interval</code> seconds for ever. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7946e2043d6e49f2a0a460740d8ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7946e2043d6e49f2a0a460740d8ae5">&#9670;&nbsp;</a></span>schedule() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduled method will be called every <code>interval</code> seconds for ever. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9910c07a3c437d44478004a5c407834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9910c07a3c437d44478004a5c407834a">&#9670;&nbsp;</a></span>schedulePerFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedulePerFrame </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'callback' function for a given target with a given priority. The 'callback' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="section note"><dt>Note</dt><dd>This method is only for internal use. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0  _schedulePerFrame </dd></dl>

</div>
</div>
<a id="a9910c07a3c437d44478004a5c407834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9910c07a3c437d44478004a5c407834a">&#9670;&nbsp;</a></span>schedulePerFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::schedulePerFrame </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'callback' function for a given target with a given priority. The 'callback' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="section note"><dt>Note</dt><dd>This method is only for internal use. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0  _schedulePerFrame </dd></dl>

</div>
</div>
<a id="ae8df7fdf2f74a90cdb37bc334a550360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8df7fdf2f74a90cdb37bc334a550360">&#9670;&nbsp;</a></span>scheduleSelector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdateForTarget:' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Please use <code><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">Scheduler::schedule</a></code> instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3, repeat and delay added in v1.1  NA </dd></dl>

</div>
</div>
<a id="ae8df7fdf2f74a90cdb37bc334a550360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8df7fdf2f74a90cdb37bc334a550360">&#9670;&nbsp;</a></span>scheduleSelector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scheduled method will be called every 'interval' seconds. If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdateForTarget:' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000289">Deprecated:</a></b></dt><dd>Please use <code><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">Scheduler::schedule</a></code> instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3, repeat and delay added in v1.1  NA </dd></dl>

</div>
</div>
<a id="ab41f346fb140ff11ebc2b0736bc7b58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41f346fb140ff11ebc2b0736bc7b58a">&#9670;&nbsp;</a></span>scheduleSelector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls scheduleSelector with CC_REPEAT_FOREVER and a 0 delay. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>Please use <code><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">Scheduler::schedule</a></code> instead.  NA </dd></dl>

</div>
</div>
<a id="ab41f346fb140ff11ebc2b0736bc7b58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41f346fb140ff11ebc2b0736bc7b58a">&#9670;&nbsp;</a></span>scheduleSelector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls scheduleSelector with CC_REPEAT_FOREVER and a 0 delay. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000290">Deprecated:</a></b></dt><dd>Please use <code><a class="el" href="classScheduler.html#a0d52145629a67e888cf1b25fd01f668b">Scheduler::schedule</a></code> instead.  NA </dd></dl>

</div>
</div>
<a id="ad566d55a4941459c185e6faeddc3a70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad566d55a4941459c185e6faeddc3a70f">&#9670;&nbsp;</a></span>scheduleUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'update' selector for a given target with a given priority. The 'update' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="section since"><dt>Since</dt><dd>v3.0  NA </dd></dl>

</div>
</div>
<a id="ad566d55a4941459c185e6faeddc3a70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad566d55a4941459c185e6faeddc3a70f">&#9670;&nbsp;</a></span>scheduleUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'update' selector for a given target with a given priority. The 'update' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="section since"><dt>Since</dt><dd>v3.0  NA </dd></dl>

</div>
</div>
<a id="a87a354dc2bcf3a750ed66f8d67ed0b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a354dc2bcf3a750ed66f8d67ed0b70">&#9670;&nbsp;</a></span>scheduleUpdateForTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleUpdateForTarget </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'update' selector for a given target with a given priority. The 'update' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#ad566d55a4941459c185e6faeddc3a70f">Scheduler::scheduleUpdate</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a87a354dc2bcf3a750ed66f8d67ed0b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a354dc2bcf3a750ed66f8d67ed0b70">&#9670;&nbsp;</a></span>scheduleUpdateForTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::scheduleUpdateForTarget </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules the 'update' selector for a given target with a given priority. The 'update' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000291">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#ad566d55a4941459c185e6faeddc3a70f">Scheduler::scheduleUpdate</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a7aeaef587604d3a1f20ebac7a12b1d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeaef587604d3a1f20ebac7a12b1d77">&#9670;&nbsp;</a></span>setTimeScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::setTimeScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modifies the time of all scheduled callbacks. You can use this property to create a 'slow motion' or 'fast forward' effect. Default is 1.0. To create a 'slow motion' effect, use values below 1.0. To create a 'fast forward' effect, use values higher than 1.0. </p><dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It will affect EVERY scheduled selector / action. </dd></dl>

</div>
</div>
<a id="a7aeaef587604d3a1f20ebac7a12b1d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeaef587604d3a1f20ebac7a12b1d77">&#9670;&nbsp;</a></span>setTimeScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::setTimeScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modifies the time of all scheduled callbacks. You can use this property to create a 'slow motion' or 'fast forward' effect. Default is 1.0. To create a 'slow motion' effect, use values below 1.0. To create a 'fast forward' effect, use values higher than 1.0. </p><dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It will affect EVERY scheduled selector / action. </dd></dl>

</div>
</div>
<a id="a3ca194b9ca146d9c522cc2c54a6d4ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca194b9ca146d9c522cc2c54a6d4ede">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unschedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a callback for a key and a given target. If you want to unschedule the 'callbackPerFrame', use unscheduleUpdate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a3ca194b9ca146d9c522cc2c54a6d4ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca194b9ca146d9c522cc2c54a6d4ede">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unschedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a callback for a key and a given target. If you want to unschedule the 'callbackPerFrame', use unscheduleUpdate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a6d354b587d5f12df2e6094116fd65c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d354b587d5f12df2e6094116fd65c71">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unschedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a selector for a given target. If you want to unschedule the "update", use <code><a class="el" href="classScheduler.html#acc7bc87cc441a0f826c2a6758a9adcad">unscheduleUpdate()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector that is unscheduled. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the unscheduled selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a6d354b587d5f12df2e6094116fd65c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d354b587d5f12df2e6094116fd65c71">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unschedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules a selector for a given target. If you want to unschedule the "update", use <code>unscheudleUpdate()</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector that is unscheduled. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the unscheduled selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a0746c417a3cf7c794d1ee32969994e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0746c417a3cf7c794d1ee32969994e6a">&#9670;&nbsp;</a></span>unscheduleAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors from all targets. You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a0746c417a3cf7c794d1ee32969994e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0746c417a3cf7c794d1ee32969994e6a">&#9670;&nbsp;</a></span>unscheduleAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors from all targets. You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a39199385fc1ab4f74c5665beaa2738b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39199385fc1ab4f74c5665beaa2738b6">&#9670;&nbsp;</a></span>unscheduleAllForTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAllForTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors for a given target. This also includes the "update" selector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="a39199385fc1ab4f74c5665beaa2738b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39199385fc1ab4f74c5665beaa2738b6">&#9670;&nbsp;</a></span>unscheduleAllForTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAllForTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors for a given target. This also includes the "update" selector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="aa846e95ed320bdac9ca2c91a0d7e79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa846e95ed320bdac9ca2c91a0d7e79db">&#9670;&nbsp;</a></span>unscheduleAllWithMinPriority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAllWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors from all targets with a minimum priority. You should only call this with <code>PRIORITY_NON_SYSTEM_MIN</code> or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be unscheduled. Which means, all selectors which priority is higher than minPriority will be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="aa846e95ed320bdac9ca2c91a0d7e79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa846e95ed320bdac9ca2c91a0d7e79db">&#9670;&nbsp;</a></span>unscheduleAllWithMinPriority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleAllWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules all selectors from all targets with a minimum priority. You should only call this with <code>PRIORITY_NON_SYSTEM_MIN</code> or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be unscheduled. Which means, all selectors which priority is higher than minPriority will be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a25e540092eabffd80c97fe2af4faf7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e540092eabffd80c97fe2af4faf7d5">&#9670;&nbsp;</a></span>unscheduleSelector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::unscheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unschedule a selector for a given target. If you want to unschedule the "update", use unscheudleUpdateForTarget. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#a3ca194b9ca146d9c522cc2c54a6d4ede">Scheduler::unschedule</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="a25e540092eabffd80c97fe2af4faf7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e540092eabffd80c97fe2af4faf7d5">&#9670;&nbsp;</a></span>unscheduleSelector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::unscheduleSelector </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unschedule a selector for a given target. If you want to unschedule the "update", use unscheduleUpdateForTarget. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000292">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#a3ca194b9ca146d9c522cc2c54a6d4ede">Scheduler::unschedule</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3  NA </dd></dl>

</div>
</div>
<a id="acc7bc87cc441a0f826c2a6758a9adcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7bc87cc441a0f826c2a6758a9adcad">&#9670;&nbsp;</a></span>unscheduleUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules the update selector for a given target </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="acc7bc87cc441a0f826c2a6758a9adcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7bc87cc441a0f826c2a6758a9adcad">&#9670;&nbsp;</a></span>unscheduleUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::unscheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unschedules the update selector for a given target </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="ac5ba32d69e94ebe72d58cbd661782ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba32d69e94ebe72d58cbd661782ca6">&#9670;&nbsp;</a></span>unscheduleUpdateForTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::unscheduleUpdateForTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unschedules the update selector for a given target </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#acc7bc87cc441a0f826c2a6758a9adcad">Scheduler::unscheduleUpdate</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="ac5ba32d69e94ebe72d58cbd661782ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba32d69e94ebe72d58cbd661782ca6">&#9670;&nbsp;</a></span>unscheduleUpdateForTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CC_DEPRECATED_ATTRIBUTE void Scheduler::unscheduleUpdateForTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRef.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unschedules the update selector for a given target </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000294">Deprecated:</a></b></dt><dd>Please use '<a class="el" href="classScheduler.html#acc7bc87cc441a0f826c2a6758a9adcad">Scheduler::unscheduleUpdate</a>' instead. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a533ad6047192a10444e2f4d386f3766a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533ad6047192a10444e2f4d386f3766a">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'update' the scheduler. You should NEVER call this method, unless you know what you are doing.  NA </p>

</div>
</div>
<a id="a533ad6047192a10444e2f4d386f3766a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533ad6047192a10444e2f4d386f3766a">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scheduler::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'update' the scheduler. You should NEVER call this method, unless you know what you are doing.  NA </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff5f555d99f98484e7b7f46450089460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5f555d99f98484e7b7f46450089460">&#9670;&nbsp;</a></span>PRIORITY_NON_SYSTEM_MIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const int Scheduler::PRIORITY_NON_SYSTEM_MIN = <a class="el" href="classScheduler.html#ab81137eee61d428046a59dd036a9bf33">PRIORITY_SYSTEM</a> + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum priority level for user scheduling. Priority level of user scheduling should bigger then this value.</p>
<p>NA  NA </p>

</div>
</div>
<a id="ab81137eee61d428046a59dd036a9bf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81137eee61d428046a59dd036a9bf33">&#9670;&nbsp;</a></span>PRIORITY_SYSTEM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const int Scheduler::PRIORITY_SYSTEM = INT_MIN</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Priority level reserved for system services.  NA  NA </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/base/<a class="el" href="cocos2d_2cocos_2base_2CCScheduler_8h_source.html">CCScheduler.h</a></li>
<li>/home/pmx/git/PMX/SimuCocos/cocos2d/cocos/base/CCScheduler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
