<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEST: cpSpace</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpSpace</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color type to use with the space debug drawing API.  <a href="structcpSpaceDebugColor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpSpaceDebugDrawOptions.html">cpSpaceDebugDrawOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used with <a class="el" href="group__cpSpace.html#ga02e8a34681aff3f29bd976e830f3b6da" title="Debug draw the current state of the space using the supplied drawing options. ">cpSpaceDebugDraw()</a> containing drawing callbacks and other drawing settings.  <a href="structcpSpaceDebugDrawOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3134f145bfc7ca4ef69b350978c26a5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga3134f145bfc7ca4ef69b350978c26a5a">cpCollisionBeginFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:ga3134f145bfc7ca4ef69b350978c26a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b24d53d81a5a028198c3c2d3c39a9d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga89b24d53d81a5a028198c3c2d3c39a9d">cpCollisionPreSolveFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:ga89b24d53d81a5a028198c3c2d3c39a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="memItemLeft" align="right" valign="top"><a id="gaccb60bbb090c97823f49ee49e4e5d3c3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaccb60bbb090c97823f49ee49e4e5d3c3">cpCollisionPostSolveFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="memdesc:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision post-solve event function callback type. <br /></td></tr>
<tr class="separator:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01427ab634c483879cfed5bb22610487"><td class="memItemLeft" align="right" valign="top"><a id="ga01427ab634c483879cfed5bb22610487"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga01427ab634c483879cfed5bb22610487">cpCollisionSeparateFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="memdesc:ga01427ab634c483879cfed5bb22610487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision separate event function callback type. <br /></td></tr>
<tr class="separator:ga01427ab634c483879cfed5bb22610487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e9005e387fec86eeb4a225ac295a23"><td class="memItemLeft" align="right" valign="top"><a id="ga93e9005e387fec86eeb4a225ac295a23"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga93e9005e387fec86eeb4a225ac295a23">cpPostStepFunc</a>) (<a class="el" href="structcpSpace.html">cpSpace</a> *space, void *key, void *data)</td></tr>
<tr class="memdesc:ga93e9005e387fec86eeb4a225ac295a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post Step callback function type. <br /></td></tr>
<tr class="separator:ga93e9005e387fec86eeb4a225ac295a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646a55f0937f07c19b24561ed5341221"><td class="memItemLeft" align="right" valign="top"><a id="ga646a55f0937f07c19b24561ed5341221"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga646a55f0937f07c19b24561ed5341221">cpSpacePointQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpVect.html">cpVect</a> point, cpFloat distance, <a class="el" href="structcpVect.html">cpVect</a> gradient, void *data)</td></tr>
<tr class="memdesc:ga646a55f0937f07c19b24561ed5341221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest point query callback function type. <br /></td></tr>
<tr class="separator:ga646a55f0937f07c19b24561ed5341221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="memItemLeft" align="right" valign="top"><a id="ga9046beaeba5728c5e954f0f1dc2ae130"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga9046beaeba5728c5e954f0f1dc2ae130">cpSpaceSegmentQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpVect.html">cpVect</a> point, <a class="el" href="structcpVect.html">cpVect</a> normal, cpFloat alpha, void *data)</td></tr>
<tr class="memdesc:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment query callback function type. <br /></td></tr>
<tr class="separator:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02779238e9b8c07797aae6139fad203c"><td class="memItemLeft" align="right" valign="top"><a id="ga02779238e9b8c07797aae6139fad203c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga02779238e9b8c07797aae6139fad203c">cpSpaceBBQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, void *data)</td></tr>
<tr class="memdesc:ga02779238e9b8c07797aae6139fad203c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangle Query callback function type. <br /></td></tr>
<tr class="separator:ga02779238e9b8c07797aae6139fad203c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="memItemLeft" align="right" valign="top"><a id="gab124952dd71dea36688f6ff6ff8bdcb2"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab124952dd71dea36688f6ff6ff8bdcb2">cpSpaceShapeQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a> *points, void *data)</td></tr>
<tr class="memdesc:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape query callback function type. <br /></td></tr>
<tr class="separator:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2870b1128c5bfe79cb261d269abdea64"><td class="memItemLeft" align="right" valign="top"><a id="ga2870b1128c5bfe79cb261d269abdea64"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2870b1128c5bfe79cb261d269abdea64">cpSpaceBodyIteratorFunc</a>) (<a class="el" href="structcpBody.html">cpBody</a> *body, void *data)</td></tr>
<tr class="memdesc:ga2870b1128c5bfe79cb261d269abdea64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/body iterator callback function type. <br /></td></tr>
<tr class="separator:ga2870b1128c5bfe79cb261d269abdea64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae017c9a8a7c082032035bf165e4ec9"><td class="memItemLeft" align="right" valign="top"><a id="gafae017c9a8a7c082032035bf165e4ec9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gafae017c9a8a7c082032035bf165e4ec9">cpSpaceShapeIteratorFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, void *data)</td></tr>
<tr class="memdesc:gafae017c9a8a7c082032035bf165e4ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/body iterator callback function type. <br /></td></tr>
<tr class="separator:gafae017c9a8a7c082032035bf165e4ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf20ed2411342352dc43b71c60649c1"><td class="memItemLeft" align="right" valign="top"><a id="ga0bf20ed2411342352dc43b71c60649c1"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga0bf20ed2411342352dc43b71c60649c1">cpSpaceConstraintIteratorFunc</a>) (<a class="el" href="structcpConstraint.html">cpConstraint</a> *constraint, void *data)</td></tr>
<tr class="memdesc:ga0bf20ed2411342352dc43b71c60649c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/constraint iterator callback function type. <br /></td></tr>
<tr class="separator:ga0bf20ed2411342352dc43b71c60649c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc46fcefca8c28112ca8245eef00bae7"><td class="memItemLeft" align="right" valign="top"><a id="gafc46fcefca8c28112ca8245eef00bae7"></a>
typedef struct <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gafc46fcefca8c28112ca8245eef00bae7">cpSpaceDebugColor</a></td></tr>
<tr class="memdesc:gafc46fcefca8c28112ca8245eef00bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color type to use with the space debug drawing API. <br /></td></tr>
<tr class="separator:gafc46fcefca8c28112ca8245eef00bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96ab3199114538fa70cb5f7c6b2887a"><td class="memItemLeft" align="right" valign="top"><a id="gab96ab3199114538fa70cb5f7c6b2887a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab96ab3199114538fa70cb5f7c6b2887a">cpSpaceDebugDrawCircleImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> pos, cpFloat angle, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gab96ab3199114538fa70cb5f7c6b2887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a filled, stroked circle. <br /></td></tr>
<tr class="separator:gab96ab3199114538fa70cb5f7c6b2887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed387c6356be81f3da4050547fe47c9e"><td class="memItemLeft" align="right" valign="top"><a id="gaed387c6356be81f3da4050547fe47c9e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaed387c6356be81f3da4050547fe47c9e">cpSpaceDebugDrawSegmentImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> color, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gaed387c6356be81f3da4050547fe47c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a line segment. <br /></td></tr>
<tr class="separator:gaed387c6356be81f3da4050547fe47c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="memItemLeft" align="right" valign="top"><a id="gab8b2b1f7036daa38914a0d3c2cb1d732"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab8b2b1f7036daa38914a0d3c2cb1d732">cpSpaceDebugDrawFatSegmentImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a thick line segment. <br /></td></tr>
<tr class="separator:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2138e846816a1e581a3433740a596ab6"><td class="memItemLeft" align="right" valign="top"><a id="ga2138e846816a1e581a3433740a596ab6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2138e846816a1e581a3433740a596ab6">cpSpaceDebugDrawPolygonImpl</a>) (int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:ga2138e846816a1e581a3433740a596ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a convex polygon. <br /></td></tr>
<tr class="separator:ga2138e846816a1e581a3433740a596ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9a758a2f1c3b53551829573b722e5a"><td class="memItemLeft" align="right" valign="top"><a id="gadf9a758a2f1c3b53551829573b722e5a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gadf9a758a2f1c3b53551829573b722e5a">cpSpaceDebugDrawDotImpl</a>) (cpFloat size, <a class="el" href="structcpVect.html">cpVect</a> pos, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> color, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gadf9a758a2f1c3b53551829573b722e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a dot. <br /></td></tr>
<tr class="separator:gadf9a758a2f1c3b53551829573b722e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="memItemLeft" align="right" valign="top"><a id="gaba1fec950f2b58c7c72ab5ca553bdf43"></a>
typedef <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaba1fec950f2b58c7c72ab5ca553bdf43">cpSpaceDebugDrawColorForShapeImpl</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine. <br /></td></tr>
<tr class="separator:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa625807338fd5ebd8f61463dead0c32b"><td class="memItemLeft" align="right" valign="top"><a id="gaa625807338fd5ebd8f61463dead0c32b"></a>
typedef enum cpSpaceDebugDrawFlags&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceDebugDrawFlags</b></td></tr>
<tr class="separator:gaa625807338fd5ebd8f61463dead0c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb44b3d40332bc5965e8dbd515caa71a"><td class="memItemLeft" align="right" valign="top"><a id="gabb44b3d40332bc5965e8dbd515caa71a"></a>
typedef struct <a class="el" href="structcpSpaceDebugDrawOptions.html">cpSpaceDebugDrawOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gabb44b3d40332bc5965e8dbd515caa71a">cpSpaceDebugDrawOptions</a></td></tr>
<tr class="memdesc:gabb44b3d40332bc5965e8dbd515caa71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used with <a class="el" href="group__cpSpace.html#ga02e8a34681aff3f29bd976e830f3b6da" title="Debug draw the current state of the space using the supplied drawing options. ">cpSpaceDebugDraw()</a> containing drawing callbacks and other drawing settings. <br /></td></tr>
<tr class="separator:gabb44b3d40332bc5965e8dbd515caa71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3134f145bfc7ca4ef69b350978c26a5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga3134f145bfc7ca4ef69b350978c26a5a">cpCollisionBeginFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:ga3134f145bfc7ca4ef69b350978c26a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b24d53d81a5a028198c3c2d3c39a9d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga89b24d53d81a5a028198c3c2d3c39a9d">cpCollisionPreSolveFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:ga89b24d53d81a5a028198c3c2d3c39a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="memItemLeft" align="right" valign="top"><a id="gaccb60bbb090c97823f49ee49e4e5d3c3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaccb60bbb090c97823f49ee49e4e5d3c3">cpCollisionPostSolveFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="memdesc:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision post-solve event function callback type. <br /></td></tr>
<tr class="separator:gaccb60bbb090c97823f49ee49e4e5d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01427ab634c483879cfed5bb22610487"><td class="memItemLeft" align="right" valign="top"><a id="ga01427ab634c483879cfed5bb22610487"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga01427ab634c483879cfed5bb22610487">cpCollisionSeparateFunc</a>) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="memdesc:ga01427ab634c483879cfed5bb22610487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision separate event function callback type. <br /></td></tr>
<tr class="separator:ga01427ab634c483879cfed5bb22610487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e9005e387fec86eeb4a225ac295a23"><td class="memItemLeft" align="right" valign="top"><a id="ga93e9005e387fec86eeb4a225ac295a23"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga93e9005e387fec86eeb4a225ac295a23">cpPostStepFunc</a>) (<a class="el" href="structcpSpace.html">cpSpace</a> *space, void *key, void *data)</td></tr>
<tr class="memdesc:ga93e9005e387fec86eeb4a225ac295a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post Step callback function type. <br /></td></tr>
<tr class="separator:ga93e9005e387fec86eeb4a225ac295a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646a55f0937f07c19b24561ed5341221"><td class="memItemLeft" align="right" valign="top"><a id="ga646a55f0937f07c19b24561ed5341221"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga646a55f0937f07c19b24561ed5341221">cpSpacePointQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpVect.html">cpVect</a> point, cpFloat distance, <a class="el" href="structcpVect.html">cpVect</a> gradient, void *data)</td></tr>
<tr class="memdesc:ga646a55f0937f07c19b24561ed5341221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest point query callback function type. <br /></td></tr>
<tr class="separator:ga646a55f0937f07c19b24561ed5341221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="memItemLeft" align="right" valign="top"><a id="ga9046beaeba5728c5e954f0f1dc2ae130"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga9046beaeba5728c5e954f0f1dc2ae130">cpSpaceSegmentQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpVect.html">cpVect</a> point, <a class="el" href="structcpVect.html">cpVect</a> normal, cpFloat alpha, void *data)</td></tr>
<tr class="memdesc:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment query callback function type. <br /></td></tr>
<tr class="separator:ga9046beaeba5728c5e954f0f1dc2ae130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02779238e9b8c07797aae6139fad203c"><td class="memItemLeft" align="right" valign="top"><a id="ga02779238e9b8c07797aae6139fad203c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga02779238e9b8c07797aae6139fad203c">cpSpaceBBQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, void *data)</td></tr>
<tr class="memdesc:ga02779238e9b8c07797aae6139fad203c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangle Query callback function type. <br /></td></tr>
<tr class="separator:ga02779238e9b8c07797aae6139fad203c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="memItemLeft" align="right" valign="top"><a id="gab124952dd71dea36688f6ff6ff8bdcb2"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab124952dd71dea36688f6ff6ff8bdcb2">cpSpaceShapeQueryFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="structcpContactPointSet.html">cpContactPointSet</a> *points, void *data)</td></tr>
<tr class="memdesc:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape query callback function type. <br /></td></tr>
<tr class="separator:gab124952dd71dea36688f6ff6ff8bdcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2870b1128c5bfe79cb261d269abdea64"><td class="memItemLeft" align="right" valign="top"><a id="ga2870b1128c5bfe79cb261d269abdea64"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2870b1128c5bfe79cb261d269abdea64">cpSpaceBodyIteratorFunc</a>) (<a class="el" href="structcpBody.html">cpBody</a> *body, void *data)</td></tr>
<tr class="memdesc:ga2870b1128c5bfe79cb261d269abdea64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/body iterator callback function type. <br /></td></tr>
<tr class="separator:ga2870b1128c5bfe79cb261d269abdea64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae017c9a8a7c082032035bf165e4ec9"><td class="memItemLeft" align="right" valign="top"><a id="gafae017c9a8a7c082032035bf165e4ec9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gafae017c9a8a7c082032035bf165e4ec9">cpSpaceShapeIteratorFunc</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, void *data)</td></tr>
<tr class="memdesc:gafae017c9a8a7c082032035bf165e4ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/body iterator callback function type. <br /></td></tr>
<tr class="separator:gafae017c9a8a7c082032035bf165e4ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf20ed2411342352dc43b71c60649c1"><td class="memItemLeft" align="right" valign="top"><a id="ga0bf20ed2411342352dc43b71c60649c1"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga0bf20ed2411342352dc43b71c60649c1">cpSpaceConstraintIteratorFunc</a>) (<a class="el" href="structcpConstraint.html">cpConstraint</a> *constraint, void *data)</td></tr>
<tr class="memdesc:ga0bf20ed2411342352dc43b71c60649c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space/constraint iterator callback function type. <br /></td></tr>
<tr class="separator:ga0bf20ed2411342352dc43b71c60649c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc46fcefca8c28112ca8245eef00bae7"><td class="memItemLeft" align="right" valign="top"><a id="gafc46fcefca8c28112ca8245eef00bae7"></a>
typedef struct <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gafc46fcefca8c28112ca8245eef00bae7">cpSpaceDebugColor</a></td></tr>
<tr class="memdesc:gafc46fcefca8c28112ca8245eef00bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color type to use with the space debug drawing API. <br /></td></tr>
<tr class="separator:gafc46fcefca8c28112ca8245eef00bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96ab3199114538fa70cb5f7c6b2887a"><td class="memItemLeft" align="right" valign="top"><a id="gab96ab3199114538fa70cb5f7c6b2887a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab96ab3199114538fa70cb5f7c6b2887a">cpSpaceDebugDrawCircleImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> pos, cpFloat angle, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gab96ab3199114538fa70cb5f7c6b2887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a filled, stroked circle. <br /></td></tr>
<tr class="separator:gab96ab3199114538fa70cb5f7c6b2887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed387c6356be81f3da4050547fe47c9e"><td class="memItemLeft" align="right" valign="top"><a id="gaed387c6356be81f3da4050547fe47c9e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaed387c6356be81f3da4050547fe47c9e">cpSpaceDebugDrawSegmentImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> color, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gaed387c6356be81f3da4050547fe47c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a line segment. <br /></td></tr>
<tr class="separator:gaed387c6356be81f3da4050547fe47c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="memItemLeft" align="right" valign="top"><a id="gab8b2b1f7036daa38914a0d3c2cb1d732"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab8b2b1f7036daa38914a0d3c2cb1d732">cpSpaceDebugDrawFatSegmentImpl</a>) (<a class="el" href="structcpVect.html">cpVect</a> a, <a class="el" href="structcpVect.html">cpVect</a> b, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a thick line segment. <br /></td></tr>
<tr class="separator:gab8b2b1f7036daa38914a0d3c2cb1d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2138e846816a1e581a3433740a596ab6"><td class="memItemLeft" align="right" valign="top"><a id="ga2138e846816a1e581a3433740a596ab6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2138e846816a1e581a3433740a596ab6">cpSpaceDebugDrawPolygonImpl</a>) (int count, const <a class="el" href="structcpVect.html">cpVect</a> *verts, cpFloat radius, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> outlineColor, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> fillColor, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:ga2138e846816a1e581a3433740a596ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a convex polygon. <br /></td></tr>
<tr class="separator:ga2138e846816a1e581a3433740a596ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9a758a2f1c3b53551829573b722e5a"><td class="memItemLeft" align="right" valign="top"><a id="gadf9a758a2f1c3b53551829573b722e5a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gadf9a758a2f1c3b53551829573b722e5a">cpSpaceDebugDrawDotImpl</a>) (cpFloat size, <a class="el" href="structcpVect.html">cpVect</a> pos, <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a> color, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gadf9a758a2f1c3b53551829573b722e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that draws a dot. <br /></td></tr>
<tr class="separator:gadf9a758a2f1c3b53551829573b722e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="memItemLeft" align="right" valign="top"><a id="gaba1fec950f2b58c7c72ab5ca553bdf43"></a>
typedef <a class="el" href="structcpSpaceDebugColor.html">cpSpaceDebugColor</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaba1fec950f2b58c7c72ab5ca553bdf43">cpSpaceDebugDrawColorForShapeImpl</a>) (<a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> data)</td></tr>
<tr class="memdesc:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for a function that returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine. <br /></td></tr>
<tr class="separator:gaba1fec950f2b58c7c72ab5ca553bdf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa625807338fd5ebd8f61463dead0c32b"><td class="memItemLeft" align="right" valign="top"><a id="gaa625807338fd5ebd8f61463dead0c32b"></a>
typedef enum cpSpaceDebugDrawFlags&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceDebugDrawFlags</b></td></tr>
<tr class="separator:gaa625807338fd5ebd8f61463dead0c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb44b3d40332bc5965e8dbd515caa71a"><td class="memItemLeft" align="right" valign="top"><a id="gabb44b3d40332bc5965e8dbd515caa71a"></a>
typedef struct <a class="el" href="structcpSpaceDebugDrawOptions.html">cpSpaceDebugDrawOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gabb44b3d40332bc5965e8dbd515caa71a">cpSpaceDebugDrawOptions</a></td></tr>
<tr class="memdesc:gabb44b3d40332bc5965e8dbd515caa71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used with <a class="el" href="group__cpSpace.html#ga02e8a34681aff3f29bd976e830f3b6da" title="Debug draw the current state of the space using the supplied drawing options. ">cpSpaceDebugDraw()</a> containing drawing callbacks and other drawing settings. <br /></td></tr>
<tr class="separator:gabb44b3d40332bc5965e8dbd515caa71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga12b09b00b23e09d770e4b2ab3980c69a"><td class="memItemLeft" align="right" valign="top"><a id="ga12b09b00b23e09d770e4b2ab3980c69a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceDebugDrawFlags</b> { <br />
&#160;&#160;<b>CP_SPACE_DEBUG_DRAW_SHAPES</b> = 1&lt;&lt;0, 
<b>CP_SPACE_DEBUG_DRAW_CONSTRAINTS</b> = 1&lt;&lt;1, 
<b>CP_SPACE_DEBUG_DRAW_COLLISION_POINTS</b> = 1&lt;&lt;2, 
<b>CP_SPACE_DEBUG_DRAW_SHAPES</b> = 1&lt;&lt;0, 
<br />
&#160;&#160;<b>CP_SPACE_DEBUG_DRAW_CONSTRAINTS</b> = 1&lt;&lt;1, 
<b>CP_SPACE_DEBUG_DRAW_COLLISION_POINTS</b> = 1&lt;&lt;2
<br />
 }</td></tr>
<tr class="separator:ga12b09b00b23e09d770e4b2ab3980c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b09b00b23e09d770e4b2ab3980c69a"><td class="memItemLeft" align="right" valign="top"><a id="ga12b09b00b23e09d770e4b2ab3980c69a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceDebugDrawFlags</b> { <br />
&#160;&#160;<b>CP_SPACE_DEBUG_DRAW_SHAPES</b> = 1&lt;&lt;0, 
<b>CP_SPACE_DEBUG_DRAW_CONSTRAINTS</b> = 1&lt;&lt;1, 
<b>CP_SPACE_DEBUG_DRAW_COLLISION_POINTS</b> = 1&lt;&lt;2, 
<b>CP_SPACE_DEBUG_DRAW_SHAPES</b> = 1&lt;&lt;0, 
<br />
&#160;&#160;<b>CP_SPACE_DEBUG_DRAW_CONSTRAINTS</b> = 1&lt;&lt;1, 
<b>CP_SPACE_DEBUG_DRAW_COLLISION_POINTS</b> = 1&lt;&lt;2
<br />
 }</td></tr>
<tr class="separator:ga12b09b00b23e09d770e4b2ab3980c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa233bc692b8773035e0b7af246f1785f"><td class="memItemLeft" align="right" valign="top"><a id="gaa233bc692b8773035e0b7af246f1785f"></a>
CP_EXPORT <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaa233bc692b8773035e0b7af246f1785f">cpSpaceAlloc</a> (void)</td></tr>
<tr class="memdesc:gaa233bc692b8773035e0b7af246f1785f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structcpSpace.html">cpSpace</a>. <br /></td></tr>
<tr class="separator:gaa233bc692b8773035e0b7af246f1785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6c77afe3cef0d06df38b7aa8d70354"><td class="memItemLeft" align="right" valign="top"><a id="ga4f6c77afe3cef0d06df38b7aa8d70354"></a>
CP_EXPORT <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga4f6c77afe3cef0d06df38b7aa8d70354">cpSpaceInit</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:ga4f6c77afe3cef0d06df38b7aa8d70354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structcpSpace.html">cpSpace</a>. <br /></td></tr>
<tr class="separator:ga4f6c77afe3cef0d06df38b7aa8d70354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7724bac5766902583bfc4a4f06ca32"><td class="memItemLeft" align="right" valign="top"><a id="ga2d7724bac5766902583bfc4a4f06ca32"></a>
CP_EXPORT <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2d7724bac5766902583bfc4a4f06ca32">cpSpaceNew</a> (void)</td></tr>
<tr class="memdesc:ga2d7724bac5766902583bfc4a4f06ca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a <a class="el" href="structcpSpace.html">cpSpace</a>. <br /></td></tr>
<tr class="separator:ga2d7724bac5766902583bfc4a4f06ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1097ee4fb04f32c4e82271d7603d26"><td class="memItemLeft" align="right" valign="top"><a id="gaaf1097ee4fb04f32c4e82271d7603d26"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaaf1097ee4fb04f32c4e82271d7603d26">cpSpaceDestroy</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gaaf1097ee4fb04f32c4e82271d7603d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="structcpSpace.html">cpSpace</a>. <br /></td></tr>
<tr class="separator:gaaf1097ee4fb04f32c4e82271d7603d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1bc162df996c03493be80d8220e5c8a"><td class="memItemLeft" align="right" valign="top"><a id="gab1bc162df996c03493be80d8220e5c8a"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab1bc162df996c03493be80d8220e5c8a">cpSpaceFree</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gab1bc162df996c03493be80d8220e5c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free a <a class="el" href="structcpSpace.html">cpSpace</a>. <br /></td></tr>
<tr class="separator:gab1bc162df996c03493be80d8220e5c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1bd8b3f1090018f65f8b798c99df79"><td class="memItemLeft" align="right" valign="top"><a id="ga7e1bd8b3f1090018f65f8b798c99df79"></a>
CP_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga7e1bd8b3f1090018f65f8b798c99df79">cpSpaceGetIterations</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:ga7e1bd8b3f1090018f65f8b798c99df79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations to use in the impulse solver to solve contacts and other constraints. <br /></td></tr>
<tr class="separator:ga7e1bd8b3f1090018f65f8b798c99df79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8975460871b3e9d3a6d89a4339742ea3"><td class="memItemLeft" align="right" valign="top"><a id="ga8975460871b3e9d3a6d89a4339742ea3"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetIterations</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, int iterations)</td></tr>
<tr class="separator:ga8975460871b3e9d3a6d89a4339742ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6270c6c036bcdd6adaeb59aac7bf6549"><td class="memItemLeft" align="right" valign="top"><a id="ga6270c6c036bcdd6adaeb59aac7bf6549"></a>
CP_EXPORT <a class="el" href="structcpVect.html">cpVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga6270c6c036bcdd6adaeb59aac7bf6549">cpSpaceGetGravity</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:ga6270c6c036bcdd6adaeb59aac7bf6549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gravity to pass to rigid bodies when integrating velocity. <br /></td></tr>
<tr class="separator:ga6270c6c036bcdd6adaeb59aac7bf6549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed619ffc8d4f3405316a6646d1e751c"><td class="memItemLeft" align="right" valign="top"><a id="ga5ed619ffc8d4f3405316a6646d1e751c"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetGravity</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpVect.html">cpVect</a> gravity)</td></tr>
<tr class="separator:ga5ed619ffc8d4f3405316a6646d1e751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00ad0e4956e444fa23874fae68df3b7"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gac00ad0e4956e444fa23874fae68df3b7">cpSpaceGetDamping</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:gac00ad0e4956e444fa23874fae68df3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02641468aa07e3120d73b4d33cb7e780"><td class="memItemLeft" align="right" valign="top"><a id="ga02641468aa07e3120d73b4d33cb7e780"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetDamping</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat damping)</td></tr>
<tr class="separator:ga02641468aa07e3120d73b4d33cb7e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256c38475826c4c165999079929fe1e7"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga256c38475826c4c165999079929fe1e7">cpSpaceGetIdleSpeedThreshold</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga256c38475826c4c165999079929fe1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb84ce106473ddfeafafcf4a4cd67993"><td class="memItemLeft" align="right" valign="top"><a id="gacb84ce106473ddfeafafcf4a4cd67993"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetIdleSpeedThreshold</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat idleSpeedThreshold)</td></tr>
<tr class="separator:gacb84ce106473ddfeafafcf4a4cd67993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f74ae04501ce532913c87e5be54a80"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab3f74ae04501ce532913c87e5be54a80">cpSpaceGetSleepTimeThreshold</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:gab3f74ae04501ce532913c87e5be54a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab593e909d82ad4824a7d1c2d6f397147"><td class="memItemLeft" align="right" valign="top"><a id="gab593e909d82ad4824a7d1c2d6f397147"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetSleepTimeThreshold</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat sleepTimeThreshold)</td></tr>
<tr class="separator:gab593e909d82ad4824a7d1c2d6f397147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e6178a021b1b6bba4b70876bf79d0"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga7b5e6178a021b1b6bba4b70876bf79d0">cpSpaceGetCollisionSlop</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga7b5e6178a021b1b6bba4b70876bf79d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa962f544b92ee508abd689729ceaaa9a"><td class="memItemLeft" align="right" valign="top"><a id="gaa962f544b92ee508abd689729ceaaa9a"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetCollisionSlop</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat collisionSlop)</td></tr>
<tr class="separator:gaa962f544b92ee508abd689729ceaaa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b093e1cbb978e00faf9216e1f9ab4f"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga53b093e1cbb978e00faf9216e1f9ab4f">cpSpaceGetCollisionBias</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga53b093e1cbb978e00faf9216e1f9ab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bf525e4d6c7eb83a5222e118168c60"><td class="memItemLeft" align="right" valign="top"><a id="ga46bf525e4d6c7eb83a5222e118168c60"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetCollisionBias</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat collisionBias)</td></tr>
<tr class="separator:ga46bf525e4d6c7eb83a5222e118168c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20dad9f3ef05f468773db3d7667c9ba"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gaa24652c104082d0725066ea5ac7dc83f">cpTimestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gac20dad9f3ef05f468773db3d7667c9ba">cpSpaceGetCollisionPersistence</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:gac20dad9f3ef05f468773db3d7667c9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cd660a485d0d963f66f8333b2da788"><td class="memItemLeft" align="right" valign="top"><a id="ga49cd660a485d0d963f66f8333b2da788"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetCollisionPersistence</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#gaa24652c104082d0725066ea5ac7dc83f">cpTimestamp</a> collisionPersistence)</td></tr>
<tr class="separator:ga49cd660a485d0d963f66f8333b2da788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f6bbc8db7698065052f4502050dc52"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga20f6bbc8db7698065052f4502050dc52">cpSpaceGetUserData</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:ga20f6bbc8db7698065052f4502050dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510319d0cc108e33cc5ee8b9cc39d449"><td class="memItemLeft" align="right" valign="top"><a id="ga510319d0cc108e33cc5ee8b9cc39d449"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>cpSpaceSetUserData</b> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td></tr>
<tr class="separator:ga510319d0cc108e33cc5ee8b9cc39d449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1306bc87ee883855311aabafb10363"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="structcpBody.html">cpBody</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaaf1306bc87ee883855311aabafb10363">cpSpaceGetStaticBody</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:gaaf1306bc87ee883855311aabafb10363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4819cd09e4590b60eea6b6dc8b4cf80"><td class="memItemLeft" align="right" valign="top">CP_EXPORT cpFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gad4819cd09e4590b60eea6b6dc8b4cf80">cpSpaceGetCurrentTimeStep</a> (const <a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="separator:gad4819cd09e4590b60eea6b6dc8b4cf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72c9085853f1d612226ec7b6faca362"><td class="memItemLeft" align="right" valign="top"><a id="gad72c9085853f1d612226ec7b6faca362"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gad72c9085853f1d612226ec7b6faca362">cpSpaceIsLocked</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gad72c9085853f1d612226ec7b6faca362"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true from inside a callback when objects cannot be added/removed. <br /></td></tr>
<tr class="separator:gad72c9085853f1d612226ec7b6faca362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6773756745d7889196ae14900b9752b"><td class="memItemLeft" align="right" valign="top"><a id="gae6773756745d7889196ae14900b9752b"></a>
CP_EXPORT <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gae6773756745d7889196ae14900b9752b">cpSpaceAddDefaultCollisionHandler</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:gae6773756745d7889196ae14900b9752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or return the existing collision handler that is called for all collisions that are not handled by a more specific collision handler. <br /></td></tr>
<tr class="separator:gae6773756745d7889196ae14900b9752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65edd7f02956f072b87daf7b42e61cf2"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga65edd7f02956f072b87daf7b42e61cf2">cpSpaceAddCollisionHandler</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#gae83e2f50965eb441e36ffff1e32e6d02">cpCollisionType</a> a, <a class="el" href="group__basicTypes.html#gae83e2f50965eb441e36ffff1e32e6d02">cpCollisionType</a> b)</td></tr>
<tr class="separator:ga65edd7f02956f072b87daf7b42e61cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75da454abaca74204a35d03d4f4ca5d8"><td class="memItemLeft" align="right" valign="top"><a id="ga75da454abaca74204a35d03d4f4ca5d8"></a>
CP_EXPORT <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga75da454abaca74204a35d03d4f4ca5d8">cpSpaceAddWildcardHandler</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#gae83e2f50965eb441e36ffff1e32e6d02">cpCollisionType</a> type)</td></tr>
<tr class="memdesc:ga75da454abaca74204a35d03d4f4ca5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or return the existing wildcard collision handler for the specified type. <br /></td></tr>
<tr class="separator:ga75da454abaca74204a35d03d4f4ca5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5728f811290d821c009d1d07b62c06a"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="structcpShape.html">cpShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gad5728f811290d821c009d1d07b62c06a">cpSpaceAddShape</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpShape.html">cpShape</a> *shape)</td></tr>
<tr class="separator:gad5728f811290d821c009d1d07b62c06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194141a199dd59d1387074aabc292280"><td class="memItemLeft" align="right" valign="top"><a id="ga194141a199dd59d1387074aabc292280"></a>
CP_EXPORT <a class="el" href="structcpBody.html">cpBody</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga194141a199dd59d1387074aabc292280">cpSpaceAddBody</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpBody.html">cpBody</a> *body)</td></tr>
<tr class="memdesc:ga194141a199dd59d1387074aabc292280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rigid body to the simulation. <br /></td></tr>
<tr class="separator:ga194141a199dd59d1387074aabc292280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2ddb030b45f59f294ee72ba945891a"><td class="memItemLeft" align="right" valign="top"><a id="ga2d2ddb030b45f59f294ee72ba945891a"></a>
CP_EXPORT <a class="el" href="structcpConstraint.html">cpConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga2d2ddb030b45f59f294ee72ba945891a">cpSpaceAddConstraint</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpConstraint.html">cpConstraint</a> *constraint)</td></tr>
<tr class="memdesc:ga2d2ddb030b45f59f294ee72ba945891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint to the simulation. <br /></td></tr>
<tr class="separator:ga2d2ddb030b45f59f294ee72ba945891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd58c37e69a7575b829e25ed3c427fc8"><td class="memItemLeft" align="right" valign="top"><a id="gadd58c37e69a7575b829e25ed3c427fc8"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gadd58c37e69a7575b829e25ed3c427fc8">cpSpaceRemoveShape</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpShape.html">cpShape</a> *shape)</td></tr>
<tr class="memdesc:gadd58c37e69a7575b829e25ed3c427fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a collision shape from the simulation. <br /></td></tr>
<tr class="separator:gadd58c37e69a7575b829e25ed3c427fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3375e5b056a887baaedd75fa1403d1cf"><td class="memItemLeft" align="right" valign="top"><a id="ga3375e5b056a887baaedd75fa1403d1cf"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga3375e5b056a887baaedd75fa1403d1cf">cpSpaceRemoveBody</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpBody.html">cpBody</a> *body)</td></tr>
<tr class="memdesc:ga3375e5b056a887baaedd75fa1403d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a rigid body from the simulation. <br /></td></tr>
<tr class="separator:ga3375e5b056a887baaedd75fa1403d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec0e391838c99b4b3cbd49d5f28e609"><td class="memItemLeft" align="right" valign="top"><a id="gaeec0e391838c99b4b3cbd49d5f28e609"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaeec0e391838c99b4b3cbd49d5f28e609">cpSpaceRemoveConstraint</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpConstraint.html">cpConstraint</a> *constraint)</td></tr>
<tr class="memdesc:gaeec0e391838c99b4b3cbd49d5f28e609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a constraint from the simulation. <br /></td></tr>
<tr class="separator:gaeec0e391838c99b4b3cbd49d5f28e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3d88fb51ede38bc5e84f31518d0a83"><td class="memItemLeft" align="right" valign="top"><a id="ga1c3d88fb51ede38bc5e84f31518d0a83"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga1c3d88fb51ede38bc5e84f31518d0a83">cpSpaceContainsShape</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpShape.html">cpShape</a> *shape)</td></tr>
<tr class="memdesc:ga1c3d88fb51ede38bc5e84f31518d0a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a collision shape has been added to the space. <br /></td></tr>
<tr class="separator:ga1c3d88fb51ede38bc5e84f31518d0a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d240d6dd4742b465590f60909681862"><td class="memItemLeft" align="right" valign="top"><a id="ga7d240d6dd4742b465590f60909681862"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga7d240d6dd4742b465590f60909681862">cpSpaceContainsBody</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpBody.html">cpBody</a> *body)</td></tr>
<tr class="memdesc:ga7d240d6dd4742b465590f60909681862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a rigid body has been added to the space. <br /></td></tr>
<tr class="separator:ga7d240d6dd4742b465590f60909681862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49f0495a0e0fda2dc76ae66c3bc637a"><td class="memItemLeft" align="right" valign="top"><a id="gaf49f0495a0e0fda2dc76ae66c3bc637a"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaf49f0495a0e0fda2dc76ae66c3bc637a">cpSpaceContainsConstraint</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpConstraint.html">cpConstraint</a> *constraint)</td></tr>
<tr class="memdesc:gaf49f0495a0e0fda2dc76ae66c3bc637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a constraint has been added to the space. <br /></td></tr>
<tr class="separator:gaf49f0495a0e0fda2dc76ae66c3bc637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbf3c0722a5618ded1ed7371cbebcb3"><td class="memItemLeft" align="right" valign="top">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga6fbf3c0722a5618ded1ed7371cbebcb3">cpSpaceAddPostStepCallback</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__cpSpace.html#ga93e9005e387fec86eeb4a225ac295a23">cpPostStepFunc</a> func, void *key, void *data)</td></tr>
<tr class="separator:ga6fbf3c0722a5618ded1ed7371cbebcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62eea2b00f5503976ef250a33d4c474a"><td class="memItemLeft" align="right" valign="top"><a id="ga62eea2b00f5503976ef250a33d4c474a"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga62eea2b00f5503976ef250a33d4c474a">cpSpacePointQuery</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpVect.html">cpVect</a> point, cpFloat maxDistance, <a class="el" href="structcpShapeFilter.html">cpShapeFilter</a> filter, <a class="el" href="group__cpSpace.html#ga646a55f0937f07c19b24561ed5341221">cpSpacePointQueryFunc</a> func, void *data)</td></tr>
<tr class="memdesc:ga62eea2b00f5503976ef250a33d4c474a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the space at a point and call <code>func</code> for each shape found. <br /></td></tr>
<tr class="separator:ga62eea2b00f5503976ef250a33d4c474a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9000c50c4e33b2255d8c3d4c376f0699"><td class="memItemLeft" align="right" valign="top"><a id="ga9000c50c4e33b2255d8c3d4c376f0699"></a>
CP_EXPORT <a class="el" href="structcpShape.html">cpShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga9000c50c4e33b2255d8c3d4c376f0699">cpSpacePointQueryNearest</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpVect.html">cpVect</a> point, cpFloat maxDistance, <a class="el" href="structcpShapeFilter.html">cpShapeFilter</a> filter, <a class="el" href="structcpPointQueryInfo.html">cpPointQueryInfo</a> *out)</td></tr>
<tr class="memdesc:ga9000c50c4e33b2255d8c3d4c376f0699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the space at a point and return the nearest shape found. Returns NULL if no shapes were found. <br /></td></tr>
<tr class="separator:ga9000c50c4e33b2255d8c3d4c376f0699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b9a1e185bea2680a1bc6c798f86049"><td class="memItemLeft" align="right" valign="top"><a id="ga16b9a1e185bea2680a1bc6c798f86049"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga16b9a1e185bea2680a1bc6c798f86049">cpSpaceSegmentQuery</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpVect.html">cpVect</a> start, <a class="el" href="structcpVect.html">cpVect</a> end, cpFloat radius, <a class="el" href="structcpShapeFilter.html">cpShapeFilter</a> filter, <a class="el" href="group__cpSpace.html#ga9046beaeba5728c5e954f0f1dc2ae130">cpSpaceSegmentQueryFunc</a> func, void *data)</td></tr>
<tr class="memdesc:ga16b9a1e185bea2680a1bc6c798f86049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a directed line segment query (like a raycast) against the space calling <code>func</code> for each shape intersected. <br /></td></tr>
<tr class="separator:ga16b9a1e185bea2680a1bc6c798f86049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5e74241b96f6feff02476030007e68"><td class="memItemLeft" align="right" valign="top"><a id="ga3e5e74241b96f6feff02476030007e68"></a>
CP_EXPORT <a class="el" href="structcpShape.html">cpShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga3e5e74241b96f6feff02476030007e68">cpSpaceSegmentQueryFirst</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpVect.html">cpVect</a> start, <a class="el" href="structcpVect.html">cpVect</a> end, cpFloat radius, <a class="el" href="structcpShapeFilter.html">cpShapeFilter</a> filter, <a class="el" href="structcpSegmentQueryInfo.html">cpSegmentQueryInfo</a> *out)</td></tr>
<tr class="memdesc:ga3e5e74241b96f6feff02476030007e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns NULL if no shapes were hit. <br /></td></tr>
<tr class="separator:ga3e5e74241b96f6feff02476030007e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e4737a3b33755ee20066297138b64e"><td class="memItemLeft" align="right" valign="top">CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga09e4737a3b33755ee20066297138b64e">cpSpaceBBQuery</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpBB.html">cpBB</a> bb, <a class="el" href="structcpShapeFilter.html">cpShapeFilter</a> filter, <a class="el" href="group__cpSpace.html#ga02779238e9b8c07797aae6139fad203c">cpSpaceBBQueryFunc</a> func, void *data)</td></tr>
<tr class="separator:ga09e4737a3b33755ee20066297138b64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a87a09145f33a72404c77cce54e4778"><td class="memItemLeft" align="right" valign="top"><a id="ga8a87a09145f33a72404c77cce54e4778"></a>
CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga8a87a09145f33a72404c77cce54e4778">cpSpaceShapeQuery</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpShape.html">cpShape</a> *shape, <a class="el" href="group__cpSpace.html#gab124952dd71dea36688f6ff6ff8bdcb2">cpSpaceShapeQueryFunc</a> func, void *data)</td></tr>
<tr class="memdesc:ga8a87a09145f33a72404c77cce54e4778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a space for any shapes overlapping the given shape and call <code>func</code> for each shape found. <br /></td></tr>
<tr class="separator:ga8a87a09145f33a72404c77cce54e4778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8119f11a4c6a44d82fb15a5873c42607"><td class="memItemLeft" align="right" valign="top"><a id="ga8119f11a4c6a44d82fb15a5873c42607"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga8119f11a4c6a44d82fb15a5873c42607">cpSpaceEachBody</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__cpSpace.html#ga2870b1128c5bfe79cb261d269abdea64">cpSpaceBodyIteratorFunc</a> func, void *data)</td></tr>
<tr class="memdesc:ga8119f11a4c6a44d82fb15a5873c42607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>func</code> for each body in the space. <br /></td></tr>
<tr class="separator:ga8119f11a4c6a44d82fb15a5873c42607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab586704d72681645d9e91d42e97f96ff"><td class="memItemLeft" align="right" valign="top"><a id="gab586704d72681645d9e91d42e97f96ff"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab586704d72681645d9e91d42e97f96ff">cpSpaceEachShape</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__cpSpace.html#gafae017c9a8a7c082032035bf165e4ec9">cpSpaceShapeIteratorFunc</a> func, void *data)</td></tr>
<tr class="memdesc:gab586704d72681645d9e91d42e97f96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>func</code> for each shape in the space. <br /></td></tr>
<tr class="separator:gab586704d72681645d9e91d42e97f96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f494c054cb89a0a842ef1a0e344ce58"><td class="memItemLeft" align="right" valign="top"><a id="ga0f494c054cb89a0a842ef1a0e344ce58"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga0f494c054cb89a0a842ef1a0e344ce58">cpSpaceEachConstraint</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__cpSpace.html#ga0bf20ed2411342352dc43b71c60649c1">cpSpaceConstraintIteratorFunc</a> func, void *data)</td></tr>
<tr class="memdesc:ga0f494c054cb89a0a842ef1a0e344ce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>func</code> for each shape in the space. <br /></td></tr>
<tr class="separator:ga0f494c054cb89a0a842ef1a0e344ce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714f105c977f9006128981fa30d8e7ec"><td class="memItemLeft" align="right" valign="top"><a id="ga714f105c977f9006128981fa30d8e7ec"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga714f105c977f9006128981fa30d8e7ec">cpSpaceReindexStatic</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space)</td></tr>
<tr class="memdesc:ga714f105c977f9006128981fa30d8e7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the collision detection info for the static shapes in the space. <br /></td></tr>
<tr class="separator:ga714f105c977f9006128981fa30d8e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab370e5ee7912ff798bebeb01fc0ba63b"><td class="memItemLeft" align="right" valign="top"><a id="gab370e5ee7912ff798bebeb01fc0ba63b"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gab370e5ee7912ff798bebeb01fc0ba63b">cpSpaceReindexShape</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpShape.html">cpShape</a> *shape)</td></tr>
<tr class="memdesc:gab370e5ee7912ff798bebeb01fc0ba63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the collision detection data for a specific shape in the space. <br /></td></tr>
<tr class="separator:gab370e5ee7912ff798bebeb01fc0ba63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a141b9c927102b02a84bb2b8631f803"><td class="memItemLeft" align="right" valign="top"><a id="ga9a141b9c927102b02a84bb2b8631f803"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga9a141b9c927102b02a84bb2b8631f803">cpSpaceReindexShapesForBody</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpBody.html">cpBody</a> *body)</td></tr>
<tr class="memdesc:ga9a141b9c927102b02a84bb2b8631f803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the collision detection data for all shapes attached to a body. <br /></td></tr>
<tr class="separator:ga9a141b9c927102b02a84bb2b8631f803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed394ccafade6346f25e9c78f92bc185"><td class="memItemLeft" align="right" valign="top"><a id="gaed394ccafade6346f25e9c78f92bc185"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gaed394ccafade6346f25e9c78f92bc185">cpSpaceUseSpatialHash</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat dim, int count)</td></tr>
<tr class="memdesc:gaed394ccafade6346f25e9c78f92bc185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch the space to use a spatial has as it's spatial index. <br /></td></tr>
<tr class="separator:gaed394ccafade6346f25e9c78f92bc185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87c828de2fe3709393ba94046212d80"><td class="memItemLeft" align="right" valign="top"><a id="gae87c828de2fe3709393ba94046212d80"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#gae87c828de2fe3709393ba94046212d80">cpSpaceStep</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, cpFloat dt)</td></tr>
<tr class="memdesc:gae87c828de2fe3709393ba94046212d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step the space forward in time by <code>dt</code>. <br /></td></tr>
<tr class="separator:gae87c828de2fe3709393ba94046212d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e8a34681aff3f29bd976e830f3b6da"><td class="memItemLeft" align="right" valign="top"><a id="ga02e8a34681aff3f29bd976e830f3b6da"></a>
CP_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpSpace.html#ga02e8a34681aff3f29bd976e830f3b6da">cpSpaceDebugDraw</a> (<a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="structcpSpaceDebugDrawOptions.html">cpSpaceDebugDrawOptions</a> *options)</td></tr>
<tr class="memdesc:ga02e8a34681aff3f29bd976e830f3b6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug draw the current state of the space using the supplied drawing options. <br /></td></tr>
<tr class="separator:ga02e8a34681aff3f29bd976e830f3b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3134f145bfc7ca4ef69b350978c26a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3134f145bfc7ca4ef69b350978c26a5a">&#9670;&nbsp;</a></span>cpCollisionBeginFunc <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(* cpCollisionBeginFunc) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collision begin event function callback type. Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding. </p>

</div>
</div>
<a id="ga3134f145bfc7ca4ef69b350978c26a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3134f145bfc7ca4ef69b350978c26a5a">&#9670;&nbsp;</a></span>cpCollisionBeginFunc <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(* cpCollisionBeginFunc) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collision begin event function callback type. Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding. </p>

</div>
</div>
<a id="ga89b24d53d81a5a028198c3c2d3c39a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b24d53d81a5a028198c3c2d3c39a9d">&#9670;&nbsp;</a></span>cpCollisionPreSolveFunc <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(* cpCollisionPreSolveFunc) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collision pre-solve event function callback type. Returning false from a pre-step callback causes the collision to be ignored until the next step. </p>

</div>
</div>
<a id="ga89b24d53d81a5a028198c3c2d3c39a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b24d53d81a5a028198c3c2d3c39a9d">&#9670;&nbsp;</a></span>cpCollisionPreSolveFunc <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a>(* cpCollisionPreSolveFunc) (<a class="el" href="structcpArbiter.html">cpArbiter</a> *arb, <a class="el" href="structcpSpace.html">cpSpace</a> *space, <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collision pre-solve event function callback type. Returning false from a pre-step callback causes the collision to be ignored until the next step. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga65edd7f02956f072b87daf7b42e61cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65edd7f02956f072b87daf7b42e61cf2">&#9670;&nbsp;</a></span>cpSpaceAddCollisionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="structcpCollisionHandler.html">cpCollisionHandler</a> * cpSpaceAddCollisionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__basicTypes.html#gae83e2f50965eb441e36ffff1e32e6d02">cpCollisionType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__basicTypes.html#gae83e2f50965eb441e36ffff1e32e6d02">cpCollisionType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create or return the existing collision handler for the specified pair of collision types. If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers. </p>

</div>
</div>
<a id="ga6fbf3c0722a5618ded1ed7371cbebcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbf3c0722a5618ded1ed7371cbebcb3">&#9670;&nbsp;</a></span>cpSpaceAddPostStepCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gabc5e752c48f3449ca26ef413ecbd647e">cpBool</a> cpSpaceAddPostStepCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpSpace.html#ga93e9005e387fec86eeb4a225ac295a23">cpPostStepFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a post-step callback to be called when <a class="el" href="group__cpSpace.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt. ">cpSpaceStep()</a> finishes. You can only register one callback per unique value for <code>key</code>. Returns true only if <code>key</code> has never been scheduled before. It's possible to pass <code>NULL</code> for <code>func</code> if you only want to mark <code>key</code> as being used. </p>

</div>
</div>
<a id="gad5728f811290d821c009d1d07b62c06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5728f811290d821c009d1d07b62c06a">&#9670;&nbsp;</a></span>cpSpaceAddShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="structcpShape.html">cpShape</a> * cpSpaceAddShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpShape.html">cpShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a collision shape to the simulation. If the shape is attached to a static body, it will be added as a static shape. </p>

</div>
</div>
<a id="ga09e4737a3b33755ee20066297138b64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e4737a3b33755ee20066297138b64e">&#9670;&nbsp;</a></span>cpSpaceBBQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT void cpSpaceBBQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpBB.html">cpBB</a>&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpShapeFilter.html">cpShapeFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpSpace.html#ga02779238e9b8c07797aae6139fad203c">cpSpaceBBQueryFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a fast rectangle query on the space calling <code>func</code> for each shape found. Only the shape's bounding boxes are checked for overlap, not their full shape. </p>

</div>
</div>
<a id="ga53b093e1cbb978e00faf9216e1f9ab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b093e1cbb978e00faf9216e1f9ab4f">&#9670;&nbsp;</a></span>cpSpaceGetCollisionBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetCollisionBias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines how fast overlapping shapes are pushed apart. Expressed as a fraction of the error remaining after each second. Defaults to pow(1.0 - 0.1, 60.0) meaning that Chipmunk fixes 10% of overlap each frame at 60Hz. </p>

</div>
</div>
<a id="gac20dad9f3ef05f468773db3d7667c9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20dad9f3ef05f468773db3d7667c9ba">&#9670;&nbsp;</a></span>cpSpaceGetCollisionPersistence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#gaa24652c104082d0725066ea5ac7dc83f">cpTimestamp</a> cpSpaceGetCollisionPersistence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of frames that contact information should persist. Defaults to 3. There is probably never a reason to change this value. </p>

</div>
</div>
<a id="ga7b5e6178a021b1b6bba4b70876bf79d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5e6178a021b1b6bba4b70876bf79d0">&#9670;&nbsp;</a></span>cpSpaceGetCollisionSlop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetCollisionSlop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Amount of encouraged penetration between colliding shapes. Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap. </p>

</div>
</div>
<a id="gad4819cd09e4590b60eea6b6dc8b4cf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4819cd09e4590b60eea6b6dc8b4cf80">&#9670;&nbsp;</a></span>cpSpaceGetCurrentTimeStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetCurrentTimeStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current (or most recent) time step used with the given space. Useful from callbacks if your time step is not a compile-time global. </p>

</div>
</div>
<a id="gac00ad0e4956e444fa23874fae68df3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00ad0e4956e444fa23874fae68df3b7">&#9670;&nbsp;</a></span>cpSpaceGetDamping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetDamping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Damping rate expressed as the fraction of velocity bodies retain each second. A value of 0.9 would mean that each body's velocity will drop 10% per second. The default value is 1.0, meaning no damping is applied. </p><dl class="section note"><dt>Note</dt><dd>This damping value is different than those of <a class="el" href="structcpDampedSpring.html">cpDampedSpring</a> and <a class="el" href="structcpDampedRotarySpring.html">cpDampedRotarySpring</a>. </dd></dl>

</div>
</div>
<a id="ga256c38475826c4c165999079929fe1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256c38475826c4c165999079929fe1e7">&#9670;&nbsp;</a></span>cpSpaceGetIdleSpeedThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetIdleSpeedThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classSpeed.html" title="Changes the speed of an action, making it take longer (speed&gt;1) or shorter (speed&lt;1) time...">Speed</a> threshold for a body to be considered idle. The default value of 0 means to let the space guess a good threshold based on gravity. </p>

</div>
</div>
<a id="gab3f74ae04501ce532913c87e5be54a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f74ae04501ce532913c87e5be54a80">&#9670;&nbsp;</a></span>cpSpaceGetSleepTimeThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT cpFloat cpSpaceGetSleepTimeThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time a group of bodies must remain idle in order to fall asleep. Enabling sleeping also implicitly enables the the contact graph. The default value of INFINITY disables the sleeping algorithm. </p>

</div>
</div>
<a id="gaaf1306bc87ee883855311aabafb10363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1306bc87ee883855311aabafb10363">&#9670;&nbsp;</a></span>cpSpaceGetStaticBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="structcpBody.html">cpBody</a> * cpSpaceGetStaticBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Space provided static body for a given <a class="el" href="structcpSpace.html">cpSpace</a>. This is merely provided for convenience and you are not required to use it. </p>

</div>
</div>
<a id="ga20f6bbc8db7698065052f4502050dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20f6bbc8db7698065052f4502050dc52">&#9670;&nbsp;</a></span>cpSpaceGetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CP_EXPORT <a class="el" href="group__basicTypes.html#ga2ac2c3c31e21893941f9e4f8ee279447">cpDataPointer</a> cpSpaceGetUserData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpSpace.html">cpSpace</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User definable data pointer. Generally this points to your game's controller or game state class so you can access it when given a <a class="el" href="structcpSpace.html">cpSpace</a> reference in a callback. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
